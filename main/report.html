
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>certstream: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/certstream/certificate.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/certstream/certstream.go (84.2%)</option>
				
				<option value="file2">github.com/linkdata/certstream/config.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/certstream/errlogidle.go (0.0%)</option>
				
				<option value="file4">github.com/linkdata/certstream/getloglist.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/certstream/jsoncertificate.go (63.0%)</option>
				
				<option value="file6">github.com/linkdata/certstream/jsonidentity.go (91.7%)</option>
				
				<option value="file7">github.com/linkdata/certstream/logentry.go (84.8%)</option>
				
				<option value="file8">github.com/linkdata/certstream/logoperator.go (74.0%)</option>
				
				<option value="file9">github.com/linkdata/certstream/logstream.go (81.2%)</option>
				
				<option value="file10">github.com/linkdata/certstream/operatordomain.go (100.0%)</option>
				
				<option value="file11">github.com/linkdata/certstream/pgbackfill.go (76.2%)</option>
				
				<option value="file12">github.com/linkdata/certstream/pgbatcher.go (91.8%)</option>
				
				<option value="file13">github.com/linkdata/certstream/pgcertificate.go (0.0%)</option>
				
				<option value="file14">github.com/linkdata/certstream/pgdb.go (55.1%)</option>
				
				<option value="file15">github.com/linkdata/certstream/pgdnsname.go (0.0%)</option>
				
				<option value="file16">github.com/linkdata/certstream/pgdnsnamesview.go (0.0%)</option>
				
				<option value="file17">github.com/linkdata/certstream/pgident.go (0.0%)</option>
				
				<option value="file18">github.com/linkdata/certstream/pglogentry.go (0.0%)</option>
				
				<option value="file19">github.com/linkdata/certstream/streamerror.go (100.0%)</option>
				
				<option value="file20">github.com/linkdata/certstream/updatestreams.go (97.3%)</option>
				
				<option value="file21">github.com/linkdata/certstream/wraperr.go (40.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package certstream

import (
        "slices"
        "time"

        "github.com/google/certificate-transparency-go/x509"
)

type Certificate struct {
        PreCert   bool
        Seen      time.Time
        Signature []byte
        *x509.Certificate
}

func (c *Certificate) GetCommonName() (s string) <span class="cov10" title="1232">{
        if s = c.Subject.CommonName; s == "" </span><span class="cov7" title="132">{
                if len(c.DNSNames) &gt; 0 </span><span class="cov7" title="130">{
                        names := slices.Clone(c.DNSNames)
                        slices.Sort(names)
                        s = c.DNSNames[0]
                }</span>
        }
        <span class="cov10" title="1232">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package certstream

import (
        "context"
        "errors"
        "net/http"
        "slices"
        "strings"
        "sync"
        "time"
)

type CertStream struct {
        Config                       // copy of config
        C           &lt;-chan *LogEntry // log entry channel
        HeadClient  *http.Client     // main HTTP client, uses Config.HeadDialer
        TailClient  *http.Client     // may be nil if not backfilling
        db          *PgDB
        mu          sync.Mutex // protects following
        sendEntryCh chan *LogEntry
        operators   map[string]*LogOperator // operators by operator domain, valid after Start()
}

var DefaultTransport = &amp;http.Transport{
        TLSHandshakeTimeout:   30 * time.Second,
        ResponseHeaderTimeout: 30 * time.Second,
        MaxIdleConnsPerHost:   2,
        DisableKeepAlives:     false,
        ExpectContinueTimeout: 1 * time.Second,
        ForceAttemptHTTP2:     true,
}

func (cs *CertStream) LogInfo(msg string, args ...any) <span class="cov5" title="41">{
        if cs.Config.Logger != nil </span><span class="cov5" title="41">{
                cs.Config.Logger.Info("certstream: "+msg, args...)
        }</span>
}

func (cs *CertStream) LogError(err error, msg string, args ...any) error <span class="cov6" title="199">{
        if err != nil &amp;&amp; cs.Config.Logger != nil </span><span class="cov5" title="64">{
                if !errors.Is(err, context.Canceled) &amp;&amp; !errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        if unwrapper, ok := err.(interface{ Unwrap() []error }); ok </span><span class="cov0" title="0">{
                                for _, e := range unwrapper.Unwrap() </span><span class="cov0" title="0">{
                                        cs.Config.Logger.Error("certstream: "+msg, append(args, "err", e)...)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cs.Config.Logger.Error("certstream: "+msg, append(args, "err", err)...)
                        }</span>
                }
        }
        <span class="cov6" title="199">return err</span>
}

func (cs *CertStream) Operators() (operators []*LogOperator) <span class="cov1" title="1">{
        cs.mu.Lock()
        for _, logop := range cs.operators </span><span class="cov2" title="6">{
                operators = append(operators, logop)
        }</span>
        <span class="cov1" title="1">cs.mu.Unlock()
        slices.SortFunc(operators, func(a, b *LogOperator) int </span><span class="cov3" title="7">{ return strings.Compare(a.Name, b.Name) }</span>)
        <span class="cov1" title="1">return</span>
}

func (cs *CertStream) CountStreams() (n int) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, logop := range cs.operators </span><span class="cov0" title="0">{
                logop.mu.Lock()
                n += len(logop.streams)
                logop.mu.Unlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cs *CertStream) getSendEntryCh() (ch chan *LogEntry) <span class="cov6" title="144">{
        cs.mu.Lock()
        ch = cs.sendEntryCh
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) DB() (db *PgDB) <span class="cov10" title="4185">{
        cs.mu.Lock()
        db = cs.db
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) Close() <span class="cov1" title="2">{
        cs.mu.Lock()
        seCh := cs.sendEntryCh
        cs.sendEntryCh = nil
        db := cs.db
        cs.db = nil
        cs.mu.Unlock()
        if seCh != nil </span><span class="cov1" title="1">{
                // drain
                ok := true
                for ok </span><span class="cov4" title="19">{
                        select </span>{
                        case _, ok = &lt;-seCh:<span class="cov4" title="18"></span>
                        default:<span class="cov1" title="1">
                                ok = false</span>
                        }
                }
                <span class="cov1" title="1">close(seCh)</span>
        }
        <span class="cov1" title="2">if db != nil </span><span class="cov1" title="1">{
                db.Close()
        }</span>
}

func (cs *CertStream) run(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        ticker := time.NewTicker(time.Hour * 24)

        defer func() </span><span class="cov1" title="1">{
                ticker.Stop()
                wg.Done()
                cs.Close()
        }</span>()

        <span class="cov1" title="1">_ = cs.LogError(cs.updateStreams(ctx, wg), "CertStream:run@1")

        if db := cs.DB(); db != nil </span><span class="cov1" title="1">{
                wg.Add(2)
                go db.runWorkers(ctx, wg)
                go db.estimator(ctx, wg)
        }</span>

        <span class="cov1" title="1">for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        _ = cs.LogError(cs.updateStreams(ctx, wg), "CertStream:run@2")</span>
                }
        }
}

func Start(ctx context.Context, wg *sync.WaitGroup, cfg *Config) (cs *CertStream, err error) <span class="cov1" title="1">{
        tp := DefaultTransport.Clone()
        tp.DialContext = cfg.HeadDialer.DialContext
        cs = &amp;CertStream{
                Config: *cfg,
                HeadClient: &amp;http.Client{
                        Timeout:   10 * time.Second,
                        Transport: tp,
                },
                operators: map[string]*LogOperator{},
        }

        if cs.Config.TailDialer != nil </span><span class="cov1" title="1">{
                tp = DefaultTransport.Clone()
                tp.DialContext = cfg.TailDialer.DialContext
                cs.TailClient = &amp;http.Client{
                        Timeout:   10 * time.Second,
                        Transport: tp,
                }
        }</span>

        <span class="cov1" title="1">var db *PgDB
        if db, err = NewPgDB(ctx, cs); err == nil </span><span class="cov1" title="1">{
                cs.mu.Lock()
                cs.db = db
                cs.sendEntryCh = make(chan *LogEntry, 1024*8)
                cs.C = cs.sendEntryCh
                cs.mu.Unlock()
                wg.Add(1)
                go cs.run(ctx, wg)
        }</span>

        <span class="cov1" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package certstream

import (
        "net"

        "golang.org/x/net/proxy"
)

type Config struct {
        Logger                Logger              // if not nil Logger to use, no default
        HeadDialer            proxy.ContextDialer // dialer for following the head, defaults to &amp;net.Dialer{}
        TailDialer            proxy.ContextDialer // if not nil, backfill db using this dialer, no default
        PgUser                string              // PostgreSQL user, default "certstream"
        PgPass                string              // PostgreSQL password, default "certstream"
        PgName                string              // PostgreSQL db name, default "certstream"
        PgAddr                string              // PostgreSQL address, no default
        PgPrefix              string              // PostgreSQL naming prefix, default "certdb_"
        PgConns               int                 // max number of database connections, default 100
        PgWorkerBits          int                 // number of prefix bits that determine DB workers, default 5 (32 workers)
        PgMaxAge              int                 // maximum age in days to backfill
        PgNoSSL               bool                // if true, do not use SSL
        GetEntriesParallelism int                 // number of concurrent GetRawEntries requests per range, default 8
}

// NewConfig returns a new default Config
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Logger:                nil,
                HeadDialer:            &amp;net.Dialer{},
                TailDialer:            nil,
                PgUser:                "certstream",
                PgPass:                "certstream",
                PgName:                "certstream",
                PgAddr:                "",
                PgPrefix:              "certdb_",
                PgConns:               100,
                PgWorkerBits:          5,
                PgMaxAge:              90,
                GetEntriesParallelism: 8,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type errLogIdle struct {
        Since time.Time
}

func (err errLogIdle) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("log idle since %v", err.Since.Round(time.Second))
}</span>

var ErrLogIdle errLogIdle
</pre>
		
		<pre class="file" id="file4" style="display: none">package certstream

import (
        "context"
        "io"
        "net/http"

        "github.com/google/certificate-transparency-go/loglist3"
)

// GetLogList fetches a CT log list from the given listUrl.
// Usually you would pass loglist3.AllLogListURL for the listUrl.
func GetLogList(ctx context.Context, httpClient *http.Client, listUrl string) (logList *loglist3.LogList, err error) <span class="cov10" title="2">{
        var req *http.Request
        if req, err = http.NewRequestWithContext(ctx, http.MethodGet, listUrl, nil); err == nil </span><span class="cov10" title="2">{
                var resp *http.Response
                if resp, err = httpClient.Do(req); err == nil </span><span class="cov10" title="2">{
                        var b []byte
                        if b, err = io.ReadAll(resp.Body); err == nil </span><span class="cov10" title="2">{
                                logList, err = loglist3.NewFromJSON(b)
                        }</span>
                }
        }
        <span class="cov10" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package certstream

import (
        "encoding/hex"
        "net/mail"
        "slices"
        "sort"
        "strings"
        "time"

        "golang.org/x/net/idna"
)

type hexEncoded []byte

func (h hexEncoded) MarshalText() (text []byte, err error) <span class="cov0" title="0">{
        return hex.AppendEncode(nil, h), nil
}</span>

type JsonCertificate struct {
        PreCert        bool         `json:",omitempty"`
        Signature      hexEncoded   `json:",omitempty"` // SHA256 signature, searchable on crt.sh
        Issuer         JsonIdentity `json:",omitempty"`
        Subject        JsonIdentity `json:",omitempty"`
        CommonName     string       `json:",omitempty"` // Subject common name
        DNSNames       []string     `json:",omitempty"`
        EmailAddresses []string     `json:",omitempty"`
        IPAddresses    []string     `json:",omitempty"`
        URIs           []string     `json:",omitempty"`
        NotBefore      time.Time    `json:",omitempty"`
        NotAfter       time.Time    `json:",omitempty"`
        Since          time.Time    `json:",omitzero"`
}

func NewJSONCertificate(cert *Certificate) (jsoncert *JsonCertificate) <span class="cov10" title="3">{
        jsoncert = &amp;JsonCertificate{
                PreCert:    cert.PreCert,
                Signature:  cert.Signature,
                CommonName: cert.GetCommonName(),
                NotBefore:  cert.NotBefore,
                NotAfter:   cert.NotAfter,
        }
        jsoncert.Issuer.Fill(&amp;cert.Issuer)
        jsoncert.Subject.Fill(&amp;cert.Subject)

        for _, dnsname := range cert.DNSNames </span><span class="cov6" title="2">{
                dnsname = strings.ToLower(dnsname)
                if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov0" title="0">{
                        jsoncert.DNSNames = append(jsoncert.DNSNames, uniname)
                }</span> else<span class="cov6" title="2"> {
                        jsoncert.DNSNames = append(jsoncert.DNSNames, dnsname)
                }</span>
        }
        <span class="cov10" title="3">sort.Strings(jsoncert.DNSNames)

        for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                jsoncert.IPAddresses = append(jsoncert.IPAddresses, ip.String())
        }</span>
        <span class="cov10" title="3">sort.Strings(jsoncert.IPAddresses)

        for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                if m, e := mail.ParseAddress(email); e == nil </span><span class="cov0" title="0">{
                        email = m.Address
                }</span>
                <span class="cov0" title="0">jsoncert.EmailAddresses = append(jsoncert.EmailAddresses, email)</span>
        }
        <span class="cov10" title="3">sort.Strings(jsoncert.EmailAddresses)

        for _, u := range cert.URIs </span><span class="cov0" title="0">{
                jsoncert.URIs = append(jsoncert.URIs, u.String())
        }</span>
        <span class="cov10" title="3">sort.Strings(jsoncert.URIs)
        return</span>
}

func (js *JsonCertificate) SetCommonName() <span class="cov10" title="3">{
        if js.CommonName == "" </span><span class="cov1" title="1">{
                if len(js.DNSNames) &gt; 0 </span><span class="cov0" title="0">{
                        names := slices.Clone(js.DNSNames)
                        slices.Sort(names)
                        js.CommonName = js.DNSNames[0]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package certstream

import (
        "strings"

        "github.com/google/certificate-transparency-go/x509/pkix"
)

type JsonIdentity struct {
        ID           int    `json:",omitempty"`
        Country      string `json:",omitempty"`
        Organization string `json:",omitempty"`
        Province     string `json:",omitempty"`
        CommonName   string `json:",omitempty"`
}

func join(l []string) string <span class="cov10" title="21">{
        var b []byte
        for _, s := range l </span><span class="cov4" title="3">{
                if s = strings.TrimSpace(s); s != "" </span><span class="cov4" title="3">{
                        if len(b) &gt; 0 </span><span class="cov0" title="0">{
                                b = append(b, ' ')
                        }</span>
                        <span class="cov4" title="3">b = append(b, s...)</span>
                }
        }
        <span class="cov10" title="21">return string(b)</span>
}

func (id *JsonIdentity) Fill(name *pkix.Name) <span class="cov6" title="7">{
        if name != nil </span><span class="cov6" title="7">{
                id.Country = join(name.Country)
                id.Organization = join(name.Organization)
                id.Province = join(name.Province)
                id.CommonName = strings.TrimSpace(name.CommonName)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package certstream

import (
        "crypto/sha256"
        "encoding/hex"
        "strconv"
        "strings"
        "time"

        ct "github.com/google/certificate-transparency-go"
        "github.com/google/certificate-transparency-go/x509"
        "golang.org/x/net/idna"
)

type LogEntry struct {
        *LogStream
        Err          error           // error from RawLogEntryFromLeaf or ToLogEntry, or nil
        RawLogEntry  *ct.RawLogEntry // may be nil in case of error
        *ct.LogEntry                 // may be nil in case of error
        Id           int64           // database id, if available
        Historical   bool            // true if the entry is from gap or backfilling
}

func (le *LogEntry) appendJSON(b []byte) []byte <span class="cov7" title="1226">{
        if cert := le.Cert(); cert != nil </span><span class="cov7" title="1226">{
                logindex := le.Index()
                var dnsnames []string
                for _, dnsname := range cert.DNSNames </span><span class="cov8" title="2337">{
                        dnsname = strings.ToLower(dnsname)
                        if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov2" title="4">{
                                ok := true
                                for _, r := range uniname </span><span class="cov5" title="68">{
                                        ok = ok &amp;&amp; strconv.IsPrint(r)
                                }</span>
                                <span class="cov2" title="4">if ok </span><span class="cov2" title="4">{
                                        dnsname = uniname
                                }</span>
                        }
                        <span class="cov8" title="2337">dnsnames = append(dnsnames, dnsname)</span>
                }

                <span class="cov7" title="1226">var ipaddrs []string
                for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                        ipaddrs = append(ipaddrs, ip.String())
                }</span>

                <span class="cov7" title="1226">var emails []string
                for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                        emails = append(emails, strings.ReplaceAll(email, " ", "_"))
                }</span>

                <span class="cov7" title="1226">var uris []string
                for _, uri := range cert.URIs </span><span class="cov0" title="0">{
                        uris = append(uris, strings.ReplaceAll(uri.String(), " ", "%20"))
                }</span>

                <span class="cov7" title="1226">b = append(b, `{`...)
                b = append(b, `"iss_org":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Organization, ","))
                b = append(b, `,"iss_prov":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Province, ","))
                b = append(b, `,"iss_country":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Country, ","))
                b = append(b, `,"sub_org":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Organization, ","))
                b = append(b, `,"sub_prov":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Province, ","))
                b = append(b, `,"sub_country":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Country, ","))
                b = append(b, `,"notbefore":"`...)
                b = append(b, cert.NotBefore.UTC().Format(time.RFC3339)...)
                b = append(b, `","notafter":"`...)
                b = append(b, cert.NotAfter.UTC().Format(time.RFC3339)...)
                b = append(b, `","commonname":`...)
                b = strconv.AppendQuote(b, cert.GetCommonName())
                b = append(b, `,"sha256_hex":"`...)
                b = append(b, hex.EncodeToString(cert.Signature)...)
                b = append(b, `","precert":`...)
                b = strconv.AppendBool(b, cert.PreCert)
                b = append(b, `,"seen":"`...)
                b = append(b, cert.Seen.UTC().Format(time.RFC3339)...)
                b = append(b, `","stream":`...)
                b = strconv.AppendInt(b, int64(le.LogStream.Id), 10)
                b = append(b, `,"logindex":`...)
                b = strconv.AppendInt(b, logindex, 10)
                b = append(b, `,"dnsnames":`...)
                b = strconv.AppendQuote(b, strings.Join(dnsnames, " "))
                b = append(b, `,"ipaddrs":`...)
                b = strconv.AppendQuote(b, strings.Join(ipaddrs, " "))
                b = append(b, `,"emails":`...)
                b = strconv.AppendQuote(b, strings.Join(emails, " "))
                b = append(b, `,"uris":`...)
                b = strconv.AppendQuote(b, strings.Join(uris, " "))
                b = append(b, `}`...)</span>
        } else<span class="cov0" title="0"> {
                b = append(b, `{}`...)
        }</span>
        <span class="cov7" title="1226">return b</span>
}

func (le *LogEntry) String() (s string) <span class="cov1" title="1">{
        var b []byte
        b = append(b, "LogEntry{"...)
        if le != nil </span><span class="cov1" title="1">{
                if le.LogStream != nil </span><span class="cov0" title="0">{
                        if le.Operator != nil </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, le.Operator.Name)
                                b = append(b, ", "...)
                        }</span>
                        <span class="cov0" title="0">if le.Log != nil </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, le.Log.URL)
                                b = append(b, ", "...)
                        }</span>
                }
                <span class="cov1" title="1">b = strconv.AppendInt(b, le.Index(), 10)
                if le.Err != nil </span><span class="cov0" title="0">{
                        b = append(b, ", "...)
                        b = strconv.AppendQuote(b, le.Err.Error())
                }</span>
        }
        <span class="cov1" title="1">b = append(b, '}')
        return string(b)</span>
}

// Cert returns the Certificate given a LogEntry or nil.
func (le *LogEntry) Cert() (crt *Certificate) <span class="cov10" title="9399">{
        if le != nil &amp;&amp; le.LogEntry != nil </span><span class="cov9" title="9397">{
                var cert *x509.Certificate
                var precert bool
                if cert = le.LogEntry.X509Cert; cert == nil </span><span class="cov9" title="3919">{
                        if le.LogEntry.Precert != nil </span><span class="cov9" title="3919">{
                                precert = true
                                cert = le.LogEntry.Precert.TBSCertificate
                        }</span>
                }
                <span class="cov9" title="9397">if cert != nil </span><span class="cov9" title="9397">{
                        crt = &amp;Certificate{
                                PreCert:     precert,
                                Certificate: cert,
                        }
                        if le.RawLogEntry != nil </span><span class="cov9" title="9397">{
                                shasig := sha256.Sum256(le.RawLogEntry.Cert.Data)
                                crt.Signature = shasig[:]
                                tse := int64(le.RawLogEntry.Leaf.TimestampedEntry.Timestamp) //#nosec G115
                                crt.Seen = time.UnixMilli(tse).UTC()
                        }</span> else<span class="cov0" title="0"> {
                                shasig := sha256.Sum256(cert.RawTBSCertificate)
                                crt.Signature = shasig[:]
                                crt.Seen = time.Now().UTC()
                        }</span>
                }
        }
        <span class="cov10" title="9399">return</span>
}

// Index returns the log index or -1 if none is available.
func (le *LogEntry) Index() (index int64) <span class="cov7" title="1229">{
        index = -1
        if le.RawLogEntry != nil </span><span class="cov7" title="1228">{
                index = le.RawLogEntry.Index
        }</span>
        <span class="cov7" title="1229">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package certstream

import (
        "context"
        "slices"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
)

type LogOperator struct {
        *CertStream
        *loglist3.Operator
        Domain   string       // e.g. "letsencrypt.org" or "googleapis.com"
        Count    atomic.Int64 // atomic; sum of the stream's Count
        Id       int32        // database ID, if available
        mu       sync.Mutex   // protects following
        streams  map[string]*LogStream
        errcount int
        errors   []*StreamError
}

func (lo *LogOperator) StreamCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = len(lo.streams)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) ErrorCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = lo.errcount
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) Errors() (errs []*StreamError) <span class="cov0" title="0">{
        lo.mu.Lock()
        errs = append(errs, lo.errors...)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) addError(ls *LogStream, err error) <span class="cov8" title="37">{
        if err != nil </span><span class="cov8" title="37">{
                now := time.Now()
                lo.mu.Lock()
                defer lo.mu.Unlock()
                lo.errors = append(lo.errors, &amp;StreamError{LogStream: ls, When: now, Err: err})
                if len(lo.errors) &gt; MaxErrors </span><span class="cov0" title="0">{
                        lo.errors = slices.Delete(lo.errors, 0, len(lo.errors)-MaxErrors)
                }</span>
                <span class="cov8" title="37">ls.errcount++</span>
        }
}

func (lo *LogOperator) Streams() (sl []*LogStream) <span class="cov4" title="6">{
        lo.mu.Lock()
        for _, s := range lo.streams </span><span class="cov8" title="31">{
                sl = append(sl, s)
        }</span>
        <span class="cov4" title="6">lo.mu.Unlock()
        slices.SortFunc(sl, func(a, b *LogStream) int </span><span class="cov10" title="66">{ return strings.Compare(a.URL, b.URL) }</span>)
        <span class="cov4" title="6">return</span>
}

func (lo *LogOperator) makeStream(log *loglist3.Log) (ls *LogStream, err error) <span class="cov8" title="31">{
        var headLogClient *client.LogClient
        if headLogClient, err = client.New(log.URL, lo.HeadClient, jsonclient.Options{}); err == nil </span><span class="cov8" title="31">{
                var tailLogClient *client.LogClient
                if lo.TailClient != nil </span><span class="cov8" title="31">{
                        tailLogClient, err = client.New(log.URL, lo.TailClient, jsonclient.Options{})
                }</span>
                <span class="cov8" title="31">ls = &amp;LogStream{
                        LogOperator: lo,
                        Log:         log,
                        HeadClient:  headLogClient,
                        TailClient:  tailLogClient,
                }
                ls.MinIndex.Store(-1)
                ls.MaxIndex.Store(-1)
                ls.LastIndex.Store(-1)</span>
        }
        <span class="cov8" title="31">return</span>
}

func (lo *LogOperator) ensureStream(ctx context.Context, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov8" title="31">{
        lo.mu.Lock()
        ls := lo.streams[log.URL]
        lo.mu.Unlock()
        if ls == nil </span><span class="cov8" title="31">{
                if ls, err = lo.makeStream(log); err == nil </span><span class="cov8" title="31">{
                        if db := lo.DB(); db != nil </span><span class="cov8" title="31">{
                                if err = db.ensureStream(ctx, ls); err == nil </span><span class="cov8" title="31">{
                                        lo.mu.Lock()
                                        lo.streams[log.URL] = ls
                                        lo.mu.Unlock()
                                        wg.Add(1)
                                        go ls.run(ctx, wg)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="31">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "math/rand/v2"
        "net/http"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        ct "github.com/google/certificate-transparency-go"
        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
        "github.com/google/trillian/client/backoff"
)

var DbBatchSize = 1000
var LogBatchSize = int64(1000)
var MaxErrors = 100
var IdleCloseTime = time.Hour * 24 * 7

type handleEntryFn func(ctx context.Context, now time.Time, logindex int64, entry ct.LeafEntry, historical bool) (wanted bool)

type LogStream struct {
        *LogOperator
        *loglist3.Log
        HeadClient *client.LogClient
        TailClient *client.LogClient
        Count      atomic.Int64 // number of certificates sent to the channel
        MinIndex   atomic.Int64 // atomic: lowest index seen so far, -1 if none seen yet
        MaxIndex   atomic.Int64 // atomic: highest index seen so far, -1 if none seen yet
        LastIndex  atomic.Int64 // atomic: highest index that is available from stream source
        InsideGaps atomic.Int64 // atomic: number of remaining entries inside gaps
        Id         int32        // database ID, if available
}

func (ls *LogStream) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("LogStream{%q}", ls.Log.URL)
}</span>

func sleep(ctx context.Context, d time.Duration) <span class="cov0" title="0">{
        tmr := time.NewTimer(d)
        defer tmr.Stop()
        select </span>{
        case &lt;-tmr.C:<span class="cov0" title="0"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        }
}

func (ls *LogStream) getEndSeen(ctx context.Context, end int64) (seen time.Time) <span class="cov4" title="31">{
        fn := func(ctx context.Context, now time.Time, logindex int64, entry ct.LeafEntry, historical bool) (wanted bool) </span><span class="cov4" title="31">{
                le := ls.makeLogEntry(logindex, entry, historical)
                if cert := le.Cert(); cert != nil </span><span class="cov4" title="31">{
                        seen = cert.Seen
                }</span>
                <span class="cov4" title="31">return</span>
        }
        <span class="cov4" title="31">ls.GetRawEntries(ctx, end, end, false, fn, nil)
        return</span>
}

func (ls *LogStream) run(ctx context.Context, wg *sync.WaitGroup) <span class="cov4" title="31">{
        var end int64
        var err error
        var wg2 sync.WaitGroup
        defer func() </span><span class="cov4" title="31">{
                ls.addError(ls, err)
                wg2.Wait()
                ls.removeStream(ls)
                if e, ok := err.(errLogIdle); ok </span><span class="cov0" title="0">{
                        ls.LogInfo("stream stopped", "url", ls.URL, "stream", ls.Id, "idle-since", e.Since)
                }</span> else<span class="cov4" title="31"> {
                        _ = ls.LogError(err, "stream stopped", "url", ls.URL, "stream", ls.Id)
                }</span>
                <span class="cov4" title="31">wg.Done()</span>
        }()

        <span class="cov4" title="31">end, err = ls.NewLastIndex(ctx)
        if seen := ls.getEndSeen(ctx, end); !seen.IsZero() </span><span class="cov4" title="31">{
                if time.Since(seen) &gt; IdleCloseTime </span><span class="cov0" title="0">{
                        err = errLogIdle{Since: seen}
                        return
                }</span>
        }

        <span class="cov4" title="31">start := end
        if cdb := ls.DB(); cdb != nil </span><span class="cov4" title="31">{
                if ls.CertStream.Config.TailDialer != nil </span><span class="cov4" title="31">{
                        wg2.Add(1)
                        go cdb.backfillStream(ctx, ls, &amp;wg2)
                }</span>
        }

        <span class="cov4" title="31">for err == nil </span><span class="cov4" title="32">{
                if start &lt; end </span><span class="cov1" title="1">{
                        ls.GetRawEntries(ctx, start, end, false, ls.sendEntry, nil)
                        if end-start &lt;= LogBatchSize/2 </span><span class="cov0" title="0">{
                                sleep(ctx, time.Second*time.Duration(10+rand.IntN(10) /*#nosec G404*/))
                        }</span>
                        <span class="cov1" title="1">start = end</span>
                }
                <span class="cov4" title="32">end, err = ls.NewLastIndex(ctx)</span>
        }
}

func (ls *LogStream) NewLastIndex(ctx context.Context) (lastIndex int64, err error) <span class="cov5" title="63">{
        bo := &amp;backoff.Backoff{
                Min:    1 * time.Second,
                Max:    5 * time.Minute,
                Factor: 2,
                Jitter: true,
        }
        now := time.Now()
        lastIndex = ls.LastIndex.Load()
        err = bo.Retry(ctx, func() error </span><span class="cov6" title="150">{
                var sth *ct.SignedTreeHead
                sth, err = ls.HeadClient.GetSTH(ctx)
                if err == nil </span><span class="cov6" title="150">{
                        newIndex := int64(sth.TreeSize) - 1 //#nosec G115
                        if lastIndex &lt; newIndex </span><span class="cov5" title="80">{
                                if lastIndex+LogBatchSize &lt; newIndex || time.Since(now) &gt; time.Second*15 </span><span class="cov4" title="32">{
                                        lastIndex = newIndex
                                        ls.LastIndex.Store(lastIndex)
                                        return nil
                                }</span>
                        } else<span class="cov5" title="70"> {
                                if time.Since(now) &gt; IdleCloseTime </span><span class="cov0" title="0">{
                                        return errLogIdle{Since: now}
                                }</span>
                        }
                        <span class="cov6" title="118">return backoff.RetriableError("STH diff too low")</span>
                }
                <span class="cov0" title="0">if ls.handleStreamError(err, "GetSTH") </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return backoff.RetriableError(err.Error())</span>
        })
        <span class="cov5" title="63">return</span>
}

func (ls *LogStream) seeIndex(logindex int64) <span class="cov10" title="4067">{
        if logindex &gt;= 0 </span><span class="cov10" title="4067">{
                if x := ls.MinIndex.Load(); x &gt; logindex || x == -1 </span><span class="cov5" title="56">{
                        ls.MinIndex.CompareAndSwap(x, logindex)
                }</span>
                <span class="cov10" title="4067">if x := ls.MaxIndex.Load(); x &lt; logindex || x == -1 </span><span class="cov6" title="125">{
                        ls.MaxIndex.CompareAndSwap(x, logindex)
                }</span>
        }
}

func (ls *LogStream) makeLogEntry(logindex int64, entry ct.LeafEntry, historical bool) *LogEntry <span class="cov10" title="4067">{
        var ctle *ct.LogEntry
        ctrle, leaferr := ct.RawLogEntryFromLeaf(logindex, &amp;entry)
        if leaferr == nil </span><span class="cov10" title="4067">{
                ctle, leaferr = ctrle.ToLogEntry()
        }</span>
        <span class="cov10" title="4067">return &amp;LogEntry{
                LogStream:   ls,
                Err:         leaferr,
                RawLogEntry: ctrle,
                LogEntry:    ctle,
                Historical:  historical,
        }</span>
}

func (ls *LogStream) sendEntry(ctx context.Context, now time.Time, logindex int64, entry ct.LeafEntry, historical bool) (wanted bool) <span class="cov9" title="4036">{
        le := ls.makeLogEntry(logindex, entry, historical)
        if cert := le.Cert(); cert != nil </span><span class="cov9" title="4036">{
                ls.seeIndex(logindex)
                wanted = now.Before(cert.NotAfter) || now.Sub(cert.Seen) &lt; time.Hour*24*time.Duration(ls.PgMaxAge)
                if ctx.Err() == nil </span><span class="cov9" title="4004">{
                        ls.Count.Add(1)
                        ls.LogOperator.Count.Add(1)
                        if db := ls.DB(); db != nil </span><span class="cov9" title="4004">{
                                db.sendToBatcher(ctx, le)
                        }</span> else<span class="cov0" title="0"> {
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                case ls.getSendEntryCh() &lt;- le:<span class="cov0" title="0"></span>
                                }
                        }
                }
        }
        <span class="cov9" title="4036">return</span>
}

func (ls *LogStream) handleStreamError(err error, from string) (fatal bool) <span class="cov5" title="41">{
        errTxt := err.Error()
        if errors.Is(err, context.Canceled) || strings.Contains(errTxt, "context canceled") </span><span class="cov4" title="31">{
                return true
        }</span>
        <span class="cov3" title="10">if errors.Is(err, context.DeadlineExceeded) || strings.Contains(errTxt, "deadline exceeded") </span><span class="cov3" title="10">{
                return false
        }</span>
        <span class="cov0" title="0">rspErr, isRspErr := err.(jsonclient.RspError)
        if isRspErr </span><span class="cov0" title="0">{
                switch rspErr.StatusCode </span>{
                case http.StatusTooManyRequests,
                        http.StatusGatewayTimeout:<span class="cov0" title="0">
                        return false</span>
                }
        }
        <span class="cov0" title="0">ls.addError(ls, wrapErr(err, from))
        if isRspErr </span><span class="cov0" title="0">{
                switch rspErr.StatusCode </span>{
                case http.StatusInternalServerError,
                        http.StatusBadGateway:<span class="cov0" title="0">
                        return false</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

func (ls *LogStream) GetRawEntries(ctx context.Context, start, end int64, historical bool, handleFn handleEntryFn, gapcounter *atomic.Int64) (wanted bool) <span class="cov5" title="63">{
        if start &gt; end </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="63">client := ls.HeadClient
        if historical &amp;&amp; ls.TailClient != nil </span><span class="cov4" title="31">{
                client = ls.TailClient
        }</span>

        <span class="cov5" title="63">maxparallelism := int64(max(ls.CertStream.Config.GetEntriesParallelism, 1))
        totalEntries := (end - start) + 1
        if historical || maxparallelism == 1 || totalEntries &lt;= LogBatchSize || totalEntries &lt; maxparallelism </span><span class="cov5" title="62">{
                return ls.getRawEntriesRange(ctx, client, start, end, historical, handleFn, gapcounter)
        }</span>

        <span class="cov1" title="1">type segment struct {
                start int64
                end   int64
        }

        parallelism := min(maxparallelism, totalEntries/LogBatchSize)
        segments := make([]segment, parallelism)
        baseSize := totalEntries / parallelism
        remainder := totalEntries % parallelism
        segStart := start
        for i := range parallelism </span><span class="cov1" title="1">{
                size := baseSize
                if int64(i) &lt; remainder </span><span class="cov0" title="0">{
                        size++
                }</span>
                <span class="cov1" title="1">segEnd := min(segStart+size-1, end)
                segments[i] = segment{start: segStart, end: segEnd}
                segStart = segEnd + 1</span>
        }

        <span class="cov1" title="1">var anyWanted atomic.Bool
        var wg sync.WaitGroup
        for _, seg := range segments </span><span class="cov1" title="1">{
                if seg.start &lt;= seg.end </span><span class="cov1" title="1">{
                        wg.Add(1)
                        go func(segStart, segEnd int64) </span><span class="cov1" title="1">{
                                defer wg.Done()
                                if ls.getRawEntriesRange(ctx, client, segStart, segEnd, historical, handleFn, gapcounter) </span><span class="cov1" title="1">{
                                        anyWanted.Store(true)
                                }</span>
                        }(seg.start, seg.end)
                }
        }
        <span class="cov1" title="1">wg.Wait()
        return anyWanted.Load()</span>
}

func (ls *LogStream) getRawEntriesRange(ctx context.Context, client *client.LogClient, start, end int64, historical bool, handleFn handleEntryFn, gapcounter *atomic.Int64) (wanted bool) <span class="cov5" title="63">{
        for start &lt;= end </span><span class="cov6" title="123">{
                if ctx.Err() != nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov6" title="122">bo := &amp;backoff.Backoff{
                        Min:    1 * time.Second,
                        Max:    30 * time.Second,
                        Factor: 2,
                        Jitter: true,
                }
                var resp *ct.GetEntriesResponse
                stop := start + min(LogBatchSize, end-start)
                if err := bo.Retry(ctx, func() error </span><span class="cov6" title="122">{
                        var err error
                        resp, err = client.GetRawEntries(ctx, start, stop)
                        return err
                }</span>); err != nil <span class="cov5" title="41">{
                        if ls.handleStreamError(err, "GetRawEntries") </span><span class="cov4" title="31">{
                                if gapcounter != nil &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                                        _ = ls.LogError(err, "gap not fillable", "url", ls.URL, "start", start, "end", end)
                                        gapcounter.Add(start - (end + 1))
                                }</span>
                                <span class="cov4" title="31">return</span>
                        }
                } else<span class="cov5" title="81"> {
                        now := time.Now()
                        for i := range resp.Entries </span><span class="cov10" title="4067">{
                                if handleFn(ctx, now, start, resp.Entries[i], historical) </span><span class="cov9" title="4036">{
                                        wanted = true
                                }</span>
                                <span class="cov10" title="4067">start++
                                if gapcounter != nil </span><span class="cov0" title="0">{
                                        gapcounter.Add(-1)
                                }</span>
                        }
                        <span class="cov5" title="81">if historical &amp;&amp; !wanted </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov5" title="91">for historical &amp;&amp; ctx.Err() == nil &amp;&amp; ls.DB() != nil &amp;&amp; ls.DB().QueueUsage() &gt; 50 </span><span class="cov0" title="0">{
                        time.Sleep(time.Millisecond * 100)
                }</span>
        }
        <span class="cov4" title="31">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package certstream

import (
        "net/url"
        "strings"
)

// OperatorDomain returns the TLD+1 given an URL.
func OperatorDomain(urlString string) string <span class="cov10" title="36">{
        opDom := urlString
        if u, err := url.Parse(urlString); err == nil </span><span class="cov10" title="36">{
                opDom = u.Hostname()
                if idx := strings.LastIndexByte(opDom, '.'); idx &gt; 0 </span><span class="cov9" title="35">{
                        if idx := strings.LastIndexByte(opDom[:idx], '.'); idx &gt; 0 </span><span class="cov9" title="33">{
                                opDom = opDom[idx+1:]
                        }</span>
                }
        }
        <span class="cov10" title="36">return opDom</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package certstream

import (
        "context"
        "database/sql"
        "fmt"
        "sync"
)

var BulkRange = int64(4096)

func (cdb *PgDB) backfillGaps(ctx context.Context, ls *LogStream) <span class="cov10" title="31">{
        type gap struct {
                start int64
                end   int64
        }
        var gaps []gap
        if lastindex := ls.LastIndex.Load(); lastindex != -1 </span><span class="cov10" title="31">{
                row := cdb.QueryRow(ctx, cdb.stmtSelectMaxIdx, ls.Id)
                var nullableMaxIndex sql.NullInt64
                if err := row.Scan(&amp;nullableMaxIndex); cdb.LogError(err, "backfillGaps/MaxIndex", "url", ls.URL) == nil </span><span class="cov10" title="31">{
                        if nullableMaxIndex.Valid </span><span class="cov0" title="0">{
                                ls.seeIndex(nullableMaxIndex.Int64)
                                if nullableMaxIndex.Int64 &lt; lastindex </span><span class="cov0" title="0">{
                                        gaps = append(gaps, gap{start: nullableMaxIndex.Int64 + 1, end: lastindex})
                                }</span>
                        }
                }
        }
        <span class="cov10" title="31">if rows, err := cdb.Query(ctx, cdb.stmtSelectGaps, ls.Id); cdb.LogError(err, "backfillGaps/Query", "url", ls.URL) == nil </span><span class="cov10" title="31">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var gap_start, gap_end int64
                        if err = rows.Scan(&amp;gap_start, &amp;gap_end); cdb.LogError(err, "backfillGaps/Scan", "url", ls.URL) == nil </span><span class="cov0" title="0">{
                                gaps = append(gaps, gap{start: gap_start, end: gap_end})
                        }</span>
                }
                <span class="cov10" title="31">rows.Close()</span>
        }
        <span class="cov10" title="31">for _, gap := range gaps </span><span class="cov0" title="0">{
                ls.InsideGaps.Add((gap.end - gap.start) + 1)
        }</span>
        <span class="cov10" title="31">for _, gap := range gaps </span><span class="cov0" title="0">{
                if ctx.Err() == nil </span><span class="cov0" title="0">{
                        cdb.LogInfo("gap", "url", ls.URL, "stream", ls.Id, "logindex", gap.start, "length", (gap.end-gap.start)+1)
                        ls.GetRawEntries(ctx, gap.start, gap.end, true, ls.sendEntry, &amp;ls.InsideGaps)
                }</span>
        }
}

func (cdb *PgDB) backfillStream(ctx context.Context, ls *LogStream, wg *sync.WaitGroup) <span class="cov10" title="31">{
        defer wg.Done()
        row := cdb.QueryRow(ctx, cdb.stmtSelectMinIdx, ls.Id)
        var nullableMinIndex sql.NullInt64
        if err := cdb.LogError(row.Scan(&amp;nullableMinIndex), "Backfill/MinIndex", "url", ls.URL); err == nil </span><span class="cov10" title="31">{
                if !nullableMinIndex.Valid </span><span class="cov10" title="31">{
                        nullableMinIndex.Int64 = ls.LastIndex.Load()
                }</span>
                <span class="cov10" title="31">minIndex := nullableMinIndex.Int64
                ls.seeIndex(minIndex)
                cdb.backfillGaps(ctx, ls)
                if minIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov10" title="31">{
                        cdb.LogInfo("backlog start", "url", ls.URL, "stream", ls.Id, "logindex", minIndex)
                        for minIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov10" title="31">{
                                start := max(0, minIndex-BulkRange)
                                stop := minIndex - 1
                                minIndex = start
                                if !ls.GetRawEntries(ctx, start, stop, true, ls.sendEntry, nil) </span><span class="cov5" title="6">{
                                        cdb.LogInfo("backlog stops", "url", ls.URL, "stream", ls.Id, "logindex", minIndex)
                                        ls.addError(ls, fmt.Errorf("log entries are older than %d days", cdb.PgMaxAge))
                                        return
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package certstream

import (
        "context"
        "sync"
        "time"

        "github.com/jackc/pgx/v5/pgconn"
)

func (cdb *PgDB) runBatch(ctx context.Context, queued []*LogEntry) (err error) <span class="cov5" title="69">{
        var b []byte
        b = append(b, `[`...)
        for i, le := range queued </span><span class="cov7" title="1226">{
                if i &gt; 0 </span><span class="cov7" title="1157">{
                        b = append(b, `,`...)
                }</span>
                <span class="cov7" title="1226">b = le.appendJSON(b)</span>
        }
        <span class="cov5" title="69">b = append(b, `]`...)
        now := time.Now()
        _, err = cdb.Exec(ctx, cdb.funcIngestBatch, string(b))
        elapsed := time.Since(now)
        if err != nil </span><span class="cov4" title="33">{
                if pe, ok := err.(*pgconn.PgError); ok </span><span class="cov0" title="0">{
                        if pe.SQLState() == "22P02" </span><span class="cov0" title="0">{
                                cdb.LogInfo("generated invalid JSON data", "json", string(b))
                        }</span>
                }
        }
        <span class="cov5" title="69">cdb.mu.Lock()
        cdb.newentrycount += int64(len(queued))
        cdb.newentrytime += elapsed
        cdb.mu.Unlock()
        return</span>
}

func (cdb *PgDB) worker(ctx context.Context, wg *sync.WaitGroup, workerID int) <span class="cov4" title="32">{
        defer wg.Done()
        if batchCh := cdb.getBatchCh(workerID); batchCh != nil </span><span class="cov4" title="32">{
                cdb.Workers.Add(1)
                defer cdb.Workers.Add(-1)
                tckr := time.NewTicker(time.Second)
                defer tckr.Stop()
                stop := false
                var queued []*LogEntry
                for !stop </span><span class="cov7" title="1340">{
                        ticked := false
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov2" title="6">
                                stop = true</span>
                        case &lt;-tckr.C:<span class="cov5" title="108">
                                ticked = true</span>
                        case le := &lt;-batchCh:<span class="cov7" title="1226">
                                queued = append(queued, le)</span>
                        }
                        <span class="cov7" title="1340">if l := len(queued); l &gt; 0 &amp;&amp; (l &gt;= DbBatchSize || ticked || stop) </span><span class="cov5" title="69">{
                                _ = cdb.LogError(cdb.runBatch(ctx, queued), "runBatch")
                                for _, le := range queued </span><span class="cov7" title="1226">{
                                        if !stop </span><span class="cov5" title="144">{
                                                select </span>{
                                                case &lt;-ctx.Done():<span class="cov4" title="26">
                                                        stop = true</span>
                                                case cdb.getSendEntryCh() &lt;- le:<span class="cov5" title="118"></span>
                                                }
                                        }
                                }
                                <span class="cov5" title="69">clear(queued)
                                queued = queued[:0]</span>
                        }
                }
        }
}

func (cdb *PgDB) AverageNewEntryTime() (d time.Duration) <span class="cov0" title="0">{
        cdb.mu.Lock()
        d = cdb.avgentrytime
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) runWorkers(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        const interval = time.Millisecond * 100
        defer func() </span><span class="cov1" title="1">{
                wg.Done()
        }</span>()

        <span class="cov1" title="1">wg.Add(cdb.workerCount)
        for i := 0; i &lt; cdb.workerCount; i++ </span><span class="cov4" title="32">{
                go cdb.worker(ctx, wg, i)
        }</span>

        <span class="cov1" title="1">ticks := 0
        ticker := time.NewTicker(interval)
        avgentrytimes := make([]time.Duration, time.Second*10/interval)
        defer ticker.Stop()
        for </span><span class="cov5" title="123">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov5" title="122">
                        cdb.mu.Lock()
                        avgentrytime := cdb.newentrytime
                        if d := time.Duration(cdb.newentrycount); d &gt; 0 </span><span class="cov4" title="28">{
                                avgentrytime /= d
                        }</span>
                        <span class="cov5" title="122">cdb.newentrytime = 0
                        cdb.newentrycount = 0
                        avgentrytimes[ticks] = avgentrytime
                        ticks++
                        if ticks &gt;= cap(avgentrytimes) </span><span class="cov1" title="1">{
                                ticks = 0
                        }</span>
                        <span class="cov5" title="122">avgentrytime = 0
                        for _, d := range avgentrytimes </span><span class="cov10" title="12200">{
                                avgentrytime += d
                        }</span>
                        <span class="cov5" title="122">cdb.avgentrytime = avgentrytime / time.Duration(cap(avgentrytimes))
                        cdb.mu.Unlock()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package certstream

import (
        "time"
)

type PgCertificate struct {
        Id         int64
        NotBefore  time.Time
        NotAfter   time.Time
        CommonName string
        SubjectID  int
        IssuerID   int
        Sha256     []byte
        PreCert    bool
        Since      time.Time
}

func ScanCertificate(row Scanner, cert *PgCertificate) (err error) <span class="cov0" title="0">{
        var p_since *time.Time
        if err = row.Scan(
                &amp;cert.Id,
                &amp;cert.NotBefore,
                &amp;cert.NotAfter,
                &amp;cert.CommonName,
                &amp;cert.SubjectID,
                &amp;cert.IssuerID,
                &amp;cert.Sha256,
                &amp;cert.PreCert,
                &amp;p_since,
        ); err == nil </span><span class="cov0" title="0">{
                if p_since != nil </span><span class="cov0" title="0">{
                        cert.Since = *p_since
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package certstream

import (
        "context"
        _ "embed"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Scanner interface {
        Scan(dest ...any) error
}

// PgDB integrates with sql.DB to manage certificate stream data for a PostgreSQL database
type PgDB struct {
        *CertStream
        *pgxpool.Pool
        Pfx                   func(string) string // prefix replacer
        Workers               atomic.Int32
        funcOperatorID        string
        funcStreamID          string
        funcEnsureIdent       string
        funcFindSince         string
        funcIngestBatch       string
        stmtEnsureCert        string
        stmtAttachMetadata    string
        stmtSelectGaps        string
        stmtSelectMinIdx      string
        stmtSelectMaxIdx      string
        stmtSelectDnsnameLike string
        stmtSelectIDSince     string
        mu                    sync.Mutex // protects following
        batchCh               []chan *LogEntry
        workerBits            int
        workerCount           int
        estimates             map[string]float64 // row count estimates
        newentrytime          time.Duration
        newentrycount         int64
        avgentrytime          time.Duration
}

func ensureSchema(ctx context.Context, db *pgxpool.Pool, pfx func(string) string) (err error) <span class="cov1" title="1">{
        if _, err = db.Exec(ctx, pfx(CreateSchema)); err == nil </span><span class="cov1" title="1">{
                if _, err = db.Exec(ctx, pfx(FunctionOperatorID)); err == nil </span><span class="cov1" title="1">{
                        if _, err = db.Exec(ctx, pfx(FunctionStreamID)); err == nil </span><span class="cov1" title="1">{
                                if _, err = db.Exec(ctx, pfx(FunctionFindSince)); err == nil </span><span class="cov1" title="1">{
                                        _, err = db.Exec(ctx, pfx(FuncIngestBatch))
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

// NewPgDB creates a PgDB and creates the needed tables and indices if they don't exist.
func NewPgDB(ctx context.Context, cs *CertStream) (cdb *PgDB, err error) <span class="cov1" title="1">{
        const callOperatorID = `SELECT CERTDB_operator_id($1,$2);`
        const callStreamID = `SELECT CERTDB_stream_id($1,$2,$3);`
        const callFindSince = `SELECT CERTDB_find_since($1,$2,$3,$4);`
        const callEnsureCert = `SELECT CERTDB_ensure_cert($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14);`
        const callAttachMetadata = `SELECT CERTDB_attach_metadata($1,$2,$3,$4,$5);`

        if cs.Config.PgAddr != "" </span><span class="cov1" title="1">{
                dsn := fmt.Sprintf("postgres://%s:%s@%s/%s?pool_max_conns=%d&amp;pool_max_conn_idle_time=1m",
                        cs.Config.PgUser, cs.Config.PgPass, cs.Config.PgAddr, cs.Config.PgName, cs.Config.PgConns)
                if cs.Config.PgNoSSL </span><span class="cov1" title="1">{
                        dsn += "&amp;sslmode=disable"
                }</span>
                <span class="cov1" title="1">var poolcfg *pgxpool.Config
                if poolcfg, err = pgxpool.ParseConfig(dsn); err == nil </span><span class="cov1" title="1">{
                        poolcfg.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeSimpleProtocol
                        var pool *pgxpool.Pool
                        if pool, err = pgxpool.NewWithConfig(ctx, poolcfg); err == nil </span><span class="cov1" title="1">{
                                if err = pool.Ping(ctx); err == nil </span><span class="cov1" title="1">{
                                        cs.LogInfo("database", "addr", cs.Config.PgAddr, "name", cs.Config.PgName, "prefix", cs.Config.PgPrefix)
                                        pfx := func(s string) string </span><span class="cov4" title="20">{ return strings.ReplaceAll(s, "CERTDB_", cs.Config.PgPrefix) }</span>
                                        <span class="cov1" title="1">if err = ensureSchema(ctx, pool, pfx); err == nil </span><span class="cov1" title="1">{
                                                var pgversion string
                                                if cs.LogError(pool.QueryRow(ctx, `SELECT version();`).Scan(&amp;pgversion), "postgres version") == nil </span><span class="cov1" title="1">{
                                                        cs.LogInfo("postgres", "version", pgversion)
                                                }</span>
                                                <span class="cov1" title="1">workerBits := min(8, max(1, cs.Config.PgWorkerBits))
                                                workerCount := 1 &lt;&lt; workerBits
                                                batchChans := make([]chan *LogEntry, workerCount)
                                                for i := range batchChans </span><span class="cov4" title="32">{
                                                        batchChans[i] = make(chan *LogEntry, 1024)
                                                }</span>
                                                <span class="cov1" title="1">cdb = &amp;PgDB{
                                                        CertStream:            cs,
                                                        Pool:                  pool,
                                                        Pfx:                   pfx,
                                                        funcOperatorID:        pfx(callOperatorID),
                                                        funcStreamID:          pfx(callStreamID),
                                                        funcEnsureIdent:       pfx(`SELECT CERTDB_ensure_ident($1,$2,$3);`),
                                                        funcFindSince:         pfx(callFindSince),
                                                        funcIngestBatch:       pfx(`SELECT CERTDB_ingest_batch($1::jsonb);`),
                                                        stmtEnsureCert:        pfx(callEnsureCert),
                                                        stmtAttachMetadata:    pfx(callAttachMetadata),
                                                        stmtSelectGaps:        pfx(SelectGaps),
                                                        stmtSelectMinIdx:      pfx(SelectMinIndex),
                                                        stmtSelectMaxIdx:      pfx(SelectMaxIndex),
                                                        stmtSelectDnsnameLike: pfx(SelectDnsnameLike),
                                                        stmtSelectIDSince:     pfx(SelectIDSince),
                                                        batchCh:               batchChans,
                                                        workerBits:            workerBits,
                                                        workerCount:           workerCount,
                                                        estimates: map[string]float64{
                                                                "cert":   0,
                                                                "domain": 0,
                                                                "entry":  0,
                                                        },
                                                }
                                                cdb.refreshEstimates(ctx)</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov1" title="1">if cdb != nil </span><span class="cov1" title="1">{
                cs.LogInfo("database workers", "count", cdb.workerCount, "bits", cdb.workerBits)
        }</span>
        <span class="cov1" title="1">return</span>
}

func (cdb *PgDB) Close() <span class="cov1" title="1">{
        cdb.mu.Lock()
        chans := cdb.batchCh
        cdb.batchCh = nil
        cdb.mu.Unlock()
        for _, ch := range chans </span><span class="cov4" title="32">{
                if ch != nil </span><span class="cov4" title="32">{
                        close(ch)
                }</span>
        }
        <span class="cov1" title="1">cdb.Pool.Close()</span>
}

func (cdb *PgDB) QueueUsage() (pct int) <span class="cov5" title="56">{
        cdb.mu.Lock()
        chans := cdb.batchCh
        cdb.mu.Unlock()
        totalLen := 0
        totalCap := 0
        for _, ch := range chans </span><span class="cov9" title="1792">{
                if ch != nil </span><span class="cov9" title="1792">{
                        totalLen += len(ch)
                        totalCap += cap(ch)
                }</span>
        }
        <span class="cov5" title="56">if totalCap &gt; 0 </span><span class="cov5" title="56">{
                pct = totalLen * 100 / totalCap
        }</span>
        <span class="cov5" title="56">return</span>
}

func (cdb *PgDB) getBatchCh(idx int) (ch chan *LogEntry) <span class="cov10" title="4036">{
        cdb.mu.Lock()
        ch = cdb.batchCh[idx]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) workerIndexFor(le *LogEntry) (idx int) <span class="cov9" title="4004">{
        if cdb != nil &amp;&amp; le != nil </span><span class="cov9" title="4004">{
                if cert := le.Cert(); cert != nil &amp;&amp; len(cert.Signature) &gt; 0 </span><span class="cov9" title="4004">{
                        idx = int(cert.Signature[0] &gt;&gt; (8 - cdb.workerBits))
                }</span>
        }
        <span class="cov9" title="4004">return</span>
}

func (cdb *PgDB) sendToBatcher(ctx context.Context, le *LogEntry) <span class="cov9" title="4004">{
        if le != nil &amp;&amp; ctx.Err() == nil </span><span class="cov9" title="4004">{
                if ch := cdb.getBatchCh(cdb.workerIndexFor(le)); ch != nil </span><span class="cov9" title="4004">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        case ch &lt;- le:<span class="cov9" title="4004"></span>
                        }
                }
        }
}

func (cdb *PgDB) ensureOperator(ctx context.Context, lo *LogOperator) (err error) <span class="cov2" title="6">{
        if cdb != nil </span><span class="cov2" title="6">{
                row := cdb.QueryRow(ctx, cdb.funcOperatorID, lo.Name, strings.Join(lo.Email, ","))
                err = wrapErr(row.Scan(&amp;lo.Id), cdb.funcOperatorID)
        }</span>
        <span class="cov2" title="6">return</span>
}

func (cdb *PgDB) ensureStream(ctx context.Context, ls *LogStream) (err error) <span class="cov4" title="31">{
        if cdb != nil </span><span class="cov4" title="31">{
                var b []byte
                if b, err = json.Marshal(ls.Log); err == nil </span><span class="cov4" title="31">{
                        row := cdb.QueryRow(ctx, cdb.funcStreamID, ls.URL, ls.LogOperator.Id, string(b))
                        err = wrapErr(row.Scan(&amp;ls.Id), cdb.funcStreamID)
                }</span>
        }
        <span class="cov4" title="31">return</span>
}

func (cdb *PgDB) fillIdentity(ctx context.Context, id int, ident *JsonIdentity) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT * FROM CERTDB_ident WHERE id=$1;`), id)
        var dbident PgIdent
        if err := cdb.LogError(ScanIdent(row, &amp;dbident), "fillIdentity", "id", id); err == nil </span><span class="cov0" title="0">{
                ident.ID = id
                ident.Country = dbident.Country
                ident.Organization = dbident.Organization
                ident.Province = dbident.Province
        }</span>
}

func (cdb *PgDB) getCertStrings(ctx context.Context, id int64, tablename, colname string) (sl []string) <span class="cov0" title="0">{
        rows, err := cdb.Query(ctx, cdb.Pfx(fmt.Sprintf("SELECT %s::text FROM CERTDB_%s WHERE cert=$1;", colname, tablename)), id)
        if cdb.LogError(err, "getCertStrings/"+tablename, "id", id) == nil </span><span class="cov0" title="0">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var s string
                        if err := cdb.LogError(rows.Scan(&amp;s), "getCertStrings/scan/"+tablename); err == nil </span><span class="cov0" title="0">{
                                sl = append(sl, s)
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) getCertificate(ctx context.Context, dbcert *PgCertificate) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        cert = &amp;JsonCertificate{
                PreCert:        dbcert.PreCert,
                Signature:      dbcert.Sha256,
                CommonName:     dbcert.CommonName,
                DNSNames:       []string{},
                EmailAddresses: []string{},
                IPAddresses:    []string{},
                URIs:           []string{},
                NotBefore:      dbcert.NotBefore,
                NotAfter:       dbcert.NotAfter,
                Since:          dbcert.Since,
        }
        cdb.fillIdentity(ctx, dbcert.IssuerID, &amp;cert.Issuer)
        cdb.fillIdentity(ctx, dbcert.SubjectID, &amp;cert.Subject)
        cert.Subject.CommonName = dbcert.CommonName
        cert.DNSNames = cdb.getCertStrings(ctx, dbcert.Id, "dnsnames", "fqdn")
        cert.EmailAddresses = cdb.getCertStrings(ctx, dbcert.Id, "email", "email")
        cert.IPAddresses = cdb.getCertStrings(ctx, dbcert.Id, "ipaddress", "addr")
        for i := range cert.IPAddresses </span><span class="cov0" title="0">{
                cert.IPAddresses[i] = strings.TrimSuffix(cert.IPAddresses[i], "/32")
        }</span>
        <span class="cov0" title="0">cert.URIs = cdb.getCertStrings(ctx, dbcert.Id, "uri", "uri")
        cert.SetCommonName()
        return</span>
}

func (cdb *PgDB) GetCertificateByLogEntry(ctx context.Context, entry *PgLogEntry) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        return cdb.GetCertificateByID(ctx, entry.CertID)
}</span>

func RenderSQL(query string, args ...any) string <span class="cov0" title="0">{
        for i, arg := range args </span><span class="cov0" title="0">{
                var s string
                switch v := arg.(type) </span>{
                case string:<span class="cov0" title="0">
                        s = fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))</span>
                case time.Time:<span class="cov0" title="0">
                        s = fmt.Sprintf("'%s'", v.Format(time.RFC3339))</span>
                default:<span class="cov0" title="0">
                        s = fmt.Sprint(v)</span>
                }
                <span class="cov0" title="0">query = strings.ReplaceAll(query, fmt.Sprintf("$%d", i+1), s)</span>
        }
        <span class="cov0" title="0">return query</span>
}

func (cdb *PgDB) GetCertificateSince(ctx context.Context, jcert *JsonCertificate) (since time.Time, err error) <span class="cov0" title="0">{
        if jcert.CommonName != "" </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(ctx, time.Second*5)
                defer cancel()
                row := cdb.QueryRow(ctx, cdb.stmtSelectIDSince,
                        jcert.CommonName,
                        jcert.Subject.Organization, jcert.Subject.Province, jcert.Subject.Country,
                        jcert.Issuer.Organization, jcert.Issuer.Province, jcert.Issuer.Country,
                        jcert.NotBefore,
                )
                var id int64
                var subject, issuer int
                var notbefore time.Time
                var p_since *time.Time
                if err = row.Scan(&amp;id, &amp;subject, &amp;issuer, &amp;notbefore, &amp;p_since); err == nil </span><span class="cov0" title="0">{
                        if p_since != nil </span><span class="cov0" title="0">{
                                since = *p_since
                        }</span> else<span class="cov0" title="0"> {
                                since = notbefore
                        }</span>
                }
                <span class="cov0" title="0">if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        err = nil
                }</span>
                <span class="cov0" title="0">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        _ = cdb.LogError(err, "GetCertificateSince", "signature", jcert.Signature, "query", strings.ReplaceAll(RenderSQL(cdb.stmtSelectIDSince,
                                jcert.CommonName,
                                jcert.Subject.Organization, jcert.Subject.Province, jcert.Subject.Country,
                                jcert.Issuer.Organization, jcert.Issuer.Province, jcert.Issuer.Country,
                                jcert.NotBefore), "\n", " "))
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificatesByCommonName(ctx context.Context, commonname string) (certs []*JsonCertificate, err error) <span class="cov0" title="0">{
        var rows pgx.Rows
        if rows, err = cdb.Query(ctx, cdb.Pfx(`SELECT * FROM CERTDB_cert WHERE commonname=$1 ORDER BY notbefore DESC;`), commonname); err == nil </span><span class="cov0" title="0">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var dbcert PgCertificate
                        e := ScanCertificate(rows, &amp;dbcert)
                        if e == nil </span><span class="cov0" title="0">{
                                var cert *JsonCertificate
                                if cert, e = cdb.getCertificate(ctx, &amp;dbcert); e == nil </span><span class="cov0" title="0">{
                                        certs = append(certs, cert)
                                }</span>
                        }
                        <span class="cov0" title="0">err = errors.Join(err, e)</span>
                }
                <span class="cov0" title="0">err = errors.Join(err, rows.Err())</span>
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByHash(ctx context.Context, hash []byte) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT * FROM CERTDB_cert WHERE sha256=$1;`), hash)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByID(ctx context.Context, id int64) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT * FROM CERTDB_cert WHERE id=$1;`), id)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) Estimate(table string) (f float64) <span class="cov0" title="0">{
        table = strings.TrimPrefix(table, "CERTDB_")
        table = strings.TrimPrefix(table, cdb.CertStream.Config.PgPrefix)
        cdb.mu.Lock()
        f = cdb.estimates[table]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) refreshEstimatesBatch() (batch *pgx.Batch) <span class="cov1" title="1">{
        batch = &amp;pgx.Batch{}
        cdb.mu.Lock()
        defer cdb.mu.Unlock()
        for k := range cdb.estimates </span><span class="cov2" title="3">{
                table := cdb.Pfx("CERTDB_" + k)
                batch.Queue(SelectEstimate, table).QueryRow(func(row pgx.Row) error </span><span class="cov2" title="3">{
                        var estimate float64
                        if cdb.LogError(row.Scan(&amp;estimate), "refreshEstimates", "table", table) == nil </span><span class="cov2" title="3">{
                                cdb.mu.Lock()
                                cdb.estimates[k] = estimate
                                cdb.mu.Unlock()
                        }</span>
                        <span class="cov2" title="3">return nil</span>
                })
        }
        <span class="cov1" title="1">return</span>
}

func (cdb *PgDB) refreshEstimates(ctx context.Context) <span class="cov1" title="1">{
        if batch := cdb.refreshEstimatesBatch(); batch != nil </span><span class="cov1" title="1">{
                ctx, cancel := context.WithTimeout(ctx, time.Minute)
                defer cancel()
                _ = cdb.LogError(cdb.SendBatch(ctx, batch).Close(), "refreshEstimates")
        }</span>
}

func (cdb *PgDB) estimator(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        defer wg.Done()
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()
        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cdb.refreshEstimates(ctx)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package certstream

type PgDnsname struct {
        Dnsname string
        CertID  int64
}

func ScanDnsname(row Scanner, p *PgDnsname) error <span class="cov0" title="0">{
        return row.Scan(
                &amp;p.Dnsname,
                &amp;p.CertID,
        )
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package certstream

import (
        "time"
)

type PgDnsnamesView struct {
        CertID    int64
        FQDN      string
        NotBefore time.Time
        Idna      bool
        Valid     bool
        PreCert   bool
        Issuer    string
        Subject   string
        Crtsh     string
        Domain    string
        Tld       string
}

func ScanDnsnamesView(row Scanner, dnsname *PgDnsnamesView) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;dnsname.CertID,
                &amp;dnsname.FQDN,
                &amp;dnsname.NotBefore,
                &amp;dnsname.Idna,
                &amp;dnsname.Valid,
                &amp;dnsname.PreCert,
                &amp;dnsname.Issuer,
                &amp;dnsname.Subject,
                &amp;dnsname.Crtsh,
                &amp;dnsname.Domain,
                &amp;dnsname.Tld,
        )
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package certstream

type PgIdent struct {
        Id           int
        Organization string
        Province     string
        Country      string
}

func ScanIdent(row Scanner, ident *PgIdent) error <span class="cov0" title="0">{
        return row.Scan(
                &amp;ident.Id,
                &amp;ident.Organization,
                &amp;ident.Province,
                &amp;ident.Country,
        )
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package certstream

import (
        "time"
)

type PgLogEntry struct {
        Seen     time.Time // CT log entry timestamp
        LogIndex int64     // CT log index for the stream
        CertID   int64     // database ID of cert
        StreamID int       // database ID of stream
}

func ScanLogEntry(row Scanner, entry *PgLogEntry) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;entry.Seen,
                &amp;entry.LogIndex,
                &amp;entry.CertID,
                &amp;entry.StreamID,
        )
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type StreamError struct {
        *LogStream
        When time.Time
        Err  error
}

func (ewt StreamError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("%v %s", ewt.When.Format(time.DateTime), ewt.Err.Error())
}</span>

func (ewt StreamError) Unwrap() error <span class="cov10" title="2">{
        return ewt.Err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "slices"
        "sort"
        "sync"

        "github.com/google/certificate-transparency-go/loglist3"
)

func (cs *CertStream) ensureOperatorAndLog(ctx context.Context, op *loglist3.Operator, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov6" title="31">{
        opDom := OperatorDomain(log.URL)

        cs.mu.Lock()
        logop := cs.operators[opDom]
        cs.mu.Unlock()

        if logop == nil </span><span class="cov4" title="6">{
                logop = &amp;LogOperator{
                        CertStream: cs,
                        Operator:   op,
                        Domain:     opDom,
                        streams:    make(map[string]*LogStream),
                }
                sort.Strings(op.Email)
                if db := cs.DB(); db != nil </span><span class="cov4" title="6">{
                        if err = db.ensureOperator(ctx, logop); err == nil </span><span class="cov4" title="6">{
                                cs.mu.Lock()
                                cs.operators[opDom] = logop
                                cs.mu.Unlock()
                        }</span>
                }
        }

        <span class="cov6" title="31">if err == nil </span><span class="cov6" title="31">{
                err = logop.ensureStream(ctx, log, wg)
        }</span>

        <span class="cov6" title="31">return</span>
}

func (cs *CertStream) updateStreams(ctx context.Context, wg *sync.WaitGroup) (err error) <span class="cov1" title="1">{
        var logList *loglist3.LogList
        if logList, err = GetLogList(ctx, cs.HeadClient, loglist3.AllLogListURL); err == nil </span><span class="cov1" title="1">{
                for _, op := range logList.Operators </span><span class="cov6" title="24">{
                        for _, log := range op.Logs </span><span class="cov10" title="186">{
                                if log.State.LogStatus() == loglist3.UsableLogStatus </span><span class="cov6" title="31">{
                                        if e := cs.ensureOperatorAndLog(ctx, op, log, wg); e != nil </span><span class="cov0" title="0">{
                                                err = errors.Join(err, e)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov1" title="1">var operators []string
        for _, lo := range cs.Operators() </span><span class="cov4" title="6">{
                operators = append(operators, fmt.Sprintf("%s*%d", lo.Domain, len(lo.Streams())))
        }</span>
        <span class="cov1" title="1">slices.Sort(operators)
        cs.LogInfo("active", "streams", operators)
        return</span>
}

func (cs *CertStream) removeStream(ls *LogStream) <span class="cov6" title="31">{
        lo := ls.LogOperator
        lo.mu.Lock()
        delete(lo.streams, ls.URL)
        empty := len(lo.streams) == 0
        lo.mu.Unlock()
        if empty </span><span class="cov4" title="6">{
                cs.mu.Lock()
                delete(cs.operators, lo.Domain)
                cs.mu.Unlock()
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package certstream

type wrappedErr struct {
        err error
        msg string
}

func (we wrappedErr) Error() string <span class="cov0" title="0">{
        return we.msg + ": " + we.err.Error()
}</span>

func (we wrappedErr) Unwrap() error <span class="cov0" title="0">{
        return we.err
}</span>

func wrapErr(err error, msg string) error <span class="cov10" title="37">{
        if err == nil </span><span class="cov10" title="37">{
                return nil
        }</span>
        <span class="cov0" title="0">return wrappedErr{err: err, msg: msg}</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
