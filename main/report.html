
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>certstream: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/certstream/certificate.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/certstream/certstream.go (70.5%)</option>
				
				<option value="file2">github.com/linkdata/certstream/config.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/certstream/errlogidle.go (0.0%)</option>
				
				<option value="file4">github.com/linkdata/certstream/getloglist.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/certstream/jsoncertificate.go (63.0%)</option>
				
				<option value="file6">github.com/linkdata/certstream/jsonidentity.go (91.7%)</option>
				
				<option value="file7">github.com/linkdata/certstream/logentry.go (71.1%)</option>
				
				<option value="file8">github.com/linkdata/certstream/logoperator.go (73.5%)</option>
				
				<option value="file9">github.com/linkdata/certstream/logstream.go (83.1%)</option>
				
				<option value="file10">github.com/linkdata/certstream/operatordomain.go (100.0%)</option>
				
				<option value="file11">github.com/linkdata/certstream/pgbackfill.go (76.2%)</option>
				
				<option value="file12">github.com/linkdata/certstream/pgbatcher.go (74.6%)</option>
				
				<option value="file13">github.com/linkdata/certstream/pgcertificate.go (0.0%)</option>
				
				<option value="file14">github.com/linkdata/certstream/pgdb.go (51.8%)</option>
				
				<option value="file15">github.com/linkdata/certstream/pgdnsname.go (0.0%)</option>
				
				<option value="file16">github.com/linkdata/certstream/pgdnsnamesview.go (0.0%)</option>
				
				<option value="file17">github.com/linkdata/certstream/pgident.go (0.0%)</option>
				
				<option value="file18">github.com/linkdata/certstream/pglogentry.go (0.0%)</option>
				
				<option value="file19">github.com/linkdata/certstream/streamerror.go (100.0%)</option>
				
				<option value="file20">github.com/linkdata/certstream/updatestreams.go (97.2%)</option>
				
				<option value="file21">github.com/linkdata/certstream/wraperr.go (60.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package certstream

import (
        "slices"
        "time"

        "github.com/google/certificate-transparency-go/x509"
)

type Certificate struct {
        PreCert   bool
        Seen      time.Time
        Signature []byte
        *x509.Certificate
}

func (c *Certificate) GetCommonName() (s string) <span class="cov10" title="62">{
        if s = c.Subject.CommonName; s == "" </span><span class="cov4" title="4">{
                if len(c.DNSNames) &gt; 0 </span><span class="cov2" title="2">{
                        names := slices.Clone(c.DNSNames)
                        slices.Sort(names)
                        s = c.DNSNames[0]
                }</span>
        }
        <span class="cov10" title="62">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package certstream

import (
        "context"
        "errors"
        "net/http"
        "slices"
        "strings"
        "sync"
        "time"
)

type CertStream struct {
        Config                       // copy of config
        C           &lt;-chan *LogEntry // log entry channel
        HeadClient  *http.Client     // main HTTP client, uses Config.HeadDialer
        TailClient  *http.Client     // may be nil if not backfilling
        DB          *PgDB
        mu          sync.Mutex // protects following
        sendEntryCh chan *LogEntry
        operators   map[string]*LogOperator // operators by operator domain, valid after Start()
}

var DefaultTransport = &amp;http.Transport{
        TLSHandshakeTimeout:   30 * time.Second,
        ResponseHeaderTimeout: 30 * time.Second,
        MaxIdleConnsPerHost:   2,
        DisableKeepAlives:     false,
        ExpectContinueTimeout: 1 * time.Second,
        ForceAttemptHTTP2:     true,
}

func (cs *CertStream) LogInfo(msg string, args ...any) <span class="cov8" title="60">{
        if cs.Config.Logger != nil </span><span class="cov8" title="60">{
                cs.Config.Logger.Info("certstream: "+msg, args...)
        }</span>
}

func (cs *CertStream) LogError(err error, msg string, args ...any) error <span class="cov10" title="130">{
        if err != nil &amp;&amp; cs.Config.Logger != nil </span><span class="cov7" title="32">{
                if !errors.Is(err, context.Canceled) &amp;&amp; !errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        if unwrapper, ok := err.(interface{ Unwrap() []error }); ok </span><span class="cov0" title="0">{
                                for _, e := range unwrapper.Unwrap() </span><span class="cov0" title="0">{
                                        cs.Config.Logger.Error("certstream: "+msg, append(args, "err", e)...)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cs.Config.Logger.Error("certstream: "+msg, append(args, "err", err)...)
                        }</span>
                }
        }
        <span class="cov10" title="130">return err</span>
}

func (cs *CertStream) Operators() (operators []*LogOperator) <span class="cov1" title="1">{
        cs.mu.Lock()
        for _, logop := range cs.operators </span><span class="cov4" title="6">{
                operators = append(operators, logop)
        }</span>
        <span class="cov1" title="1">cs.mu.Unlock()
        slices.SortFunc(operators, func(a, b *LogOperator) int </span><span class="cov4" title="7">{ return strings.Compare(a.Name, b.Name) }</span>)
        <span class="cov1" title="1">return</span>
}

func (cs *CertStream) CountStreams() (n int) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, logop := range cs.operators </span><span class="cov0" title="0">{
                logop.mu.Lock()
                n += len(logop.streams)
                logop.mu.Unlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cs *CertStream) getSendEntryCh() (ch chan *LogEntry) <span class="cov9" title="100">{
        cs.mu.Lock()
        ch = cs.sendEntryCh
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) Close() <span class="cov0" title="0">{
        cs.mu.Lock()
        close(cs.sendEntryCh)
        cs.sendEntryCh = nil
        cs.mu.Unlock()
        if cs.DB != nil </span><span class="cov0" title="0">{
                cs.DB.Close()
        }</span>
}

func (cs *CertStream) run(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        ticker := time.NewTicker(time.Hour * 24)

        defer func() </span><span class="cov1" title="1">{
                ticker.Stop()
                wg.Done()
        }</span>()

        <span class="cov1" title="1">_ = cs.LogError(cs.updateStreams(ctx, wg), "CertStream:run@1")

        if cs.DB != nil </span><span class="cov1" title="1">{
                wg.Add(2)
                go cs.DB.runWorkers(ctx, wg)
                go cs.DB.estimator(ctx, wg)
        }</span>

        <span class="cov1" title="1">for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        _ = cs.LogError(cs.updateStreams(ctx, wg), "CertStream:run@2")</span>
                }
        }
}

func Start(ctx context.Context, wg *sync.WaitGroup, cfg *Config) (cs *CertStream, err error) <span class="cov1" title="1">{
        tp := DefaultTransport.Clone()
        tp.DialContext = cfg.HeadDialer.DialContext
        cs = &amp;CertStream{
                Config: *cfg,
                HeadClient: &amp;http.Client{
                        Timeout:   10 * time.Second,
                        Transport: tp,
                },
                operators: map[string]*LogOperator{},
        }

        if cs.Config.TailDialer != nil </span><span class="cov1" title="1">{
                tp = DefaultTransport.Clone()
                tp.DialContext = cfg.TailDialer.DialContext
                cs.TailClient = &amp;http.Client{
                        Timeout:   10 * time.Second,
                        Transport: tp,
                }
        }</span>

        <span class="cov1" title="1">if cs.DB, err = NewPgDB(ctx, cs); err == nil </span><span class="cov1" title="1">{
                cs.mu.Lock()
                cs.sendEntryCh = make(chan *LogEntry, 1024*8)
                cs.C = cs.sendEntryCh
                cs.mu.Unlock()
                wg.Add(1)
                go cs.run(ctx, wg)
        }</span>

        <span class="cov1" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package certstream

import (
        "net"

        "golang.org/x/net/proxy"
)

type Config struct {
        Logger     Logger              // if not nil Logger to use, no default
        HeadDialer proxy.ContextDialer // dialer for following the head, defaults to &amp;net.Dialer{}
        TailDialer proxy.ContextDialer // if not nil, backfill db using this dialer, no default
        PgUser     string              // PostgreSQL user, default "certstream"
        PgPass     string              // PostgreSQL password, default "certstream"
        PgName     string              // PostgreSQL db name, default "certstream"
        PgAddr     string              // PostgreSQL address, no default
        PgPrefix   string              // PostgreSQL naming prefix, default "certdb_"
        PgConns    int                 // max number of database connections, default 100
        PgMaxAge   int                 // maximum age in days to backfill
        PgNoSSL    bool                // if true, do not use SSL
}

// NewConfig returns a new default Config
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Logger:     nil,
                HeadDialer: &amp;net.Dialer{},
                TailDialer: nil,
                PgUser:     "certstream",
                PgPass:     "certstream",
                PgName:     "certstream",
                PgAddr:     "",
                PgPrefix:   "certdb_",
                PgConns:    100,
                PgMaxAge:   90,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type errLogIdle struct {
        Since time.Time
}

func (err errLogIdle) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("log idle since %v", err.Since.Round(time.Second))
}</span>

var ErrLogIdle errLogIdle
</pre>
		
		<pre class="file" id="file4" style="display: none">package certstream

import (
        "context"
        "io"
        "net/http"

        "github.com/google/certificate-transparency-go/loglist3"
)

// GetLogList fetches a CT log list from the given listUrl.
// Usually you would pass loglist3.AllLogListURL for the listUrl.
func GetLogList(ctx context.Context, httpClient *http.Client, listUrl string) (logList *loglist3.LogList, err error) <span class="cov10" title="2">{
        var req *http.Request
        if req, err = http.NewRequestWithContext(ctx, http.MethodGet, listUrl, nil); err == nil </span><span class="cov10" title="2">{
                var resp *http.Response
                if resp, err = httpClient.Do(req); err == nil </span><span class="cov10" title="2">{
                        var b []byte
                        if b, err = io.ReadAll(resp.Body); err == nil </span><span class="cov10" title="2">{
                                logList, err = loglist3.NewFromJSON(b)
                        }</span>
                }
        }
        <span class="cov10" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package certstream

import (
        "encoding/hex"
        "net/mail"
        "slices"
        "sort"
        "strings"
        "time"

        "golang.org/x/net/idna"
)

type hexEncoded []byte

func (h hexEncoded) MarshalText() (text []byte, err error) <span class="cov0" title="0">{
        return hex.AppendEncode(nil, h), nil
}</span>

type JsonCertificate struct {
        PreCert        bool         `json:",omitempty"`
        Signature      hexEncoded   `json:",omitempty"` // SHA256 signature, searchable on crt.sh
        Issuer         JsonIdentity `json:",omitempty"`
        Subject        JsonIdentity `json:",omitempty"`
        CommonName     string       `json:",omitempty"` // Subject common name
        DNSNames       []string     `json:",omitempty"`
        EmailAddresses []string     `json:",omitempty"`
        IPAddresses    []string     `json:",omitempty"`
        URIs           []string     `json:",omitempty"`
        NotBefore      time.Time    `json:",omitempty"`
        NotAfter       time.Time    `json:",omitempty"`
        Since          time.Time    `json:",omitzero"`
}

func NewJSONCertificate(cert *Certificate) (jsoncert *JsonCertificate) <span class="cov10" title="3">{
        jsoncert = &amp;JsonCertificate{
                PreCert:    cert.PreCert,
                Signature:  cert.Signature,
                CommonName: cert.GetCommonName(),
                NotBefore:  cert.NotBefore,
                NotAfter:   cert.NotAfter,
        }
        jsoncert.Issuer.Fill(&amp;cert.Issuer)
        jsoncert.Subject.Fill(&amp;cert.Subject)

        for _, dnsname := range cert.DNSNames </span><span class="cov6" title="2">{
                dnsname = strings.ToLower(dnsname)
                if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov0" title="0">{
                        jsoncert.DNSNames = append(jsoncert.DNSNames, uniname)
                }</span> else<span class="cov6" title="2"> {
                        jsoncert.DNSNames = append(jsoncert.DNSNames, dnsname)
                }</span>
        }
        <span class="cov10" title="3">sort.Strings(jsoncert.DNSNames)

        for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                jsoncert.IPAddresses = append(jsoncert.IPAddresses, ip.String())
        }</span>
        <span class="cov10" title="3">sort.Strings(jsoncert.IPAddresses)

        for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                if m, e := mail.ParseAddress(email); e == nil </span><span class="cov0" title="0">{
                        email = m.Address
                }</span>
                <span class="cov0" title="0">jsoncert.EmailAddresses = append(jsoncert.EmailAddresses, email)</span>
        }
        <span class="cov10" title="3">sort.Strings(jsoncert.EmailAddresses)

        for _, u := range cert.URIs </span><span class="cov0" title="0">{
                jsoncert.URIs = append(jsoncert.URIs, u.String())
        }</span>
        <span class="cov10" title="3">sort.Strings(jsoncert.URIs)
        return</span>
}

func (js *JsonCertificate) SetCommonName() <span class="cov10" title="3">{
        if js.CommonName == "" </span><span class="cov1" title="1">{
                if len(js.DNSNames) &gt; 0 </span><span class="cov0" title="0">{
                        names := slices.Clone(js.DNSNames)
                        slices.Sort(names)
                        js.CommonName = js.DNSNames[0]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package certstream

import (
        "strings"

        "github.com/google/certificate-transparency-go/x509/pkix"
)

type JsonIdentity struct {
        ID           int    `json:",omitempty"`
        Country      string `json:",omitempty"`
        Organization string `json:",omitempty"`
        Province     string `json:",omitempty"`
        CommonName   string `json:",omitempty"`
}

func join(l []string) string <span class="cov10" title="21">{
        var b []byte
        for _, s := range l </span><span class="cov4" title="3">{
                if s = strings.TrimSpace(s); s != "" </span><span class="cov4" title="3">{
                        if len(b) &gt; 0 </span><span class="cov0" title="0">{
                                b = append(b, ' ')
                        }</span>
                        <span class="cov4" title="3">b = append(b, s...)</span>
                }
        }
        <span class="cov10" title="21">return string(b)</span>
}

func (id *JsonIdentity) Fill(name *pkix.Name) <span class="cov6" title="7">{
        if name != nil </span><span class="cov6" title="7">{
                id.Country = join(name.Country)
                id.Organization = join(name.Organization)
                id.Province = join(name.Province)
                id.CommonName = strings.TrimSpace(name.CommonName)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package certstream

import (
        "crypto/sha256"
        "strconv"
        "time"

        ct "github.com/google/certificate-transparency-go"
        "github.com/google/certificate-transparency-go/x509"
)

type LogEntry struct {
        *LogStream
        Err          error           // error from RawLogEntryFromLeaf or ToLogEntry, or nil
        RawLogEntry  *ct.RawLogEntry // may be nil in case of error
        *ct.LogEntry                 // may be nil in case of error
        Id           int64           // database id, if available
        Historical   bool            // true if the entry is from gap or backfilling
}

func (le *LogEntry) String() (s string) <span class="cov1" title="1">{
        var b []byte
        b = append(b, "LogEntry{"...)
        if le != nil </span><span class="cov1" title="1">{
                if le.LogStream != nil </span><span class="cov0" title="0">{
                        if le.Operator != nil </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, le.Operator.Name)
                                b = append(b, ", "...)
                        }</span>
                        <span class="cov0" title="0">if le.Log != nil </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, le.Log.URL)
                                b = append(b, ", "...)
                        }</span>
                }
                <span class="cov1" title="1">b = strconv.AppendInt(b, le.Index(), 10)
                if le.Err != nil </span><span class="cov0" title="0">{
                        b = append(b, ", "...)
                        b = strconv.AppendQuote(b, le.Err.Error())
                }</span>
        }
        <span class="cov1" title="1">b = append(b, '}')
        return string(b)</span>
}

// Cert returns the Certificate given a LogEntry or nil.
func (le *LogEntry) Cert() (crt *Certificate) <span class="cov10" title="297">{
        if le.LogEntry != nil </span><span class="cov9" title="295">{
                var cert *x509.Certificate
                var precert bool
                if cert = le.LogEntry.X509Cert; cert == nil </span><span class="cov8" title="150">{
                        if le.LogEntry.Precert != nil </span><span class="cov8" title="150">{
                                precert = true
                                cert = le.LogEntry.Precert.TBSCertificate
                        }</span>
                }
                <span class="cov9" title="295">if cert != nil </span><span class="cov9" title="295">{
                        crt = &amp;Certificate{
                                PreCert:     precert,
                                Certificate: cert,
                        }
                        if le.RawLogEntry != nil </span><span class="cov9" title="295">{
                                shasig := sha256.Sum256(le.RawLogEntry.Cert.Data)
                                crt.Signature = shasig[:]
                                tse := int64(le.RawLogEntry.Leaf.TimestampedEntry.Timestamp) //#nosec G115
                                crt.Seen = time.UnixMilli(tse).UTC()
                        }</span> else<span class="cov0" title="0"> {
                                shasig := sha256.Sum256(cert.RawTBSCertificate)
                                crt.Signature = shasig[:]
                                crt.Seen = time.Now().UTC()
                        }</span>
                }
        }
        <span class="cov10" title="297">return</span>
}

// Index returns the log index or -1 if none is available.
func (le *LogEntry) Index() (index int64) <span class="cov7" title="59">{
        index = -1
        if le.RawLogEntry != nil </span><span class="cov7" title="58">{
                index = le.RawLogEntry.Index
        }</span>
        <span class="cov7" title="59">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package certstream

import (
        "context"
        "slices"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
)

type LogOperator struct {
        *CertStream
        *loglist3.Operator
        Domain   string       // e.g. "letsencrypt.org" or "googleapis.com"
        Count    atomic.Int64 // atomic; sum of the stream's Count
        Id       int32        // database ID, if available
        mu       sync.Mutex   // protects following
        streams  map[string]*LogStream
        errcount int
        errors   []*StreamError
}

func (lo *LogOperator) StreamCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = len(lo.streams)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) ErrorCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = lo.errcount
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) Errors() (errs []*StreamError) <span class="cov0" title="0">{
        lo.mu.Lock()
        errs = append(errs, lo.errors...)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) addError(ls *LogStream, err error) <span class="cov10" title="60">{
        if err != nil </span><span class="cov10" title="60">{
                now := time.Now()
                lo.mu.Lock()
                defer lo.mu.Unlock()
                lo.errors = append(lo.errors, &amp;StreamError{LogStream: ls, When: now, Err: err})
                if len(lo.errors) &gt; MaxErrors </span><span class="cov0" title="0">{
                        lo.errors = slices.Delete(lo.errors, 0, len(lo.errors)-MaxErrors)
                }</span>
                <span class="cov10" title="60">ls.errcount++</span>
        }
}

func (lo *LogOperator) Streams() (sl []*LogStream) <span class="cov4" title="6">{
        lo.mu.Lock()
        for _, s := range lo.streams </span><span class="cov8" title="31">{
                sl = append(sl, s)
        }</span>
        <span class="cov4" title="6">lo.mu.Unlock()
        slices.SortFunc(sl, func(a, b *LogStream) int </span><span class="cov8" title="33">{ return strings.Compare(a.URL, b.URL) }</span>)
        <span class="cov4" title="6">return</span>
}

func (lo *LogOperator) makeStream(log *loglist3.Log) (ls *LogStream, err error) <span class="cov8" title="31">{
        var headLogClient *client.LogClient
        if headLogClient, err = client.New(log.URL, lo.HeadClient, jsonclient.Options{}); err == nil </span><span class="cov8" title="31">{
                var tailLogClient *client.LogClient
                if lo.TailClient != nil </span><span class="cov8" title="31">{
                        tailLogClient, err = client.New(log.URL, lo.TailClient, jsonclient.Options{})
                }</span>
                <span class="cov8" title="31">ls = &amp;LogStream{
                        LogOperator: lo,
                        Log:         log,
                        HeadClient:  headLogClient,
                        TailClient:  tailLogClient,
                }
                ls.MinIndex.Store(-1)
                ls.MaxIndex.Store(-1)
                ls.LastIndex.Store(-1)</span>
        }
        <span class="cov8" title="31">return</span>
}

func (lo *LogOperator) ensureStream(ctx context.Context, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov8" title="31">{
        lo.mu.Lock()
        ls := lo.streams[log.URL]
        lo.mu.Unlock()
        if ls == nil </span><span class="cov8" title="31">{
                if ls, err = lo.makeStream(log); err == nil </span><span class="cov8" title="31">{
                        if err = lo.DB.ensureStream(ctx, ls); err == nil </span><span class="cov8" title="31">{
                                lo.mu.Lock()
                                lo.streams[log.URL] = ls
                                lo.mu.Unlock()
                                wg.Add(1)
                                go ls.run(ctx, wg)
                        }</span>
                }
        }
        <span class="cov8" title="31">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        ct "github.com/google/certificate-transparency-go"
        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
        "github.com/google/trillian/client/backoff"
)

var BatchSize = 1024
var MaxErrors = 100
var IdleCloseTime = time.Hour * 24 * 7

type handleEntryFn func(ctx context.Context, now time.Time, logindex int64, entry ct.LeafEntry, historical bool) (wanted bool)

type LogStream struct {
        *LogOperator
        *loglist3.Log
        HeadClient *client.LogClient
        TailClient *client.LogClient
        Count      atomic.Int64 // number of certificates sent to the channel
        MinIndex   atomic.Int64 // atomic: lowest index seen so far, -1 if none seen yet
        MaxIndex   atomic.Int64 // atomic: highest index seen so far, -1 if none seen yet
        LastIndex  atomic.Int64 // atomic: highest index that is available from stream source
        InsideGaps atomic.Int64 // atomic: number of remaining entries inside gaps
        Id         int32        // database ID, if available
}

func (ls *LogStream) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("LogStream{%q}", ls.Log.URL)
}</span>

func sleep(ctx context.Context, d time.Duration) <span class="cov0" title="0">{
        tmr := time.NewTimer(d)
        defer tmr.Stop()
        select </span>{
        case &lt;-tmr.C:<span class="cov0" title="0"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        }
}

func (ls *LogStream) getEndSeen(ctx context.Context, end int64) (seen time.Time) <span class="cov7" title="31">{
        fn := func(ctx context.Context, now time.Time, logindex int64, entry ct.LeafEntry, historical bool) (wanted bool) </span><span class="cov7" title="28">{
                le := ls.makeLogEntry(logindex, entry, historical)
                if cert := le.Cert(); cert != nil </span><span class="cov7" title="28">{
                        seen = cert.Seen
                }</span>
                <span class="cov7" title="28">return</span>
        }
        <span class="cov7" title="31">ls.GetRawEntries(ctx, end, end, false, fn, nil)
        return</span>
}

func (ls *LogStream) run(ctx context.Context, wg *sync.WaitGroup) <span class="cov7" title="31">{
        var end int64
        var err error
        var wg2 sync.WaitGroup
        defer func() </span><span class="cov7" title="31">{
                ls.addError(ls, err)
                wg2.Wait()
                ls.removeStream(ls)
                if e, ok := err.(errLogIdle); ok </span><span class="cov0" title="0">{
                        ls.LogInfo("stream stopped", "url", ls.URL, "stream", ls.Id, "idle-since", e.Since)
                }</span> else<span class="cov7" title="31"> {
                        _ = ls.LogError(err, "stream stopped", "url", ls.URL, "stream", ls.Id)
                }</span>
                <span class="cov7" title="31">wg.Done()</span>
        }()

        <span class="cov7" title="31">end, err = ls.NewLastIndex(ctx)
        if seen := ls.getEndSeen(ctx, end); !seen.IsZero() </span><span class="cov7" title="28">{
                if time.Since(seen) &gt; IdleCloseTime </span><span class="cov0" title="0">{
                        err = errLogIdle{Since: seen}
                        return
                }</span>
        }

        <span class="cov7" title="31">start := end
        if cdb := ls.DB; cdb != nil </span><span class="cov7" title="31">{
                if ls.CertStream.Config.TailDialer != nil </span><span class="cov7" title="31">{
                        wg2.Add(1)
                        go cdb.backfillStream(ctx, ls, &amp;wg2)
                }</span>
        }

        <span class="cov7" title="31">for err == nil </span><span class="cov7" title="31">{
                if start &lt; end </span><span class="cov0" title="0">{
                        ls.GetRawEntries(ctx, start, end, false, ls.sendEntry, nil)
                        if end-start &lt;= int64(BatchSize/2) </span><span class="cov0" title="0">{
                                sleep(ctx, time.Second*15)
                        }</span>
                        <span class="cov0" title="0">start = end</span>
                }
                <span class="cov7" title="31">end, err = ls.NewLastIndex(ctx)</span>
        }
}

func (ls *LogStream) NewLastIndex(ctx context.Context) (lastIndex int64, err error) <span class="cov8" title="62">{
        bo := &amp;backoff.Backoff{
                Min:    1 * time.Second,
                Max:    5 * time.Minute,
                Factor: 2,
                Jitter: true,
        }
        now := time.Now()
        lastIndex = ls.LastIndex.Load()
        err = bo.Retry(ctx, func() error </span><span class="cov8" title="66">{
                var sth *ct.SignedTreeHead
                sth, err = ls.HeadClient.GetSTH(ctx)
                if err == nil </span><span class="cov8" title="62">{
                        newIndex := int64(sth.TreeSize) - 1 //#nosec G115
                        if lastIndex &lt; newIndex </span><span class="cov7" title="39">{
                                if lastIndex+int64(BatchSize) &lt; newIndex || time.Since(now) &gt; time.Second*15 </span><span class="cov7" title="31">{
                                        lastIndex = newIndex
                                        ls.LastIndex.Store(lastIndex)
                                        return nil
                                }</span>
                        } else<span class="cov6" title="23"> {
                                if time.Since(now) &gt; IdleCloseTime </span><span class="cov0" title="0">{
                                        return errLogIdle{Since: now}
                                }</span>
                        }
                        <span class="cov7" title="31">return backoff.RetriableError("STH diff too low")</span>
                }
                <span class="cov3" title="4">if ls.handleStreamError(err, "GetSTH") </span><span class="cov3" title="4">{
                        return err
                }</span>
                <span class="cov0" title="0">return backoff.RetriableError(err.Error())</span>
        })
        <span class="cov8" title="62">return</span>
}

func (ls *LogStream) seeIndex(logindex int64) <span class="cov10" title="141">{
        if logindex &gt;= 0 </span><span class="cov10" title="141">{
                if x := ls.MinIndex.Load(); x &gt; logindex || x == -1 </span><span class="cov7" title="33">{
                        ls.MinIndex.CompareAndSwap(x, logindex)
                }</span>
                <span class="cov10" title="141">if x := ls.MaxIndex.Load(); x &lt; logindex || x == -1 </span><span class="cov7" title="30">{
                        ls.MaxIndex.CompareAndSwap(x, logindex)
                }</span>
        }
}

func (ls *LogStream) makeLogEntry(logindex int64, entry ct.LeafEntry, historical bool) *LogEntry <span class="cov9" title="139">{
        var ctle *ct.LogEntry
        ctrle, leaferr := ct.RawLogEntryFromLeaf(logindex, &amp;entry)
        if leaferr == nil </span><span class="cov9" title="139">{
                ctle, leaferr = ctrle.ToLogEntry()
        }</span>
        <span class="cov9" title="139">return &amp;LogEntry{
                LogStream:   ls,
                Err:         leaferr,
                RawLogEntry: ctrle,
                LogEntry:    ctle,
                Historical:  historical,
        }</span>
}

func (ls *LogStream) sendEntry(ctx context.Context, now time.Time, logindex int64, entry ct.LeafEntry, historical bool) (wanted bool) <span class="cov9" title="111">{
        le := ls.makeLogEntry(logindex, entry, historical)
        if cert := le.Cert(); cert != nil </span><span class="cov9" title="111">{
                ls.seeIndex(logindex)
                wanted = now.Before(cert.NotAfter) || now.Sub(cert.Seen) &lt; time.Hour*24*time.Duration(ls.PgMaxAge)
                if ctx.Err() == nil </span><span class="cov9" title="100">{
                        if ls.DB != nil </span><span class="cov9" title="100">{
                                ls.DB.sendToBatcher(ctx, le)
                        }</span>
                        <span class="cov9" title="100">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        case ls.getSendEntryCh() &lt;- le:<span class="cov9" title="100">
                                ls.Count.Add(1)
                                ls.LogOperator.Count.Add(1)</span>
                        }
                }
        }
        <span class="cov9" title="111">return</span>
}

func (ls *LogStream) handleStreamError(err error, from string) (fatal bool) <span class="cov7" title="36">{
        errTxt := err.Error()
        if errors.Is(err, context.Canceled) || strings.Contains(errTxt, "context canceled") </span><span class="cov7" title="34">{
                return true
        }</span>
        <span class="cov2" title="2">if errors.Is(err, context.DeadlineExceeded) || strings.Contains(errTxt, "deadline exceeded") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="2">rspErr, isRspErr := err.(jsonclient.RspError)
        if isRspErr </span><span class="cov2" title="2">{
                switch rspErr.StatusCode </span>{
                case http.StatusTooManyRequests,
                        http.StatusGatewayTimeout:<span class="cov0" title="0">
                        return false</span>
                }
        }
        <span class="cov2" title="2">ls.addError(ls, wrapErr(err, from))
        if isRspErr </span><span class="cov2" title="2">{
                switch rspErr.StatusCode </span>{
                case http.StatusInternalServerError,
                        http.StatusBadGateway:<span class="cov0" title="0">
                        return false</span>
                }
        }
        <span class="cov2" title="2">return true</span>
}

func (ls *LogStream) GetRawEntries(ctx context.Context, start, end int64, historical bool, handleFn handleEntryFn, gapcounter *atomic.Int64) (wanted bool) <span class="cov8" title="61">{
        client := ls.HeadClient
        if historical &amp;&amp; ls.TailClient != nil </span><span class="cov7" title="30">{
                client = ls.TailClient
        }</span>
        <span class="cov8" title="61">for start &lt;= end </span><span class="cov8" title="64">{
                if ctx.Err() != nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov8" title="63">bo := &amp;backoff.Backoff{
                        Min:    1 * time.Second,
                        Max:    30 * time.Second,
                        Factor: 2,
                        Jitter: true,
                }
                var resp *ct.GetEntriesResponse
                stop := start + min(int64(BatchSize), end-start)
                if err := bo.Retry(ctx, func() error </span><span class="cov8" title="63">{
                        var err error
                        resp, err = client.GetRawEntries(ctx, start, stop)
                        return err
                }</span>); err != nil <span class="cov7" title="32">{
                        if ls.handleStreamError(err, "GetRawEntries") </span><span class="cov7" title="32">{
                                if gapcounter != nil </span><span class="cov0" title="0">{
                                        ls.LogInfo("gap not fillable", "url", ls.URL, "start", start, "end", end, "err", err)
                                        gapcounter.Add(start - (end + 1))
                                }</span>
                                <span class="cov7" title="32">return</span>
                        }
                } else<span class="cov7" title="31"> {
                        now := time.Now()
                        for i := range resp.Entries </span><span class="cov9" title="139">{
                                if handleFn(ctx, now, start, resp.Entries[i], historical) </span><span class="cov9" title="111">{
                                        wanted = true
                                }</span>
                                <span class="cov9" title="139">start++
                                if gapcounter != nil </span><span class="cov0" title="0">{
                                        gapcounter.Add(-1)
                                }</span>
                        }
                        <span class="cov7" title="31">if historical &amp;&amp; !wanted </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov7" title="31">for historical &amp;&amp; ctx.Err() == nil &amp;&amp; ls.DB != nil &amp;&amp; ls.DB.QueueUsage() &gt; 50 </span><span class="cov0" title="0">{
                        time.Sleep(time.Millisecond * 100)
                }</span>
        }
        <span class="cov7" title="28">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package certstream

import (
        "net/url"
        "strings"
)

// OperatorDomain returns the TLD+1 given an URL.
func OperatorDomain(urlString string) string <span class="cov10" title="36">{
        opDom := urlString
        if u, err := url.Parse(urlString); err == nil </span><span class="cov10" title="36">{
                opDom = u.Hostname()
                if idx := strings.LastIndexByte(opDom, '.'); idx &gt; 0 </span><span class="cov9" title="35">{
                        if idx := strings.LastIndexByte(opDom[:idx], '.'); idx &gt; 0 </span><span class="cov9" title="33">{
                                opDom = opDom[idx+1:]
                        }</span>
                }
        }
        <span class="cov10" title="36">return opDom</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package certstream

import (
        "context"
        "database/sql"
        "fmt"
        "sync"
)

var BulkRange = int64(4096)

func (cdb *PgDB) backfillGaps(ctx context.Context, ls *LogStream) <span class="cov9" title="30">{
        type gap struct {
                start int64
                end   int64
        }
        var gaps []gap
        if lastindex := ls.LastIndex.Load(); lastindex != -1 </span><span class="cov9" title="30">{
                row := cdb.QueryRow(ctx, cdb.stmtSelectMaxIdx, ls.Id)
                var nullableMaxIndex sql.NullInt64
                if err := row.Scan(&amp;nullableMaxIndex); cdb.LogError(err, "backfillGaps/MaxIndex", "url", ls.URL) == nil </span><span class="cov9" title="30">{
                        if nullableMaxIndex.Valid </span><span class="cov0" title="0">{
                                ls.seeIndex(nullableMaxIndex.Int64)
                                if nullableMaxIndex.Int64 &lt; lastindex </span><span class="cov0" title="0">{
                                        gaps = append(gaps, gap{start: nullableMaxIndex.Int64 + 1, end: lastindex})
                                }</span>
                        }
                }
        }
        <span class="cov9" title="30">if rows, err := cdb.Query(ctx, cdb.stmtSelectGaps, ls.Id); cdb.LogError(err, "backfillGaps/Query", "url", ls.URL) == nil </span><span class="cov9" title="30">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var gap_start, gap_end int64
                        if err = rows.Scan(&amp;gap_start, &amp;gap_end); cdb.LogError(err, "backfillGaps/Scan", "url", ls.URL) == nil </span><span class="cov0" title="0">{
                                gaps = append(gaps, gap{start: gap_start, end: gap_end})
                        }</span>
                }
                <span class="cov9" title="30">rows.Close()</span>
        }
        <span class="cov9" title="30">for _, gap := range gaps </span><span class="cov0" title="0">{
                ls.InsideGaps.Add((gap.end - gap.start) + 1)
        }</span>
        <span class="cov9" title="30">for _, gap := range gaps </span><span class="cov0" title="0">{
                if ctx.Err() == nil </span><span class="cov0" title="0">{
                        cdb.LogInfo("gap", "url", ls.URL, "stream", ls.Id, "logindex", gap.start, "length", (gap.end-gap.start)+1)
                        ls.GetRawEntries(ctx, gap.start, gap.end, true, ls.sendEntry, &amp;ls.InsideGaps)
                }</span>
        }
}

func (cdb *PgDB) backfillStream(ctx context.Context, ls *LogStream, wg *sync.WaitGroup) <span class="cov10" title="31">{
        defer wg.Done()
        row := cdb.QueryRow(ctx, cdb.stmtSelectMinIdx, ls.Id)
        var nullableMinIndex sql.NullInt64
        if err := cdb.LogError(row.Scan(&amp;nullableMinIndex), "Backfill/MinIndex", "url", ls.URL); err == nil </span><span class="cov9" title="30">{
                if !nullableMinIndex.Valid </span><span class="cov9" title="30">{
                        nullableMinIndex.Int64 = ls.LastIndex.Load()
                }</span>
                <span class="cov9" title="30">minIndex := nullableMinIndex.Int64
                ls.seeIndex(minIndex)
                cdb.backfillGaps(ctx, ls)
                if minIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov9" title="30">{
                        cdb.LogInfo("backlog start", "url", ls.URL, "stream", ls.Id, "logindex", minIndex)
                        for minIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov9" title="30">{
                                start := max(0, minIndex-BulkRange)
                                stop := minIndex - 1
                                minIndex = start
                                if !ls.GetRawEntries(ctx, start, stop, true, ls.sendEntry, nil) </span><span class="cov9" title="27">{
                                        cdb.LogInfo("backlog stops", "url", ls.URL, "stream", ls.Id, "logindex", minIndex)
                                        ls.addError(ls, fmt.Errorf("log entries are older than %d days", cdb.PgMaxAge))
                                        return
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package certstream

import (
        "context"
        "sync"
        "time"

        "github.com/jackc/pgx/v5"
)

const batcherQueueSize = 16 * 1024

func (cdb *PgDB) runBatch(ctx context.Context, batch *pgx.Batch) (err error) <span class="cov1" title="2">{
        now := time.Now()
        err = cdb.SendBatch(ctx, batch).Close()
        elapsed := time.Since(now)
        cdb.mu.Lock()
        cdb.newentrycount += int64(len(batch.QueuedQueries))
        cdb.newentrytime += elapsed
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) worker(ctx context.Context, wg *sync.WaitGroup, idlecount int) <span class="cov1" title="1">{
        defer func() </span><span class="cov1" title="1">{
                cdb.Workers.Add(-1)
                wg.Done()
        }</span>()

        <span class="cov1" title="1">cdb.Workers.Add(1)
        batch := &amp;pgx.Batch{}

        for </span><span class="cov6" title="72">{
                if ctx.Err() != nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov6" title="71">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case le, ok := &lt;-cdb.getBatchCh():<span class="cov6" title="56">
                        if ok &amp;&amp; le != nil </span><span class="cov6" title="56">{
                                batch.Queue(cdb.stmtNewEntry, cdb.queueEntry(le)...)
                                if len(batch.QueuedQueries) &gt;= BatchSize </span><span class="cov0" title="0">{
                                        if cdb.LogError(cdb.runBatch(ctx, batch), "worker@1") != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">batch = &amp;pgx.Batch{}</span>
                                }
                        }
                default:<span class="cov4" title="15">
                        if len(batch.QueuedQueries) &gt; 0 </span><span class="cov1" title="2">{
                                if cdb.LogError(cdb.runBatch(ctx, batch), "worker@2") != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov1" title="2">batch = &amp;pgx.Batch{}</span>
                        } else<span class="cov4" title="13"> {
                                if idlecount &gt; 0 </span><span class="cov0" title="0">{
                                        idlecount--
                                        if idlecount == 0 </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                                <span class="cov4" title="13">time.Sleep(time.Millisecond * 100)</span>
                        }
                }
        }
}

func (cdb *PgDB) AverageNewEntryTime() (d time.Duration) <span class="cov0" title="0">{
        cdb.mu.Lock()
        d = cdb.avgentrytime
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) runWorkers(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        const interval = time.Millisecond * 100
        defer wg.Done()

        wg.Add(1)
        go cdb.worker(ctx, wg, -1)

        loaded := 0
        ticks := 0
        ticker := time.NewTicker(interval)
        avgentrytimes := make([]time.Duration, time.Second*10/interval)
        defer ticker.Stop()
        for </span><span class="cov4" title="14">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov4" title="13">
                        cdb.mu.Lock()
                        avgentrytime := cdb.newentrytime
                        if d := time.Duration(cdb.newentrycount); d &gt; 0 </span><span class="cov1" title="1">{
                                avgentrytime /= d
                        }</span>
                        <span class="cov4" title="13">cdb.newentrytime = 0
                        cdb.newentrycount = 0
                        avgentrytimes[ticks] = avgentrytime
                        ticks++
                        if ticks &gt;= cap(avgentrytimes) </span><span class="cov0" title="0">{
                                ticks = 0
                        }</span>
                        <span class="cov4" title="13">avgentrytime = 0
                        for _, d := range avgentrytimes </span><span class="cov10" title="1300">{
                                avgentrytime += d
                        }</span>
                        <span class="cov4" title="13">cdb.avgentrytime = avgentrytime / time.Duration(cap(avgentrytimes))
                        cdb.mu.Unlock()

                        if cdb.QueueUsage() &gt; 30 </span><span class="cov0" title="0">{
                                loaded++
                                if loaded &gt; 10 </span><span class="cov0" title="0">{
                                        loaded /= 2
                                        wg.Add(1)
                                        go cdb.worker(ctx, wg, 10)
                                }</span>
                        } else<span class="cov4" title="13"> {
                                loaded = 0
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package certstream

import (
        "time"
)

type PgCertificate struct {
        Id         int64
        NotBefore  time.Time
        NotAfter   time.Time
        CommonName string
        SubjectID  int
        IssuerID   int
        Sha256     []byte
        PreCert    bool
        Since      time.Time
}

func ScanCertificate(row Scanner, cert *PgCertificate) (err error) <span class="cov0" title="0">{
        var p_since *time.Time
        if err = row.Scan(
                &amp;cert.Id,
                &amp;cert.NotBefore,
                &amp;cert.NotAfter,
                &amp;cert.CommonName,
                &amp;cert.SubjectID,
                &amp;cert.IssuerID,
                &amp;cert.Sha256,
                &amp;cert.PreCert,
                &amp;p_since,
        ); err == nil </span><span class="cov0" title="0">{
                if p_since != nil </span><span class="cov0" title="0">{
                        cert.Since = *p_since
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package certstream

import (
        "context"
        _ "embed"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "golang.org/x/net/idna"
)

type Scanner interface {
        Scan(dest ...any) error
}

// PgDB integrates with sql.DB to manage certificate stream data for a PostgreSQL database
type PgDB struct {
        *CertStream
        *pgxpool.Pool
        Pfx                   func(string) string // prefix replacer
        Workers               atomic.Int32
        funcOperatorID        string
        funcStreamID          string
        funcEnsureIdent       string
        funcFindSince         string
        stmtNewEntry          string
        stmtSelectGaps        string
        stmtSelectMinIdx      string
        stmtSelectMaxIdx      string
        stmtSelectDnsnameLike string
        stmtSelectIDSince     string
        mu                    sync.Mutex // protects following
        batchCh               chan *LogEntry
        estimates             map[string]float64 // row count estimates
        newentrytime          time.Duration
        newentrycount         int64
        avgentrytime          time.Duration
}

func ensureSchema(ctx context.Context, db *pgxpool.Pool, pfx func(string) string) (err error) <span class="cov1" title="1">{
        if _, err = db.Exec(ctx, pfx(CreateSchema)); err == nil </span><span class="cov1" title="1">{
                if _, err = db.Exec(ctx, pfx(FunctionOperatorID)); err == nil </span><span class="cov1" title="1">{
                        if _, err = db.Exec(ctx, pfx(FunctionStreamID)); err == nil </span><span class="cov1" title="1">{
                                if _, err = db.Exec(ctx, pfx(FunctionFindSince)); err == nil </span><span class="cov1" title="1">{
                                        _, err = db.Exec(ctx, pfx(ProcAddNewEntry))
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

// NewPgDB creates a PgDB and creates the needed tables and indices if they don't exist.
func NewPgDB(ctx context.Context, cs *CertStream) (cdb *PgDB, err error) <span class="cov1" title="1">{
        const callOperatorID = `SELECT CERTDB_operator_id($1,$2);`
        const callStreamID = `SELECT CERTDB_stream_id($1,$2,$3);`
        const callFindSince = `SELECT CERTDB_find_since($1,$2,$3,$4);`
        const callNewEntry = `CALL CERTDB_add_new_entry($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18);`

        if cs.Config.PgAddr != "" </span><span class="cov1" title="1">{
                dsn := fmt.Sprintf("postgres://%s:%s@%s/%s?pool_max_conns=%d&amp;pool_max_conn_idle_time=1m",
                        cs.Config.PgUser, cs.Config.PgPass, cs.Config.PgAddr, cs.Config.PgName, cs.Config.PgConns)
                if cs.Config.PgNoSSL </span><span class="cov1" title="1">{
                        dsn += "&amp;sslmode=disable"
                }</span>
                <span class="cov1" title="1">var poolcfg *pgxpool.Config
                if poolcfg, err = pgxpool.ParseConfig(dsn); err == nil </span><span class="cov1" title="1">{
                        var pool *pgxpool.Pool
                        if pool, err = pgxpool.NewWithConfig(ctx, poolcfg); err == nil </span><span class="cov1" title="1">{
                                if err = pool.Ping(ctx); err == nil </span><span class="cov1" title="1">{
                                        cs.LogInfo("database", "addr", cs.Config.PgAddr, "name", cs.Config.PgName, "prefix", cs.Config.PgPrefix)
                                        pfx := func(s string) string </span><span class="cov5" title="18">{ return strings.ReplaceAll(s, "CERTDB_", cs.Config.PgPrefix) }</span>
                                        <span class="cov1" title="1">if err = ensureSchema(ctx, pool, pfx); err == nil </span><span class="cov1" title="1">{
                                                var pgversion string
                                                if cs.LogError(pool.QueryRow(ctx, `SELECT version();`).Scan(&amp;pgversion), "postgres version") == nil </span><span class="cov1" title="1">{
                                                        cs.LogInfo("postgres", "version", pgversion)
                                                }</span>
                                                <span class="cov1" title="1">cdb = &amp;PgDB{
                                                        CertStream:            cs,
                                                        Pool:                  pool,
                                                        Pfx:                   pfx,
                                                        funcOperatorID:        pfx(callOperatorID),
                                                        funcStreamID:          pfx(callStreamID),
                                                        funcEnsureIdent:       pfx(`SELECT CERTDB_ensure_ident($1,$2,$3);`),
                                                        funcFindSince:         pfx(callFindSince),
                                                        stmtNewEntry:          pfx(callNewEntry),
                                                        stmtSelectGaps:        pfx(SelectGaps),
                                                        stmtSelectMinIdx:      pfx(SelectMinIndex),
                                                        stmtSelectMaxIdx:      pfx(SelectMaxIndex),
                                                        stmtSelectDnsnameLike: pfx(SelectDnsnameLike),
                                                        stmtSelectIDSince:     pfx(SelectIDSince),
                                                        batchCh:               make(chan *LogEntry, batcherQueueSize),
                                                        estimates: map[string]float64{
                                                                "cert":   0,
                                                                "domain": 0,
                                                                "entry":  0,
                                                        },
                                                }
                                                cdb.refreshEstimates(ctx)</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

func (cdb *PgDB) Close() <span class="cov0" title="0">{
        cdb.mu.Lock()
        close(cdb.batchCh)
        cdb.batchCh = nil
        cdb.mu.Unlock()
        cdb.Pool.Close()
}</span>

func (cdb *PgDB) QueueUsage() (pct int) <span class="cov5" title="15">{
        pct = len(cdb.getBatchCh()) * 100 / batcherQueueSize
        return
}</span>

func (cdb *PgDB) getBatchCh() (ch chan *LogEntry) <span class="cov10" title="186">{
        cdb.mu.Lock()
        ch = cdb.batchCh
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) sendToBatcher(ctx context.Context, le *LogEntry) <span class="cov8" title="100">{
        if le != nil &amp;&amp; ctx.Err() == nil </span><span class="cov8" title="100">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                case cdb.getBatchCh() &lt;- le:<span class="cov8" title="100"></span>
                }
        }
}

func (cdb *PgDB) ensureOperator(ctx context.Context, lo *LogOperator) (err error) <span class="cov4" title="6">{
        if cdb != nil </span><span class="cov4" title="6">{
                row := cdb.QueryRow(ctx, cdb.funcOperatorID, lo.Name, strings.Join(lo.Email, ","))
                err = wrapErr(row.Scan(&amp;lo.Id), cdb.funcOperatorID)
        }</span>
        <span class="cov4" title="6">return</span>
}

func (cdb *PgDB) ensureStream(ctx context.Context, ls *LogStream) (err error) <span class="cov6" title="31">{
        if cdb != nil </span><span class="cov6" title="31">{
                var b []byte
                if b, err = json.Marshal(ls.Log); err == nil </span><span class="cov6" title="31">{
                        row := cdb.QueryRow(ctx, cdb.funcStreamID, ls.URL, ls.LogOperator.Id, string(b))
                        err = wrapErr(row.Scan(&amp;ls.Id), cdb.funcStreamID)
                }</span>
        }
        <span class="cov6" title="31">return</span>
}

func (cdb *PgDB) queueEntry(le *LogEntry) (args []any) <span class="cov7" title="56">{
        if cert := le.Cert(); cert != nil </span><span class="cov7" title="56">{
                logindex := le.Index()

                var dnsnames []string
                for _, dnsname := range cert.DNSNames </span><span class="cov9" title="143">{
                        dnsname = strings.ToLower(dnsname)
                        if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov0" title="0">{
                                dnsnames = append(dnsnames, uniname)
                        }</span> else<span class="cov9" title="143"> {
                                dnsnames = append(dnsnames, dnsname)
                        }</span>
                }

                <span class="cov7" title="56">var ipaddrs []string
                for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                        ipaddrs = append(ipaddrs, ip.String())
                }</span>

                <span class="cov7" title="56">var emails []string
                for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                        emails = append(emails, strings.ReplaceAll(email, " ", "_"))
                }</span>

                <span class="cov7" title="56">var uris []string
                for _, uri := range cert.URIs </span><span class="cov0" title="0">{
                        uris = append(uris, strings.ReplaceAll(uri.String(), " ", "%20"))
                }</span>

                <span class="cov7" title="56">args = []any{
                        cert.Seen,
                        le.LogStream.Id,
                        logindex,
                        cert.PreCert,
                        cert.Signature,
                        strings.Join(cert.Issuer.Organization, ","),
                        strings.Join(cert.Issuer.Province, ","),
                        strings.Join(cert.Issuer.Country, ","),
                        strings.Join(cert.Subject.Organization, ","),
                        strings.Join(cert.Subject.Province, ","),
                        strings.Join(cert.Subject.Country, ","),
                        cert.NotBefore,
                        cert.NotAfter,
                        cert.GetCommonName(),
                        strings.Join(dnsnames, " "),
                        strings.Join(ipaddrs, " "),
                        strings.Join(emails, " "),
                        strings.Join(uris, " "),
                }</span>
        }
        <span class="cov7" title="56">return</span>
}

func (cdb *PgDB) fillIdentity(ctx context.Context, id int, ident *JsonIdentity) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT * FROM CERTDB_ident WHERE id=$1;`), id)
        var dbident PgIdent
        if err := cdb.LogError(ScanIdent(row, &amp;dbident), "fillIdentity", "id", id); err == nil </span><span class="cov0" title="0">{
                ident.ID = id
                ident.Country = dbident.Country
                ident.Organization = dbident.Organization
                ident.Province = dbident.Province
        }</span>
}

func (cdb *PgDB) getCertStrings(ctx context.Context, id int64, tablename, colname string) (sl []string) <span class="cov0" title="0">{
        rows, err := cdb.Query(ctx, cdb.Pfx(fmt.Sprintf("SELECT %s::text FROM CERTDB_%s WHERE cert=$1;", colname, tablename)), id)
        if cdb.LogError(err, "getCertStrings/"+tablename, "id", id) == nil </span><span class="cov0" title="0">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var s string
                        if err := cdb.LogError(rows.Scan(&amp;s), "getCertStrings/scan/"+tablename); err == nil </span><span class="cov0" title="0">{
                                sl = append(sl, s)
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) getCertificate(ctx context.Context, dbcert *PgCertificate) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        cert = &amp;JsonCertificate{
                PreCert:        dbcert.PreCert,
                Signature:      dbcert.Sha256,
                CommonName:     dbcert.CommonName,
                DNSNames:       []string{},
                EmailAddresses: []string{},
                IPAddresses:    []string{},
                URIs:           []string{},
                NotBefore:      dbcert.NotBefore,
                NotAfter:       dbcert.NotAfter,
                Since:          dbcert.Since,
        }
        cdb.fillIdentity(ctx, dbcert.IssuerID, &amp;cert.Issuer)
        cdb.fillIdentity(ctx, dbcert.SubjectID, &amp;cert.Subject)
        cert.Subject.CommonName = dbcert.CommonName
        cert.DNSNames = cdb.getCertStrings(ctx, dbcert.Id, "dnsnames", "fqdn")
        cert.EmailAddresses = cdb.getCertStrings(ctx, dbcert.Id, "email", "email")
        cert.IPAddresses = cdb.getCertStrings(ctx, dbcert.Id, "ipaddress", "addr")
        for i := range cert.IPAddresses </span><span class="cov0" title="0">{
                cert.IPAddresses[i] = strings.TrimSuffix(cert.IPAddresses[i], "/32")
        }</span>
        <span class="cov0" title="0">cert.URIs = cdb.getCertStrings(ctx, dbcert.Id, "uri", "uri")
        cert.SetCommonName()
        return</span>
}

func (cdb *PgDB) GetCertificateByLogEntry(ctx context.Context, entry *PgLogEntry) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        return cdb.GetCertificateByID(ctx, entry.CertID)
}</span>

func (cdb *PgDB) GetCertificateSince(ctx context.Context, jcert *JsonCertificate) (since time.Time, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.stmtSelectIDSince,
                jcert.Subject.CommonName,
                jcert.Subject.Organization, jcert.Subject.Province, jcert.Subject.Country,
                jcert.Issuer.Organization, jcert.Issuer.Province, jcert.Issuer.Country,
                jcert.NotBefore,
        )
        var id int64
        var subject, issuer int
        var notbefore time.Time
        var p_since *time.Time
        if err = row.Scan(&amp;id, &amp;subject, &amp;issuer, &amp;notbefore, &amp;p_since); err == nil </span><span class="cov0" title="0">{
                if p_since != nil </span><span class="cov0" title="0">{
                        since = *p_since
                }</span> else<span class="cov0" title="0"> {
                        since = notbefore
                }</span>
        }
        <span class="cov0" title="0">if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificatesByCommonName(ctx context.Context, commonname string) (certs []*JsonCertificate, err error) <span class="cov0" title="0">{
        var rows pgx.Rows
        if rows, err = cdb.Query(ctx, cdb.Pfx(`SELECT * FROM CERTDB_cert WHERE commonname=$1 ORDER BY notbefore DESC;`), commonname); err == nil </span><span class="cov0" title="0">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var dbcert PgCertificate
                        e := ScanCertificate(rows, &amp;dbcert)
                        if e == nil </span><span class="cov0" title="0">{
                                var cert *JsonCertificate
                                if cert, e = cdb.getCertificate(ctx, &amp;dbcert); e == nil </span><span class="cov0" title="0">{
                                        certs = append(certs, cert)
                                }</span>
                        }
                        <span class="cov0" title="0">err = errors.Join(err, e)</span>
                }
                <span class="cov0" title="0">err = errors.Join(err, rows.Err())</span>
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByHash(ctx context.Context, hash []byte) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT * FROM CERTDB_cert WHERE sha256=$1;`), hash)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByID(ctx context.Context, id int64) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT * FROM CERTDB_cert WHERE id=$1;`), id)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) Estimate(table string) (f float64) <span class="cov0" title="0">{
        table = strings.TrimPrefix(table, "CERTDB_")
        table = strings.TrimPrefix(table, cdb.CertStream.Config.PgPrefix)
        cdb.mu.Lock()
        f = cdb.estimates[table]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) refreshEstimatesBatch() (batch *pgx.Batch) <span class="cov1" title="1">{
        batch = &amp;pgx.Batch{}
        cdb.mu.Lock()
        defer cdb.mu.Unlock()
        for k := range cdb.estimates </span><span class="cov2" title="3">{
                table := cdb.Pfx("CERTDB_" + k)
                batch.Queue(SelectEstimate, table).QueryRow(func(row pgx.Row) error </span><span class="cov2" title="3">{
                        var estimate float64
                        if cdb.LogError(row.Scan(&amp;estimate), "refreshEstimates", "table", table) == nil </span><span class="cov2" title="3">{
                                cdb.mu.Lock()
                                cdb.estimates[k] = estimate
                                cdb.mu.Unlock()
                        }</span>
                        <span class="cov2" title="3">return nil</span>
                })
        }
        <span class="cov1" title="1">return</span>
}

func (cdb *PgDB) refreshEstimates(ctx context.Context) <span class="cov1" title="1">{
        if batch := cdb.refreshEstimatesBatch(); batch != nil </span><span class="cov1" title="1">{
                ctx, cancel := context.WithTimeout(ctx, time.Minute)
                defer cancel()
                _ = cdb.LogError(cdb.SendBatch(ctx, batch).Close(), "refreshEstimates")
        }</span>
}

func (cdb *PgDB) estimator(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        defer wg.Done()
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()
        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cdb.refreshEstimates(ctx)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package certstream

type PgDnsname struct {
        Dnsname string
        CertID  int64
}

func ScanDnsname(row Scanner, p *PgDnsname) error <span class="cov0" title="0">{
        return row.Scan(
                &amp;p.Dnsname,
                &amp;p.CertID,
        )
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package certstream

import (
        "time"
)

type PgDnsnamesView struct {
        CertID    int64
        FQDN      string
        NotBefore time.Time
        Idna      bool
        Valid     bool
        PreCert   bool
        Issuer    string
        Subject   string
        Crtsh     string
        Domain    string
        Tld       string
}

func ScanDnsnamesView(row Scanner, dnsname *PgDnsnamesView) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;dnsname.CertID,
                &amp;dnsname.FQDN,
                &amp;dnsname.NotBefore,
                &amp;dnsname.Idna,
                &amp;dnsname.Valid,
                &amp;dnsname.PreCert,
                &amp;dnsname.Issuer,
                &amp;dnsname.Subject,
                &amp;dnsname.Crtsh,
                &amp;dnsname.Domain,
                &amp;dnsname.Tld,
        )
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package certstream

type PgIdent struct {
        Id           int
        Organization string
        Province     string
        Country      string
}

func ScanIdent(row Scanner, ident *PgIdent) error <span class="cov0" title="0">{
        return row.Scan(
                &amp;ident.Id,
                &amp;ident.Organization,
                &amp;ident.Province,
                &amp;ident.Country,
        )
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package certstream

import (
        "time"
)

type PgLogEntry struct {
        Seen     time.Time // CT log entry timestamp
        LogIndex int64     // CT log index for the stream
        CertID   int64     // database ID of cert
        StreamID int       // database ID of stream
}

func ScanLogEntry(row Scanner, entry *PgLogEntry) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;entry.Seen,
                &amp;entry.LogIndex,
                &amp;entry.CertID,
                &amp;entry.StreamID,
        )
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type StreamError struct {
        *LogStream
        When time.Time
        Err  error
}

func (ewt StreamError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("%v %s", ewt.When.Format(time.DateTime), ewt.Err.Error())
}</span>

func (ewt StreamError) Unwrap() error <span class="cov10" title="2">{
        return ewt.Err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "slices"
        "sort"
        "sync"

        "github.com/google/certificate-transparency-go/loglist3"
)

func (cs *CertStream) ensureOperatorAndLog(ctx context.Context, op *loglist3.Operator, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov6" title="31">{
        opDom := OperatorDomain(log.URL)

        cs.mu.Lock()
        logop := cs.operators[opDom]
        cs.mu.Unlock()

        if logop == nil </span><span class="cov4" title="6">{
                logop = &amp;LogOperator{
                        CertStream: cs,
                        Operator:   op,
                        Domain:     opDom,
                        streams:    make(map[string]*LogStream),
                }
                sort.Strings(op.Email)
                if err = cs.DB.ensureOperator(ctx, logop); err == nil </span><span class="cov4" title="6">{
                        cs.mu.Lock()
                        cs.operators[opDom] = logop
                        cs.mu.Unlock()
                }</span>
        }

        <span class="cov6" title="31">if err == nil </span><span class="cov6" title="31">{
                err = logop.ensureStream(ctx, log, wg)
        }</span>

        <span class="cov6" title="31">return</span>
}

func (cs *CertStream) updateStreams(ctx context.Context, wg *sync.WaitGroup) (err error) <span class="cov1" title="1">{
        var logList *loglist3.LogList
        if logList, err = GetLogList(ctx, cs.HeadClient, loglist3.AllLogListURL); err == nil </span><span class="cov1" title="1">{
                for _, op := range logList.Operators </span><span class="cov6" title="24">{
                        for _, log := range op.Logs </span><span class="cov10" title="186">{
                                if log.State.LogStatus() == loglist3.UsableLogStatus </span><span class="cov6" title="31">{
                                        if e := cs.ensureOperatorAndLog(ctx, op, log, wg); e != nil </span><span class="cov0" title="0">{
                                                err = errors.Join(err, e)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov1" title="1">var operators []string
        for _, lo := range cs.Operators() </span><span class="cov4" title="6">{
                operators = append(operators, fmt.Sprintf("%s*%d", lo.Domain, len(lo.Streams())))
        }</span>
        <span class="cov1" title="1">slices.Sort(operators)
        cs.LogInfo("active", "streams", operators)
        return</span>
}

func (cs *CertStream) removeStream(ls *LogStream) <span class="cov6" title="31">{
        lo := ls.LogOperator
        lo.mu.Lock()
        delete(lo.streams, ls.URL)
        empty := len(lo.streams) == 0
        lo.mu.Unlock()
        if empty </span><span class="cov4" title="6">{
                cs.mu.Lock()
                delete(cs.operators, lo.Domain)
                cs.mu.Unlock()
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package certstream

type wrappedErr struct {
        err error
        msg string
}

func (we wrappedErr) Error() string <span class="cov0" title="0">{
        return we.msg + ": " + we.err.Error()
}</span>

func (we wrappedErr) Unwrap() error <span class="cov0" title="0">{
        return we.err
}</span>

func wrapErr(err error, msg string) error <span class="cov10" title="39">{
        if err == nil </span><span class="cov9" title="37">{
                return nil
        }</span>
        <span class="cov2" title="2">return wrappedErr{err: err, msg: msg}</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
