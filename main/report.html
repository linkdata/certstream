
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>certstream: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/certstream/atomic_minmax.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/certstream/certificate.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/certstream/certstream.go (77.3%)</option>
				
				<option value="file3">github.com/linkdata/certstream/config.go (100.0%)</option>
				
				<option value="file4">github.com/linkdata/certstream/errlogidle.go (0.0%)</option>
				
				<option value="file5">github.com/linkdata/certstream/getloglist.go (100.0%)</option>
				
				<option value="file6">github.com/linkdata/certstream/httpcallcounter.go (76.5%)</option>
				
				<option value="file7">github.com/linkdata/certstream/jsoncertificate.go (63.0%)</option>
				
				<option value="file8">github.com/linkdata/certstream/jsonidentity.go (91.7%)</option>
				
				<option value="file9">github.com/linkdata/certstream/logentry.go (80.5%)</option>
				
				<option value="file10">github.com/linkdata/certstream/logoperator.go (72.0%)</option>
				
				<option value="file11">github.com/linkdata/certstream/logstream.go (76.3%)</option>
				
				<option value="file12">github.com/linkdata/certstream/logstream_backoff.go (82.1%)</option>
				
				<option value="file13">github.com/linkdata/certstream/logstream_rawentries.go (97.3%)</option>
				
				<option value="file14">github.com/linkdata/certstream/logstream_tileentries.go (73.7%)</option>
				
				<option value="file15">github.com/linkdata/certstream/operatordomain.go (100.0%)</option>
				
				<option value="file16">github.com/linkdata/certstream/pgbackfill.go (74.7%)</option>
				
				<option value="file17">github.com/linkdata/certstream/pgbatcher.go (89.9%)</option>
				
				<option value="file18">github.com/linkdata/certstream/pgcertificate.go (100.0%)</option>
				
				<option value="file19">github.com/linkdata/certstream/pgdb.go (81.1%)</option>
				
				<option value="file20">github.com/linkdata/certstream/pgdnsname.go (0.0%)</option>
				
				<option value="file21">github.com/linkdata/certstream/pgdnsnamesview.go (0.0%)</option>
				
				<option value="file22">github.com/linkdata/certstream/pgident.go (100.0%)</option>
				
				<option value="file23">github.com/linkdata/certstream/pglogentry.go (0.0%)</option>
				
				<option value="file24">github.com/linkdata/certstream/requestlog.go (81.0%)</option>
				
				<option value="file25">github.com/linkdata/certstream/streamerror.go (100.0%)</option>
				
				<option value="file26">github.com/linkdata/certstream/sunlight_cache.go (92.3%)</option>
				
				<option value="file27">github.com/linkdata/certstream/sunlight_client.go (100.0%)</option>
				
				<option value="file28">github.com/linkdata/certstream/toggled_logger.go (77.8%)</option>
				
				<option value="file29">github.com/linkdata/certstream/updatestreams.go (95.9%)</option>
				
				<option value="file30">github.com/linkdata/certstream/wraperr.go (40.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package certstream

type atomicInt64 interface {
        Load() int64
        CompareAndSwap(old, new int64) bool
}

func updateAtomicMin(a atomicInt64, candidate int64) <span class="cov9" title="1529">{
        for </span><span class="cov10" title="1530">{
                current := a.Load()
                if current == -1 || current &gt; candidate </span><span class="cov5" title="54">{
                        if !a.CompareAndSwap(current, candidate) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                }
                <span class="cov9" title="1529">break</span>
        }
}

func updateAtomicMax(a atomicInt64, candidate int64) <span class="cov9" title="1529">{
        for </span><span class="cov10" title="1530">{
                current := a.Load()
                if current == -1 || current &lt; candidate </span><span class="cov7" title="219">{
                        if !a.CompareAndSwap(current, candidate) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                }
                <span class="cov9" title="1529">break</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package certstream

import (
        "slices"
        "time"

        "github.com/google/certificate-transparency-go/x509"
)

type Certificate struct {
        PreCert   bool
        Seen      time.Time
        Signature []byte
        *x509.Certificate
}

func (c *Certificate) GetCommonName() (s string) <span class="cov10" title="735">{
        if s = c.Subject.CommonName; s == "" </span><span class="cov6" title="62">{
                if len(c.DNSNames) &gt; 0 </span><span class="cov6" title="59">{
                        names := slices.Clone(c.DNSNames)
                        slices.Sort(names)
                        s = c.DNSNames[0]
                }</span>
        }
        <span class="cov10" title="735">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package certstream

import (
        "context"
        "errors"
        "net/http"
        "os"
        "slices"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/linkdata/bwlimit"
)

type CertStream struct {
        Config                       // copy of config
        C           &lt;-chan *LogEntry // log entry channel
        HeadClient  *http.Client     // main HTTP client, uses Config.HeadDialer
        TailClient  *http.Client     // may be nil if not backfilling
        LogToggle   atomic.Bool      // if true, log stream activity
        tailLimiter *bwlimit.Limiter // master tail limiter, if known
        subLimiter  *bwlimit.Limiter // sub tail limiter
        headLogFile *os.File         // head HTTP request log
        tailLogFile *os.File         // tail HTTP request log
        mu          sync.Mutex       // protects following
        db          *PgDB
        sendEntryCh chan *LogEntry
        operators   map[string]*LogOperator // operators by operator domain, valid after Start()
}

var DefaultTransport = &amp;http.Transport{
        TLSHandshakeTimeout:   30 * time.Second,
        ResponseHeaderTimeout: 30 * time.Second,
        MaxIdleConnsPerHost:   2,
        DisableKeepAlives:     false,
        ExpectContinueTimeout: 10 * time.Second,
        ForceAttemptHTTP2:     true,
}

func (cs *CertStream) LogInfo(msg string, args ...any) <span class="cov6" title="63">{
        if cs.Config.Logger != nil </span><span class="cov3" title="6">{
                cs.Config.Logger.Info("certstream: "+msg, args...)
        }</span>
}

func (cs *CertStream) LogError(err error, msg string, args ...any) error <span class="cov9" title="427">{
        if err != nil &amp;&amp; cs.Config.Logger != nil </span><span class="cov6" title="78">{
                if !errors.Is(err, context.Canceled) &amp;&amp; !errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        if unwrapper, ok := err.(interface{ Unwrap() []error }); ok </span><span class="cov0" title="0">{
                                for _, e := range unwrapper.Unwrap() </span><span class="cov0" title="0">{
                                        cs.Config.Logger.Error("certstream: "+msg, append(args, "err", e)...)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cs.Config.Logger.Error("certstream: "+msg, append(args, "err", err)...)
                        }</span>
                }
        }
        <span class="cov9" title="427">return err</span>
}

func (cs *CertStream) Operators() (operators []*LogOperator) <span class="cov2" title="4">{
        cs.mu.Lock()
        for _, logop := range cs.operators </span><span class="cov3" title="8">{
                operators = append(operators, logop)
        }</span>
        <span class="cov2" title="4">cs.mu.Unlock()
        slices.SortFunc(operators, func(a, b *LogOperator) int </span><span class="cov5" title="23">{ return strings.Compare(a.operator.Name, b.operator.Name) }</span>)
        <span class="cov2" title="4">return</span>
}

func (cs *CertStream) CountStreams() (n int) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, logop := range cs.operators </span><span class="cov0" title="0">{
                logop.mu.Lock()
                n += len(logop.streams)
                logop.mu.Unlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cs *CertStream) GetLogStreamByID(id int32) (ls *LogStream) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, logop := range cs.operators </span><span class="cov0" title="0">{
                if ls = logop.GetStreamByID(id); ls != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (cs *CertStream) getSendEntryCh() (ch chan *LogEntry) <span class="cov7" title="105">{
        cs.mu.Lock()
        ch = cs.sendEntryCh
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) getTailLogFile() (f *os.File) <span class="cov1" title="2">{
        cs.mu.Lock()
        f = cs.tailLogFile
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) getHeadLogFile() (f *os.File) <span class="cov1" title="2">{
        cs.mu.Lock()
        f = cs.headLogFile
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) DB() (db *PgDB) <span class="cov10" title="835">{
        cs.mu.Lock()
        db = cs.db
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) close() <span class="cov2" title="4">{
        cs.mu.Lock()
        seCh := cs.sendEntryCh
        cs.sendEntryCh = nil
        db := cs.db
        cs.db = nil
        headLog := cs.headLogFile
        cs.headLogFile = nil
        tailLog := cs.tailLogFile
        cs.tailLogFile = nil
        cs.mu.Unlock()
        if seCh != nil </span><span class="cov2" title="4">{
                // drain
                ok := true
                for ok </span><span class="cov3" title="9">{
                        select </span>{
                        case _, ok = &lt;-seCh:<span class="cov3" title="5"></span>
                        default:<span class="cov2" title="4">
                                ok = false</span>
                        }
                }
                <span class="cov2" title="4">close(seCh)</span>
        }
        <span class="cov2" title="4">if db != nil </span><span class="cov1" title="1">{
                db.Close()
        }</span>
        <span class="cov2" title="4">if headLog != nil </span><span class="cov1" title="1">{
                _ = headLog.Close()
        }</span>
        <span class="cov2" title="4">if tailLog != nil </span><span class="cov1" title="1">{
                _ = tailLog.Close()
        }</span>
}

func (cs *CertStream) run(ctx context.Context, pwg *sync.WaitGroup) <span class="cov2" title="4">{
        var streamWG sync.WaitGroup
        var dbWG sync.WaitGroup
        ticker := time.NewTicker(time.Hour * 24)

        defer func() </span><span class="cov2" title="4">{
                ticker.Stop()
                streamWG.Wait()
                dbWG.Wait()
                cs.close()
                pwg.Done()
        }</span>()

        <span class="cov2" title="4">streamWG.Add(1)
        _ = cs.LogError(cs.updateStreams(ctx, &amp;streamWG), "CertStream:run@1")

        if db := cs.DB(); db != nil </span><span class="cov1" title="1">{
                dbWG.Add(3)
                go db.runWorkers(ctx, &amp;dbWG)
                go db.estimator(ctx, &amp;dbWG)
                go db.selectAllGaps(ctx, &amp;dbWG)
        }</span>

        <span class="cov2" title="4">for </span><span class="cov2" title="4">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov2" title="4">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        streamWG.Add(1)
                        _ = cs.LogError(cs.updateStreams(ctx, &amp;streamWG), "CertStream:run@2")</span>
                }
        }
}

func Start(ctx context.Context, wg *sync.WaitGroup, cfg *Config) (cs *CertStream, err error) <span class="cov2" title="4">{
        tailDialer := cfg.TailDialer
        if tailDialer == nil </span><span class="cov0" title="0">{
                tailDialer = cfg.HeadDialer
        }</span>
        <span class="cov2" title="4">subLimiter := bwlimit.NewLimiter()
        var tailLimiter *bwlimit.Limiter
        if bwdialer, ok := tailDialer.(*bwlimit.Dialer); ok </span><span class="cov1" title="1">{
                tailLimiter = bwdialer.Limiter
                subLimiter.Reads.Limit.Store(tailLimiter.Reads.Limit.Load())
        }</span>
        <span class="cov2" title="4">tailDialer = subLimiter.Wrap(tailDialer)

        tphead := DefaultTransport.Clone()
        tphead.DialContext = cfg.HeadDialer.DialContext
        headTransport := http.RoundTripper(tphead)
        var headLogFile *os.File
        if cfg.HeadLog != "" </span><span class="cov1" title="1">{
                headLogFile, err = os.OpenFile(cfg.HeadLog, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)
                if err == nil </span><span class="cov1" title="1">{
                        headTransport = newHeadLogTransport(tphead, headLogFile)
                }</span> else<span class="cov0" title="0"> {
                        err = errHeadLogOpen{err: err}
                }</span>
        }
        <span class="cov2" title="4">tptail := DefaultTransport.Clone()
        tptail.DialContext = tailDialer.DialContext
        tailTransport := http.RoundTripper(tptail)
        var tailLogFile *os.File
        if err == nil </span><span class="cov2" title="4">{
                if cfg.TailLog != "" </span><span class="cov1" title="1">{
                        tailLogFile, err = os.OpenFile(cfg.TailLog, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)
                        if err == nil </span><span class="cov1" title="1">{
                                tailTransport = newTailLogTransport(tptail, tailLogFile)
                        }</span> else<span class="cov0" title="0"> {
                                err = errTailLogOpen{err: err}
                        }</span>
                }
        }

        <span class="cov2" title="4">if cfg.DataDir != "" </span><span class="cov2" title="4">{
                cfg.DataDir = strings.TrimSpace(os.ExpandEnv(cfg.DataDir))
        }</span>

        <span class="cov2" title="4">if err == nil &amp;&amp; cfg.DataDir != "" </span><span class="cov2" title="4">{
                if cfg.CacheMaxAge &gt; 0 </span><span class="cov2" title="4">{
                        err = os.MkdirAll(getCacheDir(cfg.DataDir, ""), 0o755)
                }</span>
        }

        <span class="cov2" title="4">if err == nil </span><span class="cov2" title="4">{
                cs = &amp;CertStream{
                        Config: *cfg,
                        HeadClient: &amp;http.Client{
                                Timeout:   10 * time.Second,
                                Transport: httpCallCounter{headTransport},
                        },
                        TailClient: &amp;http.Client{
                                Timeout:   10 * time.Second,
                                Transport: httpCallCounter{tailTransport},
                        },
                        tailLimiter: tailLimiter,
                        subLimiter:  subLimiter,
                        headLogFile: headLogFile,
                        tailLogFile: tailLogFile,
                        operators:   map[string]*LogOperator{},
                }

                var db *PgDB
                if db, err = NewPgDB(ctx, cs); err == nil </span><span class="cov2" title="4">{
                        cs.mu.Lock()
                        cs.db = db
                        cs.sendEntryCh = make(chan *LogEntry, 1024*8)
                        cs.C = cs.sendEntryCh
                        cs.mu.Unlock()
                        if cs.Config.DataDir != "" &amp;&amp; cs.Config.CacheMaxAge &gt; 0 </span><span class="cov2" title="4">{
                                wg.Add(1)
                                go cs.runCachePruner(ctx, wg, getCacheDir(cs.Config.DataDir, ""), cs.Config.CacheMaxAge)
                        }</span>
                        <span class="cov2" title="4">wg.Add(1)
                        go cs.run(ctx, wg)</span>
                }
        }
        <span class="cov2" title="4">if err != nil &amp;&amp; tailLogFile != nil </span><span class="cov0" title="0">{
                _ = tailLogFile.Close()
                if cs != nil </span><span class="cov0" title="0">{
                        cs.mu.Lock()
                        if cs.tailLogFile == tailLogFile </span><span class="cov0" title="0">{
                                cs.tailLogFile = nil
                        }</span>
                        <span class="cov0" title="0">cs.mu.Unlock()</span>
                }
        }
        <span class="cov2" title="4">if err != nil &amp;&amp; headLogFile != nil </span><span class="cov0" title="0">{
                _ = headLogFile.Close()
                if cs != nil </span><span class="cov0" title="0">{
                        cs.mu.Lock()
                        if cs.headLogFile == headLogFile </span><span class="cov0" title="0">{
                                cs.headLogFile = nil
                        }</span>
                        <span class="cov0" title="0">cs.mu.Unlock()</span>
                }
        }

        <span class="cov2" title="4">return</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package certstream

import (
        "net"
        "os"
        "path"
        "time"

        "golang.org/x/net/proxy"
)

type Config struct {
        Logger       Logger              // if not nil Logger to use, no default
        HeadDialer   proxy.ContextDialer // dialer for following the head, defaults to &amp;net.Dialer{}
        HeadLog      string              // log HTTP requests using the head dialer to this file
        TailDialer   proxy.ContextDialer // if not nil, backfill db using this dialer, no default
        PgUser       string              // PostgreSQL user, default "certstream"
        PgPass       string              // PostgreSQL password, default "certstream"
        PgName       string              // PostgreSQL db name, default "certstream"
        PgAddr       string              // PostgreSQL address, no default
        PgPrefix     string              // PostgreSQL naming prefix, default "certdb_"
        PgConns      int                 // max number of database connections, default 100
        PgWorkerBits int                 // number of prefix bits that determine DB workers, default 5 (32 workers)
        PgMaxAge     int                 // maximum age in days to backfill
        PgNoSSL      bool                // if true, do not use SSL
        PgSyncCommit bool                // if true, do not set synchronous_commit=off
        Concurrency  int                 // number of concurrent requests per stream, default is 4
        DataDir      string              // log and cache directory; leave empty to disable
        CacheMaxAge  time.Duration       // remove cached tile data older than this age; zero disables caching of tiles
        TailLog      string              // log HTTP requests using the tail dialer to this file
}

// NewConfig returns a new default Config
func NewConfig() *Config <span class="cov10" title="20">{
        return &amp;Config{
                Logger:       nil,
                HeadDialer:   &amp;net.Dialer{},
                TailDialer:   nil,
                PgUser:       "certstream",
                PgPass:       "certstream",
                PgName:       "certstream",
                PgAddr:       "",
                PgPrefix:     "certdb_",
                PgConns:      100,
                PgWorkerBits: 5,
                PgMaxAge:     90,
                Concurrency:  4,
                DataDir:      path.Join(os.TempDir(), "certstream"),
                CacheMaxAge:  time.Minute * 10,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type errLogIdle struct {
        Since time.Time
}

func (err errLogIdle) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("log idle since %v", err.Since.Round(time.Second))
}</span>

var ErrLogIdle errLogIdle
</pre>
		
		<pre class="file" id="file5" style="display: none">package certstream

import (
        "context"
        "io"
        "net/http"

        "github.com/google/certificate-transparency-go/loglist3"
)

// getLogList fetches a CT log list from the given listUrl.
// Usually you would pass loglist3.AllLogListURL for the listUrl.
func getLogList(ctx context.Context, httpClient *http.Client, listUrl string) (logList *loglist3.LogList, err error) <span class="cov10" title="5">{
        var req *http.Request
        if req, err = http.NewRequestWithContext(ctx, http.MethodGet, listUrl, nil); err == nil </span><span class="cov10" title="5">{
                var resp *http.Response
                if resp, err = httpClient.Do(req); err == nil </span><span class="cov4" title="2">{
                        var b []byte
                        if b, err = io.ReadAll(resp.Body); err == nil </span><span class="cov4" title="2">{
                                logList, err = loglist3.NewFromJSON(b)
                        }</span>
                }
        }
        <span class="cov10" title="5">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package certstream

import (
        "maps"
        "net/http"
        "strings"
        "sync"
)

var httpCallsMu sync.Mutex
var httpCallsMap map[string]int64 = map[string]int64{}

type httpCallCounter struct {
        next http.RoundTripper
}

func (sct httpCallCounter) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="361">{
        mapkey := req.URL.Scheme + "://" + req.URL.Host + req.URL.Path
        for _, cutoff := range []string{"/ct/", "/tile/", "/checkpoint"} </span><span class="cov10" title="673">{
                if idx := strings.Index(mapkey, cutoff); idx != -1 </span><span class="cov9" title="361">{
                        mapkey = mapkey[:idx+1]
                        break</span>
                }
        }
        <span class="cov9" title="361">httpCallsMu.Lock()
        httpCallsMap[mapkey]++
        httpCallsMu.Unlock()
        return sct.next.RoundTrip(req)</span>
}

func GetHTTPCallsMap() (m map[string]int64) <span class="cov1" title="1">{
        httpCallsMu.Lock()
        m = maps.Clone(httpCallsMap)
        httpCallsMu.Unlock()
        return
}</span>

func GetHTTPCalls(s string) (n int64) <span class="cov0" title="0">{
        httpCallsMu.Lock()
        n = httpCallsMap[s]
        httpCallsMu.Unlock()
        return
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package certstream

import (
        "encoding/hex"
        "net/mail"
        "slices"
        "sort"
        "strings"
        "time"

        "golang.org/x/net/idna"
)

type hexEncoded []byte

func (h hexEncoded) MarshalText() (text []byte, err error) <span class="cov0" title="0">{
        return hex.AppendEncode(nil, h), nil
}</span>

type JsonCertificate struct {
        PreCert        bool         `json:",omitempty"`
        Signature      hexEncoded   `json:",omitempty"` // SHA256 signature, searchable on crt.sh
        Issuer         JsonIdentity `json:",omitempty"`
        Subject        JsonIdentity `json:",omitempty"`
        CommonName     string       `json:",omitempty"` // Subject common name
        DNSNames       []string     `json:",omitempty"`
        EmailAddresses []string     `json:",omitempty"`
        IPAddresses    []string     `json:",omitempty"`
        URIs           []string     `json:",omitempty"`
        NotBefore      time.Time    `json:",omitempty"`
        NotAfter       time.Time    `json:",omitempty"`
        Since          time.Time    `json:",omitzero"`
}

func NewJSONCertificate(cert *Certificate) (jsoncert *JsonCertificate) <span class="cov7" title="3">{
        jsoncert = &amp;JsonCertificate{
                PreCert:    cert.PreCert,
                Signature:  cert.Signature,
                CommonName: cert.GetCommonName(),
                NotBefore:  cert.NotBefore,
                NotAfter:   cert.NotAfter,
        }
        jsoncert.Issuer.fill(&amp;cert.Issuer)
        jsoncert.Subject.fill(&amp;cert.Subject)

        for _, dnsname := range cert.DNSNames </span><span class="cov4" title="2">{
                dnsname = strings.ToLower(dnsname)
                if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov0" title="0">{
                        jsoncert.DNSNames = append(jsoncert.DNSNames, uniname)
                }</span> else<span class="cov4" title="2"> {
                        jsoncert.DNSNames = append(jsoncert.DNSNames, dnsname)
                }</span>
        }
        <span class="cov7" title="3">sort.Strings(jsoncert.DNSNames)

        for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                jsoncert.IPAddresses = append(jsoncert.IPAddresses, ip.String())
        }</span>
        <span class="cov7" title="3">sort.Strings(jsoncert.IPAddresses)

        for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                if m, e := mail.ParseAddress(email); e == nil </span><span class="cov0" title="0">{
                        email = m.Address
                }</span>
                <span class="cov0" title="0">jsoncert.EmailAddresses = append(jsoncert.EmailAddresses, email)</span>
        }
        <span class="cov7" title="3">sort.Strings(jsoncert.EmailAddresses)

        for _, u := range cert.URIs </span><span class="cov0" title="0">{
                jsoncert.URIs = append(jsoncert.URIs, u.String())
        }</span>
        <span class="cov7" title="3">sort.Strings(jsoncert.URIs)
        return</span>
}

func (js *JsonCertificate) SetCommonName() <span class="cov10" title="5">{
        if js.CommonName == "" </span><span class="cov1" title="1">{
                if len(js.DNSNames) &gt; 0 </span><span class="cov0" title="0">{
                        names := slices.Clone(js.DNSNames)
                        slices.Sort(names)
                        js.CommonName = js.DNSNames[0]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package certstream

import (
        "strings"

        "github.com/google/certificate-transparency-go/x509/pkix"
)

type JsonIdentity struct {
        ID           int    `json:",omitempty"`
        Country      string `json:",omitempty"`
        Organization string `json:",omitempty"`
        Province     string `json:",omitempty"`
        CommonName   string `json:",omitempty"`
}

func join(l []string) string <span class="cov10" title="21">{
        var b []byte
        for _, s := range l </span><span class="cov4" title="3">{
                if s = strings.TrimSpace(s); s != "" </span><span class="cov4" title="3">{
                        if len(b) &gt; 0 </span><span class="cov0" title="0">{
                                b = append(b, ' ')
                        }</span>
                        <span class="cov4" title="3">b = append(b, s...)</span>
                }
        }
        <span class="cov10" title="21">return string(b)</span>
}

func (id *JsonIdentity) fill(name *pkix.Name) <span class="cov6" title="7">{
        if name != nil </span><span class="cov6" title="7">{
                id.Country = join(name.Country)
                id.Organization = join(name.Organization)
                id.Province = join(name.Province)
                id.CommonName = strings.TrimSpace(name.CommonName)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package certstream

import (
        "encoding/hex"
        "strconv"
        "strings"
        "time"

        "github.com/google/certificate-transparency-go/x509"
        "golang.org/x/net/idna"
)

type LogEntry struct {
        *LogStream
        Err         error // error from RawLogEntryFromLeaf or ToLogEntry, or nil
        LogIndex    int64
        PreCert     bool
        Certificate *x509.Certificate
        Id          int64 // database id, if available
        Historical  bool  // true if the entry is from gap or backfilling
        Signature   []byte
        Seen        time.Time
}

func (le *LogEntry) appendJSON(b []byte) []byte <span class="cov8" title="729">{
        if cert := le.Cert(); cert != nil </span><span class="cov8" title="729">{
                logindex := le.Index()
                var dnsnames []string
                for _, dnsname := range cert.DNSNames </span><span class="cov9" title="1294">{
                        dnsname = strings.ToLower(dnsname)
                        if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov0" title="0">{
                                ok := true
                                for _, r := range uniname </span><span class="cov0" title="0">{
                                        ok = ok &amp;&amp; strconv.IsPrint(r)
                                }</span>
                                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                        dnsname = uniname
                                }</span>
                        }
                        <span class="cov9" title="1294">dnsnames = append(dnsnames, dnsname)</span>
                }

                <span class="cov8" title="729">var ipaddrs []string
                for _, ip := range cert.IPAddresses </span><span class="cov1" title="1">{
                        ipaddrs = append(ipaddrs, ip.String())
                }</span>

                <span class="cov8" title="729">var emails []string
                for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                        emails = append(emails, strings.ReplaceAll(email, " ", "_"))
                }</span>

                <span class="cov8" title="729">var uris []string
                for _, uri := range cert.URIs </span><span class="cov0" title="0">{
                        uris = append(uris, strings.ReplaceAll(uri.String(), " ", "%20"))
                }</span>

                <span class="cov8" title="729">b = append(b, `{`...)
                b = append(b, `"iss_org":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Organization, ","))
                b = append(b, `,"iss_prov":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Province, ","))
                b = append(b, `,"iss_country":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Country, ","))
                b = append(b, `,"sub_org":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Organization, ","))
                b = append(b, `,"sub_prov":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Province, ","))
                b = append(b, `,"sub_country":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Country, ","))
                b = append(b, `,"notbefore":"`...)
                b = append(b, cert.NotBefore.UTC().Format(time.RFC3339)...)
                b = append(b, `","notafter":"`...)
                b = append(b, cert.NotAfter.UTC().Format(time.RFC3339)...)
                b = append(b, `","commonname":`...)
                b = strconv.AppendQuote(b, cert.GetCommonName())
                b = append(b, `,"sha256_hex":"`...)
                b = append(b, hex.EncodeToString(cert.Signature)...)
                b = append(b, `","precert":`...)
                b = strconv.AppendBool(b, cert.PreCert)
                b = append(b, `,"seen":"`...)
                b = append(b, cert.Seen.UTC().Format(time.RFC3339)...)
                b = append(b, `","stream":`...)
                b = strconv.AppendInt(b, int64(le.LogStream.Id), 10)
                b = append(b, `,"logindex":`...)
                b = strconv.AppendInt(b, logindex, 10)
                b = append(b, `,"dnsnames":`...)
                b = strconv.AppendQuote(b, strings.Join(dnsnames, " "))
                b = append(b, `,"ipaddrs":`...)
                b = strconv.AppendQuote(b, strings.Join(ipaddrs, " "))
                b = append(b, `,"emails":`...)
                b = strconv.AppendQuote(b, strings.Join(emails, " "))
                b = append(b, `,"uris":`...)
                b = strconv.AppendQuote(b, strings.Join(uris, " "))
                b = append(b, `}`...)</span>
        } else<span class="cov0" title="0"> {
                b = append(b, `{}`...)
        }</span>
        <span class="cov8" title="729">return b</span>
}

func (le *LogEntry) String() (s string) <span class="cov1" title="1">{
        var b []byte
        b = append(b, "LogEntry{"...)
        if le != nil </span><span class="cov1" title="1">{
                if le.LogStream != nil </span><span class="cov0" title="0">{
                        if le.operator != nil </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, le.operator.Name)
                                b = append(b, ", "...)
                        }</span>
                        <span class="cov0" title="0">if url := le.URL(); url != "" </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, url)
                                b = append(b, ", "...)
                        }</span>
                }
                <span class="cov1" title="1">b = strconv.AppendInt(b, le.Index(), 10)
                if le.Err != nil </span><span class="cov0" title="0">{
                        b = append(b, ", "...)
                        b = strconv.AppendQuote(b, le.Err.Error())
                }</span>
        }
        <span class="cov1" title="1">b = append(b, '}')
        return string(b)</span>
}

// Cert returns the Certificate given a LogEntry or nil.
func (le *LogEntry) Cert() (crt *Certificate) <span class="cov10" title="2336">{
        if le != nil &amp;&amp; le.Certificate != nil </span><span class="cov9" title="2334">{
                crt = &amp;Certificate{
                        PreCert:     le.PreCert,
                        Certificate: le.Certificate,
                        Signature:   le.Signature,
                        Seen:        le.Seen,
                }
                if le.Seen.IsZero() </span><span class="cov0" title="0">{
                        crt.Seen = time.Now().UTC()
                }</span>
        }
        <span class="cov10" title="2336">return</span>
}

// Index returns the log index or -1 if none is available.
func (le *LogEntry) Index() (index int64) <span class="cov8" title="732">{
        index = -1
        if le != nil </span><span class="cov8" title="732">{
                if le.LogIndex != 0 || le.Certificate != nil || le.PreCert || le.Err != nil </span><span class="cov8" title="731">{
                        index = le.LogIndex
                }</span>
        }
        <span class="cov8" title="732">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package certstream

import (
        "context"
        "maps"
        "net/http"
        "path"
        "slices"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
)

type LogOperator struct {
        *CertStream
        Domain    string             // e.g. "letsencrypt.org" or "googleapis.com"
        Count     atomic.Int64       // atomic; sum of the stream's Count
        Status429 atomic.Int64       // atomic; number of 429 Too Many Requests
        Id        int32              // database ID, if available
        operator  *loglist3.Operator // read-only
        mu        sync.Mutex         // protects following
        statuses  map[int]int        // HTTP status code counter
        streams   map[string]*LogStream
        errcount  int
        errors    []*StreamError
}

func (lo *LogOperator) Name() string <span class="cov0" title="0">{
        return lo.operator.Name
}</span>

func (lo *LogOperator) Email() []string <span class="cov0" title="0">{
        return lo.operator.Email
}</span>

func (lo *LogOperator) StreamCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = len(lo.streams)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) ErrorCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = lo.errcount
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) addStatus(statuscode int) <span class="cov3" title="3">{
        if statuscode &gt; http.StatusOK </span><span class="cov3" title="3">{
                if statuscode == http.StatusTooManyRequests </span><span class="cov2" title="2">{
                        lo.Status429.Add(1)
                }</span>
                <span class="cov3" title="3">lo.mu.Lock()
                if lo.statuses == nil </span><span class="cov2" title="2">{
                        lo.statuses = make(map[int]int)
                }</span>
                <span class="cov3" title="3">lo.statuses[statuscode]++
                lo.mu.Unlock()</span>
        }
}

func (lo *LogOperator) StatusCounts() (m map[int]int) <span class="cov0" title="0">{
        lo.mu.Lock()
        m = maps.Clone(lo.statuses)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) CallCount() (n int64) <span class="cov0" title="0">{
        lo.mu.Lock()
        for _, s := range lo.streams </span><span class="cov0" title="0">{
                n += s.backoff.Count()
        }</span>
        <span class="cov0" title="0">lo.mu.Unlock()
        return</span>
}

func (lo *LogOperator) Errors() (errs []*StreamError) <span class="cov0" title="0">{
        lo.mu.Lock()
        errs = append(errs, lo.errors...)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) addError(ls *LogStream, err error) (errcount int) <span class="cov8" title="47">{
        if err != nil </span><span class="cov8" title="47">{
                now := time.Now()
                lo.mu.Lock()
                defer lo.mu.Unlock()
                lo.errors = append(lo.errors, &amp;StreamError{LogStream: ls, When: now, Err: err})
                if len(lo.errors) &gt; MaxErrors </span><span class="cov0" title="0">{
                        lo.errors = slices.Delete(lo.errors, 0, len(lo.errors)-MaxErrors)
                }</span>
                <span class="cov8" title="47">ls.errcount++
                errcount = ls.errcount</span>
        }
        <span class="cov8" title="47">return</span>
}

func (lo *LogOperator) Streams() (sl []*LogStream) <span class="cov5" title="8">{
        lo.mu.Lock()
        for _, s := range lo.streams </span><span class="cov8" title="47">{
                sl = append(sl, s)
        }</span>
        <span class="cov5" title="8">lo.mu.Unlock()
        slices.SortFunc(sl, func(a, b *LogStream) int </span><span class="cov10" title="88">{ return strings.Compare(a.URL(), b.URL()) }</span>)
        <span class="cov5" title="8">return</span>
}

func (lo *LogOperator) GetStreamByID(id int32) (ls *LogStream) <span class="cov0" title="0">{
        lo.mu.Lock()
        for _, ls = range lo.streams </span><span class="cov0" title="0">{
                if ls.Id == id </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">lo.mu.Unlock()
        return</span>
}

func (lo *LogOperator) makeStream(log *loglist3.Log) (ls *LogStream, err error) <span class="cov7" title="27">{
        tmpls := &amp;LogStream{
                LogOperator: lo,
                log:         log,
                backoff:     newLogStreamBackoff(time.Second, 30*time.Second, 2, true),
        }

        if lo.Config.DataDir != "" </span><span class="cov7" title="27">{
                logfile := path.Join(lo.Config.DataDir, urlToFileString(log.URL)+".log")
                tmpls.Logger = newToggledLogger(logfile, &amp;tmpls.LogToggle)
        }</span>

        <span class="cov7" title="27">if tmpls.headClient, err = client.New(log.URL, lo.HeadClient, jsonclient.Options{}); err == nil </span><span class="cov7" title="27">{
                if lo.TailClient != nil </span><span class="cov7" title="27">{
                        tmpls.tailClient, err = client.New(log.URL, lo.TailClient, jsonclient.Options{})
                }</span>
                <span class="cov7" title="27">ls = tmpls
                ls.MinIndex.Store(-1)
                ls.MaxIndex.Store(-1)
                ls.LastIndex.Store(-1)</span>
        }
        <span class="cov7" title="27">return</span>
}

func (lo *LogOperator) ensureStream(ctx context.Context, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov7" title="27">{
        lo.mu.Lock()
        ls := lo.streams[log.URL]
        lo.mu.Unlock()
        if ls == nil </span><span class="cov7" title="27">{
                if ls, err = lo.makeStream(log); err == nil </span><span class="cov7" title="27">{
                        if db := lo.DB(); db != nil </span><span class="cov7" title="27">{
                                if err = db.ensureStream(ctx, ls); err == nil </span><span class="cov7" title="27">{
                                        lo.mu.Lock()
                                        lo.streams[log.URL] = ls
                                        lo.mu.Unlock()
                                        wg.Add(1)
                                        go ls.run(ctx, wg)
                                }</span>
                        }
                }
        }
        <span class="cov7" title="27">return</span>
}

func urlToFileString(urlstr string) (s string) <span class="cov9" title="67">{
        return strings.Trim(strings.ReplaceAll(strings.TrimPrefix(urlstr, "https://"), "/", "_"), "_")
}</span>

func (lo *LogOperator) makeTiledStream(log *loglist3.TiledLog) (ls *LogStream, err error) <span class="cov7" title="21">{
        tmpls := &amp;LogStream{
                LogOperator: lo,
                tiledLog:    log,
                backoff:     newLogStreamBackoff(time.Second, 30*time.Second, 2, true),
        }

        if lo.Config.DataDir != "" </span><span class="cov7" title="20">{
                logfile := path.Join(lo.Config.DataDir, urlToFileString(log.MonitoringURL)+".log")
                tmpls.Logger = newToggledLogger(logfile, &amp;tmpls.LogToggle)
        }</span>

        <span class="cov7" title="21">cacheDir := getCacheDir(lo.Config.DataDir, log.MonitoringURL)
        if tmpls.headTile, err = newSunlightClient(log, lo.HeadClient, tmpls.Logger, lo.Config.Concurrency, cacheDir); err == nil </span><span class="cov7" title="21">{
                if lo.TailClient != nil </span><span class="cov7" title="21">{
                        tmpls.tailTile, err = newSunlightClient(log, lo.TailClient, tmpls.Logger, lo.Config.Concurrency, cacheDir)
                }</span>
                <span class="cov7" title="21">if err == nil </span><span class="cov7" title="21">{
                        ls = tmpls
                        ls.MinIndex.Store(-1)
                        ls.MaxIndex.Store(-1)
                        ls.LastIndex.Store(-1)
                }</span>
        }
        <span class="cov7" title="21">return</span>
}

func (lo *LogOperator) ensureTiledStream(ctx context.Context, log *loglist3.TiledLog, wg *sync.WaitGroup) (err error) <span class="cov7" title="20">{
        lo.mu.Lock()
        ls := lo.streams[log.MonitoringURL]
        lo.mu.Unlock()
        if ls == nil </span><span class="cov7" title="20">{
                if ls, err = lo.makeTiledStream(log); err == nil </span><span class="cov7" title="20">{
                        if db := lo.DB(); db != nil </span><span class="cov7" title="20">{
                                if err = db.ensureStream(ctx, ls); err == nil </span><span class="cov7" title="20">{
                                        lo.mu.Lock()
                                        lo.streams[log.MonitoringURL] = ls
                                        lo.mu.Unlock()
                                        wg.Add(1)
                                        go ls.run(ctx, wg)
                                }</span>
                        }
                }
        }
        <span class="cov7" title="20">return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package certstream

import (
        "bytes"
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "math/rand/v2"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "filippo.io/sunlight"
        ct "github.com/google/certificate-transparency-go"
        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
)

var DbIngestBatchSize = 1000   // number of entries to send to ingest at a time
var HistoricalBatchSize = 1000 // number of rows to SELECT when getting historical certificates
var LogBatchSize = int64(1024)
var MaxErrors = 100
var IdleCloseTime = time.Hour * 24 * 7

type handleLogEntryFn func(ctx context.Context, now time.Time, entry *LogEntry) (wanted bool)

type rawEntriesClient interface {
        GetRawEntries(ctx context.Context, start, end int64) (*ct.GetEntriesResponse, error)
}

type LogStream struct {
        *LogOperator
        Count      atomic.Int64 // number of certificates sent to the channel
        MinIndex   atomic.Int64 // atomic: lowest index seen so far, -1 if none seen yet
        MaxIndex   atomic.Int64 // atomic: highest index seen so far, -1 if none seen yet
        LastIndex  atomic.Int64 // atomic: highest index that is available from stream source
        Backfill   atomic.Int64 // atomic: number of remaining entries to backfill until we reach head
        Logger     *slog.Logger // toggled by LogToggle
        Id         int32        // database ID, if available
        gapCh      chan gap     // protected by LogOperator.mu
        log        *loglist3.Log
        tiledLog   *loglist3.TiledLog
        headClient *client.LogClient
        tailClient *client.LogClient
        headTile   *sunlight.Client
        tailTile   *sunlight.Client
        backoff    *logStreamBackoff
}

func (ls *LogStream) HTTPCalls() int64 <span class="cov0" title="0">{
        return GetHTTPCalls(ls.URL())
}</span>

func (ls *LogStream) URL() string <span class="cov8" title="539">{
        if ls.log != nil </span><span class="cov8" title="326">{
                return ls.log.URL
        }</span>
        <span class="cov7" title="213">if ls.tiledLog != nil </span><span class="cov7" title="199">{
                return ls.tiledLog.MonitoringURL
        }</span>
        <span class="cov4" title="14">return ""</span>
}

func (ls *LogStream) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("LogStream{%q}", ls.URL())
}</span>

func (ls *LogStream) logInfo() any <span class="cov5" title="47">{
        if ls != nil </span><span class="cov5" title="47">{
                if ls.log != nil </span><span class="cov5" title="27">{
                        return ls.log
                }</span>
                <span class="cov4" title="20">if ls.tiledLog != nil </span><span class="cov4" title="20">{
                        return ls.tiledLog
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ls *LogStream) isTiled() bool <span class="cov7" title="162">{
        return ls != nil &amp;&amp; ls.tiledLog != nil
}</span>

func (ls *LogStream) adjustTailLimiter(historical bool) <span class="cov6" title="79">{
        if historical </span><span class="cov0" title="0">{
                if db := ls.DB(); db != nil </span><span class="cov0" title="0">{
                        if qu := db.QueueUsage(); qu &gt; 50 </span><span class="cov0" title="0">{
                                readLimit := int64(1) // 1 byte / sec
                                if ls.tailLimiter != nil </span><span class="cov0" title="0">{
                                        // set rate limit according to queue size
                                        scaleFactor := int64(50 - (qu - 50))
                                        readLimit = ls.tailLimiter.Reads.Limit.Load() * scaleFactor / 50
                                }</span>
                                <span class="cov0" title="0">ls.subLimiter.Reads.Limit.Store(readLimit)</span>
                        } else<span class="cov0" title="0"> {
                                ls.subLimiter.Reads.Limit.Store(0)
                        }</span>
                }
        }
}

func (ls *LogStream) getGapCh() (ch chan gap) <span class="cov6" title="107">{
        ls.mu.Lock()
        ch = ls.gapCh
        ls.mu.Unlock()
        return
}</span>

func sleep(ctx context.Context, d time.Duration) (err error) <span class="cov6" title="69">{
        tmr := time.NewTimer(d)
        defer tmr.Stop()
        select </span>{
        case &lt;-tmr.C:<span class="cov4" title="23"></span>
        case &lt;-ctx.Done():<span class="cov5" title="46">
                err = ctx.Err()</span>
        }
        <span class="cov6" title="69">return</span>
}

func (ls *LogStream) getEndSeen(ctx context.Context, end int64) (seen time.Time) <span class="cov5" title="47">{
        fn := func(ctx context.Context, now time.Time, le *LogEntry) (wanted bool) </span><span class="cov5" title="47">{
                if cert := le.Cert(); cert != nil </span><span class="cov5" title="47">{
                        seen = cert.Seen
                }</span>
                <span class="cov5" title="47">return</span>
        }
        <span class="cov5" title="47">ls.getEntries(ctx, end, end, false, fn, nil)
        return</span>
}

func (ls *LogStream) run(ctx context.Context, wg *sync.WaitGroup) <span class="cov5" title="47">{
        var end int64
        var err error
        var wg2 sync.WaitGroup
        defer func() </span><span class="cov5" title="47">{
                ls.addError(ls, err)
                wg2.Wait()
                ls.removeStream(ls)
                if e, ok := err.(errLogIdle); ok </span><span class="cov0" title="0">{
                        ls.LogInfo("stream stopped", "url", ls.URL(), "stream", ls.Id, "idle-since", e.Since)
                }</span> else<span class="cov5" title="47"> {
                        _ = ls.LogError(err, "stream stopped", "url", ls.URL(), "stream", ls.Id)
                }</span>
                <span class="cov5" title="47">wg.Done()</span>
        }()

        <span class="cov5" title="47">end, err = ls.newLastIndex(ctx)
        if seen := ls.getEndSeen(ctx, end); !seen.IsZero() </span><span class="cov5" title="47">{
                if time.Since(seen) &gt; IdleCloseTime </span><span class="cov0" title="0">{
                        err = errLogIdle{Since: seen}
                        return
                }</span>
        }

        <span class="cov5" title="47">start := end
        if cdb := ls.DB(); cdb != nil </span><span class="cov5" title="47">{
                if ls.CertStream.Config.TailDialer != nil </span><span class="cov5" title="47">{
                        wg2.Add(1)
                        go cdb.backfillStream(ctx, ls, &amp;wg2)
                }</span>
        }

        <span class="cov5" title="47">for err == nil </span><span class="cov5" title="49">{
                if start &lt;= end </span><span class="cov5" title="49">{
                        startBefore := start
                        start, _ = ls.getEntries(ctx, start, end, false, ls.sendEntry, nil)
                        if end-startBefore &lt;= LogBatchSize/2 </span><span class="cov5" title="47">{
                                _ = sleep(ctx, time.Second*time.Duration(10+rand.IntN(10) /*#nosec G404*/))
                        }</span>
                }
                <span class="cov5" title="49">end, err = ls.newLastIndex(ctx)</span>
        }
}

func (ls *LogStream) newLastIndex(ctx context.Context) (lastIndex int64, err error) <span class="cov6" title="96">{
        started := time.Now()
        var newIndex int64
        lastIndex = ls.LastIndex.Load()
        for err == nil </span><span class="cov6" title="96">{
                err = ls.backoff.Retry(ctx, func() (callErr error) </span><span class="cov6" title="66">{
                        var errFrom string
                        if ls.isTiled() </span><span class="cov4" title="24">{
                                errFrom = "Checkpoint"
                                if ls.headTile != nil </span><span class="cov4" title="24">{
                                        var checkpoint sunlight.Checkpoint
                                        checkpoint, _, callErr = ls.headTile.Checkpoint(ctx)
                                        if callErr == nil </span><span class="cov4" title="24">{
                                                newIndex = checkpoint.N - 1
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        callErr = ErrSunlightClientMissing
                                }</span>
                        } else<span class="cov5" title="42"> {
                                errFrom = "GetSTH"
                                var sth *ct.SignedTreeHead
                                sth, callErr = ls.headClient.GetSTH(ctx)
                                if callErr == nil </span><span class="cov5" title="42">{
                                        newIndex = int64(sth.TreeSize) - 1 //#nosec G115
                                }</span>
                        }
                        <span class="cov6" title="66">if callErr != nil </span><span class="cov0" title="0">{
                                if ls.handleStreamError(callErr, errFrom) </span>{<span class="cov0" title="0">
                                        // keep callErr as-is
                                }</span> else<span class="cov0" title="0"> {
                                        callErr = wrapLogStreamRetryable(callErr)
                                }</span>
                        }
                        <span class="cov6" title="66">return</span>
                })
                <span class="cov6" title="96">if err == nil </span><span class="cov6" title="66">{
                        if lastIndex &lt; newIndex &amp;&amp; (lastIndex+LogBatchSize &lt; newIndex || time.Since(started) &gt; time.Minute) </span><span class="cov5" title="49">{
                                lastIndex = newIndex
                                ls.LastIndex.Store(lastIndex)
                                return
                        }</span>
                        <span class="cov4" title="17">err = sleep(ctx, time.Millisecond*time.Duration(8000+rand.IntN(4000)))</span>
                }
        }
        <span class="cov5" title="47">return</span>
}

func (ls *LogStream) seeIndex(logindex int64) <span class="cov10" title="1528">{
        if logindex &gt;= 0 </span><span class="cov10" title="1528">{
                updateAtomicMin(&amp;ls.MinIndex, logindex)
                updateAtomicMax(&amp;ls.MaxIndex, logindex)
        }</span>
}

func (ls *LogStream) makeLogEntry(logindex int64, entry ct.LeafEntry, historical bool) *LogEntry <span class="cov9" title="753">{
        ctrle, leaferr := ct.RawLogEntryFromLeaf(logindex, &amp;entry)
        var ctle *ct.LogEntry
        if leaferr == nil </span><span class="cov9" title="753">{
                ctle, leaferr = ctrle.ToLogEntry()
        }</span>
        <span class="cov9" title="753">le := &amp;LogEntry{
                LogStream:  ls,
                Err:        leaferr,
                LogIndex:   logindex,
                Historical: historical,
        }
        if ctle != nil </span><span class="cov9" title="753">{
                if ctle.X509Cert != nil </span><span class="cov7" title="290">{
                        le.Certificate = ctle.X509Cert
                }</span> else<span class="cov8" title="463"> if ctle.Precert != nil </span><span class="cov8" title="463">{
                        le.PreCert = true
                        le.Certificate = ctle.Precert.TBSCertificate
                }</span>
        }
        <span class="cov9" title="753">if ctrle != nil </span><span class="cov9" title="753">{
                if len(ctrle.Cert.Data) &gt; 0 </span><span class="cov9" title="753">{
                        shasig := sha256.Sum256(ctrle.Cert.Data)
                        le.Signature = shasig[:]
                }</span>
                <span class="cov9" title="753">if tse := ctrle.Leaf.TimestampedEntry; tse != nil </span><span class="cov9" title="753">{
                        ts := int64(tse.Timestamp) //#nosec G115
                        le.Seen = time.UnixMilli(ts).UTC()
                }</span>
        }
        <span class="cov9" title="753">if len(le.Signature) == 0 &amp;&amp; le.Certificate != nil </span><span class="cov0" title="0">{
                if raw := le.Certificate.Raw; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span> else<span class="cov0" title="0"> if raw := le.Certificate.RawTBSCertificate; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span>
        }
        <span class="cov9" title="753">return le</span>
}

func (ls *LogStream) sendEntry(ctx context.Context, now time.Time, le *LogEntry) (wanted bool) <span class="cov9" title="729">{
        if le != nil </span><span class="cov9" title="729">{
                if cert := le.Cert(); cert != nil </span><span class="cov9" title="729">{
                        ls.seeIndex(le.LogIndex)
                        wanted = now.Before(cert.NotAfter) || now.Sub(cert.Seen) &lt; time.Hour*24*time.Duration(ls.PgMaxAge)
                        if ctx.Err() == nil </span><span class="cov9" title="729">{
                                ls.Count.Add(1)
                                ls.LogOperator.Count.Add(1)
                                if db := ls.DB(); db != nil </span><span class="cov9" title="729">{
                                        db.sendToBatcher(ctx, le)
                                }</span> else<span class="cov0" title="0"> {
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                        case ls.getSendEntryCh() &lt;- le:<span class="cov0" title="0"></span>
                                        }
                                }
                        }
                } else<span class="cov0" title="0"> {
                        wanted = true
                        err := le.Err
                        if err == nil </span><span class="cov0" title="0">{
                                err = os.ErrInvalid
                        }</span>
                        <span class="cov0" title="0">ls.LogError(err, "sendEntry", "url", ls.URL(), "stream", ls.Id, "logindex", le.LogIndex)</span>
                }
        }
        <span class="cov9" title="729">return</span>
}

func (ls *LogStream) handleStreamError(err error, from string) (fatal bool) <span class="cov3" title="8">{
        errTxt := err.Error()
        if errors.Is(err, context.Canceled) || errors.Is(err, os.ErrInvalid) || errors.Is(err, io.ErrNoProgress) || strings.Contains(errTxt, "context canceled") </span><span class="cov2" title="5">{
                fatal = true
        }</span> else<span class="cov2" title="3"> if errors.Is(err, context.DeadlineExceeded) || strings.Contains(errTxt, "deadline exceeded") </span><span class="cov0" title="0">{
                fatal = false
        }</span> else<span class="cov2" title="3"> {
                statusCode := ls.statusCodeFromError(err)
                switch statusCode </span>{
                default:<span class="cov0" title="0">
                        if ls.addError(ls, wrapErr(err, from)) &gt;= MaxErrors </span><span class="cov0" title="0">{
                                fatal = true
                        }</span>
                        <span class="cov0" title="0">fallthrough</span>
                case 530:<span class="cov0" title="0"> // https://developers.cloudflare.com/support/troubleshooting/http-status-codes/cloudflare-5xx-errors/error-530/
                        fallthrough</span>
                case http.StatusTooManyRequests, http.StatusGatewayTimeout, http.StatusNotFound, http.StatusBadRequest, http.StatusConflict:<span class="cov2" title="3">
                        if ls.LogToggle.Load() &amp;&amp; ls.Logger != nil </span><span class="cov0" title="0">{
                                ls.Logger.Error(from, "url", ls.URL(), "error", err)
                        }</span>
                        <span class="cov2" title="3">ls.addStatus(statusCode)</span>
                }
        }
        <span class="cov3" title="8">return</span>
}

func (ls *LogStream) statusCodeFromError(err error) (code int) <span class="cov3" title="6">{
        if err != nil </span><span class="cov3" title="6">{
                if rspErr, isRspErr := err.(jsonclient.RspError); isRspErr </span><span class="cov2" title="3">{
                        if code = rspErr.StatusCode; code &gt;= 500 </span><span class="cov0" title="0">{
                                // https://developers.cloudflare.com/support/troubleshooting/http-status-codes/cloudflare-5xx-errors/
                                if after, found := bytes.CutPrefix(bytes.TrimSpace(rspErr.Body), []byte("error code:")); found </span><span class="cov0" title="0">{
                                        if n, err := strconv.Atoi(string(bytes.TrimSpace(after))); err == nil </span><span class="cov0" title="0">{
                                                if n &gt;= 1000 </span><span class="cov0" title="0">{
                                                        code = n
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if code &lt; 1000 </span><span class="cov0" title="0">{
                                        ls.LogInfo("code500+", "url", ls.URL(), "stream", ls.Id, "code", code, "body", string(rspErr.Body))
                                }</span>
                        }
                } else<span class="cov2" title="3"> {
                        msg := err.Error()
                        idx := strings.LastIndex(msg, "status code ")
                        if idx &gt;= 0 </span><span class="cov1" title="2">{
                                start := idx + len("status code ")
                                end := start
                                for end &lt; len(msg) </span><span class="cov3" title="6">{
                                        if msg[end] &lt; '0' || msg[end] &gt; '9' </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                        <span class="cov3" title="6">end++</span>
                                }
                                <span class="cov1" title="2">if end &gt; start </span><span class="cov1" title="2">{
                                        code, _ = strconv.Atoi(msg[start:end])
                                }</span>
                        }
                }
        }
        <span class="cov3" title="6">return</span>
}

func (ls *LogStream) getEntries(ctx context.Context, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool) <span class="cov6" title="96">{
        next = start
        if start &lt;= end </span><span class="cov6" title="96">{
                if ls.isTiled() </span><span class="cov5" title="40">{
                        next, wanted = ls.getTileEntries(ctx, start, end, historical, handleFn, gapcounter)
                }</span> else<span class="cov5" title="56"> {
                        var fn func(ctx context.Context, client rawEntriesClient, start int64, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (wanted bool, next int64, err error)
                        client := ls.headClient
                        fn = ls.getRawEntriesParallel
                        if historical </span><span class="cov0" title="0">{
                                fn = ls.getRawEntries
                                if ls.tailClient != nil </span><span class="cov0" title="0">{
                                        client = ls.tailClient
                                }</span>
                        }
                        <span class="cov5" title="56">wanted, next, _ = fn(ctx, client, start, end, historical, handleFn, gapcounter)</span>
                }
        }
        <span class="cov6" title="96">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package certstream

import (
        "context"
        "errors"
        "math/rand/v2"
        "sync"
        "time"
)

var ErrLogStreamRetryable = errors.New("logstream retryable")
var ErrSTHDiffTooLow = errors.New("STH diff too low")

type logStreamRetryableError struct {
        err error
}

func (e logStreamRetryableError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

func (e logStreamRetryableError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func (e logStreamRetryableError) Is(target error) bool <span class="cov2" title="3">{
        return target == ErrLogStreamRetryable
}</span>

func wrapLogStreamRetryable(err error) (wrapped error) <span class="cov2" title="3">{
        if err != nil </span><span class="cov2" title="3">{
                wrapped = logStreamRetryableError{err: err}
        }</span> else<span class="cov0" title="0"> {
                wrapped = ErrLogStreamRetryable
        }</span>
        <span class="cov2" title="3">return</span>
}

type logStreamBackoff struct {
        mu      sync.Mutex
        min     time.Duration
        max     time.Duration
        factor  float64
        jitter  bool
        count   int64
        current time.Duration
        next    time.Time
        nowFn   func() time.Time
        sleepFn func(context.Context, time.Duration) (err error)
}

func newLogStreamBackoff(min, max time.Duration, factor float64, jitter bool) (bo *logStreamBackoff) <span class="cov7" title="49">{
        bo = &amp;logStreamBackoff{
                min:     min,
                max:     max,
                factor:  factor,
                jitter:  jitter,
                nowFn:   time.Now,
                sleepFn: sleep,
        }
        return
}</span>

func (b *logStreamBackoff) Count() (n int64) <span class="cov0" title="0">{
        if b != nil </span><span class="cov0" title="0">{
                b.mu.Lock()
                n = b.count
                b.mu.Unlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (b *logStreamBackoff) Retry(ctx context.Context, f func() error) (err error) <span class="cov9" title="215">{
        for err == nil </span><span class="cov10" title="218">{
                if err = b.wait(ctx); err == nil </span><span class="cov9" title="186">{
                        if err = f(); err == nil </span><span class="cov9" title="178">{
                                b.success()
                                break</span>
                        }
                        <span class="cov4" title="8">if errors.Is(err, ErrLogStreamRetryable) </span><span class="cov2" title="3">{
                                b.backoff()
                                err = nil
                        }</span>
                }
        }
        <span class="cov9" title="215">return</span>
}

func (b *logStreamBackoff) wait(ctx context.Context) (err error) <span class="cov10" title="218">{
        if b != nil </span><span class="cov9" title="207">{
                if err = ctx.Err(); err == nil </span><span class="cov9" title="176">{
                        b.mu.Lock()
                        next := b.next
                        b.count++
                        b.mu.Unlock()
                        if !next.IsZero() </span><span class="cov2" title="3">{
                                delay := next.Sub(b.nowFn())
                                if delay &gt; 0 </span><span class="cov2" title="3">{
                                        if b.jitter </span><span class="cov2" title="2">{
                                                delay += time.Duration(rand.Int64N(int64(delay))) /*#nosec G404*/
                                        }</span>
                                        <span class="cov2" title="3">err = b.sleepFn(ctx, delay)</span>
                                }
                        }
                }
        }
        <span class="cov10" title="218">return</span>
}

func (b *logStreamBackoff) success() <span class="cov9" title="178">{
        if b != nil </span><span class="cov9" title="168">{
                b.mu.Lock()
                if b.factor &gt; 0 </span><span class="cov9" title="168">{
                        b.current = time.Duration(float64(b.current) / b.factor)
                        if b.current &lt; b.min </span><span class="cov9" title="168">{
                                b.current = 0
                        }</span>
                }
                <span class="cov9" title="168">if b.current &gt; 0 </span><span class="cov0" title="0">{
                        b.next = b.nowFn().Add(b.current)
                }</span> else<span class="cov9" title="168"> {
                        b.next = time.Time{}
                }</span>
                <span class="cov9" title="168">b.mu.Unlock()</span>
        }
}

func (b *logStreamBackoff) backoff() <span class="cov2" title="3">{
        if b != nil </span><span class="cov2" title="3">{
                b.mu.Lock()
                defer b.mu.Unlock()

                if b.current &gt; 0 &amp;&amp; b.factor &gt; 0 </span><span class="cov0" title="0">{
                        b.current = time.Duration(float64(b.current) * b.factor)
                }</span>
                <span class="cov2" title="3">b.current = max(b.min, b.current)
                b.current = min(b.max, b.current)
                b.next = time.Time{}
                if b.current &gt; 0 </span><span class="cov2" title="3">{
                        b.next = b.nowFn().Add(b.current)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package certstream

import (
        "context"
        "sync"
        "sync/atomic"
        "time"

        ct "github.com/google/certificate-transparency-go"
)

func rawEntriesStopIndex(start, end int64) (stop int64) <span class="cov7" title="143">{
        stop = start
        if start &lt;= end </span><span class="cov7" title="143">{
                stop = start + min(end-start+1, LogBatchSize) - 1
        }</span>
        <span class="cov7" title="143">return</span>
}

// getRawEntries fetches and processes the logentries in the index range start...end (inclusive) in order with no parallelism.
// Returns 'wanted' set to true if handleFn returned true for any logentry.
// Returns an error if not all entries could be fetched and processed.
func (ls *LogStream) getRawEntries(ctx context.Context, client rawEntriesClient, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (wanted bool, next int64, err error) <span class="cov6" title="68">{
        next = start
        for next &lt;= end &amp;&amp; err == nil </span><span class="cov6" title="76">{
                stopIndex := rawEntriesStopIndex(next, end)
                var resp *ct.GetEntriesResponse
                if err = ls.backoff.Retry(ctx, func() (e error) </span><span class="cov6" title="77">{
                        if ls.LogOperator != nil </span><span class="cov6" title="74">{
                                if sleeptime := min(500, ls.Status429.Load()*2); sleeptime &gt; 0 </span><span class="cov2" title="3">{
                                        if historical </span><span class="cov0" title="0">{
                                                sleeptime *= 2
                                        }</span>
                                        <span class="cov2" title="3">_ = sleep(ctx, time.Millisecond*time.Duration(sleeptime))</span>
                                }
                        }
                        <span class="cov6" title="77">ls.adjustTailLimiter(historical)
                        if resp, e = client.GetRawEntries(ctx, next, stopIndex); e != nil </span><span class="cov3" title="7">{
                                if !ls.handleStreamError(e, "GetRawEntries") </span><span class="cov1" title="2">{
                                        e = wrapLogStreamRetryable(e)
                                }</span>
                        }
                        <span class="cov6" title="77">return</span>
                }); err == nil <span class="cov6" title="70">{
                        now := time.Now()
                        for i := range resp.Entries </span><span class="cov10" title="753">{
                                le := ls.makeLogEntry(next, resp.Entries[i], historical)
                                if handleFn(ctx, now, le) </span><span class="cov9" title="711">{
                                        wanted = true
                                }</span>
                                <span class="cov10" title="753">ls.seeIndex(next)
                                next++
                                if gapcounter != nil </span><span class="cov4" title="11">{
                                        gapcounter.Add(-1)
                                }</span>
                        }
                } else<span class="cov3" title="6"> {
                        if ctx.Err() == nil </span><span class="cov1" title="1">{
                                _ = ls.LogError(err, "GetRawEntries", "url", ls.URL(), "start", next, "end", end)
                        }</span>
                        <span class="cov3" title="6">if gapcounter != nil </span><span class="cov1" title="1">{
                                gapcounter.Add(next - (end + 1))
                        }</span>
                }
        }
        <span class="cov6" title="68">return</span>
}

// getRawEntriesParallel fetches and processes the logentries in the index range start...end (inclusive) using Config.Concurrency workers.
// The returned next start index can be less than end+1 if an error occured.
// Returns the next start index and 'wanted' set to true if handleFn returned true for any logentry.
func (ls *LogStream) getRawEntriesParallel(ctx context.Context, client rawEntriesClient, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (wanted bool, next int64, err error) <span class="cov6" title="58">{
        type rawEntriesRange struct {
                start int64
                end   int64
        }

        err = ctx.Err()
        next = start

        sleepCtx, sleepCancel := context.WithCancel(ctx)
        workCh := make(chan rawEntriesRange)
        workerCount := min(32, max(1, ls.Concurrency))
        workerSleep := time.Second / time.Duration(workerCount)
        completed := make(map[int64]int64)
        var wg sync.WaitGroup
        var workMu sync.Mutex
        var stop atomic.Bool
        for i := range workerCount </span><span class="cov8" title="229">{
                wg.Add(1)
                go func(i int) </span><span class="cov8" title="229">{
                        defer wg.Done()
                        if i &gt; 0 &amp;&amp; ls.LogOperator != nil </span><span class="cov7" title="171">{
                                if ls.Status429.Load() &gt; 0 </span><span class="cov0" title="0">{
                                        _ = sleep(sleepCtx, workerSleep*time.Duration(i))
                                }</span>
                        }
                        <span class="cov8" title="229">for r := range workCh </span><span class="cov6" title="66">{
                                w, _, e := ls.getRawEntries(ctx, client, r.start, r.end, historical, handleFn, gapcounter)
                                workMu.Lock()
                                wanted = wanted || w
                                if e == nil </span><span class="cov6" title="61">{
                                        completed[r.start] = r.end
                                </span>advanceNext:
                                        <span class="cov7" title="121">if end, ok := completed[next]; ok </span><span class="cov6" title="60">{
                                                delete(completed, next)
                                                next = end + 1
                                                goto advanceNext</span>
                                        }
                                } else<span class="cov3" title="5"> {
                                        err = e
                                        stop.Store(true)
                                }</span>
                                <span class="cov6" title="66">workMu.Unlock()</span>
                        }
                }(i)
        }

        <span class="cov6" title="58">for start &lt;= end &amp;&amp; !stop.Load() </span><span class="cov6" title="67">{
                stopIndex := rawEntriesStopIndex(start, end)
                select </span>{
                case workCh &lt;- rawEntriesRange{start: start, end: stopIndex}:<span class="cov6" title="66">
                        start = stopIndex + 1</span>
                case &lt;-ctx.Done():<span class="cov1" title="1"></span>
                }
        }

        <span class="cov6" title="58">close(workCh)
        sleepCancel()
        wg.Wait()
        if err == nil </span><span class="cov6" title="56">{
                err = ctx.Err()
        }</span>

        <span class="cov6" title="58">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package certstream

import (
        "context"
        "crypto/sha256"
        "sync/atomic"
        "time"

        "filippo.io/sunlight"
        "github.com/google/certificate-transparency-go/x509"
)

func (ls *LogStream) makeTileLogEntry(logindex int64, entry *sunlight.LogEntry, historical bool) (le *LogEntry) <span class="cov10" title="44">{
        le = &amp;LogEntry{
                LogStream:  ls,
                LogIndex:   logindex,
                Historical: historical,
        }
        if entry != nil </span><span class="cov10" title="44">{
                le.Seen = time.UnixMilli(entry.Timestamp).UTC()
                if entry.IsPrecert </span><span class="cov8" title="26">{
                        le.PreCert = true
                }</span>
                <span class="cov10" title="44">var cert *x509.Certificate
                var certErr error
                if entry.IsPrecert </span><span class="cov8" title="26">{
                        cert, certErr = x509.ParseTBSCertificate(entry.Certificate)
                }</span> else<span class="cov7" title="18"> {
                        cert, certErr = x509.ParseCertificate(entry.Certificate)
                }</span>
                <span class="cov10" title="44">if certErr != nil </span><span class="cov0" title="0">{
                        le.Err = certErr
                }</span>
                <span class="cov10" title="44">le.Certificate = cert
                if entry.IsPrecert &amp;&amp; len(entry.PreCertificate) &gt; 0 </span><span class="cov8" title="26">{
                        shasig := sha256.Sum256(entry.PreCertificate)
                        le.Signature = shasig[:]
                }</span> else<span class="cov7" title="18"> if len(entry.Certificate) &gt; 0 </span><span class="cov7" title="18">{
                        shasig := sha256.Sum256(entry.Certificate)
                        le.Signature = shasig[:]
                }</span>
        }
        <span class="cov10" title="44">if len(le.Signature) == 0 &amp;&amp; le.Certificate != nil </span><span class="cov0" title="0">{
                if raw := le.Certificate.Raw; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span> else<span class="cov0" title="0"> if raw := le.Certificate.RawTBSCertificate; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span>
        }
        <span class="cov10" title="44">return</span>
}

func (ls *LogStream) getTileEntries(ctx context.Context, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool) <span class="cov9" title="41">{
        client := ls.headTile
        if historical &amp;&amp; ls.tailTile != nil </span><span class="cov0" title="0">{
                client = ls.tailTile
        }</span>

        <span class="cov9" title="41">next = start
        for next &lt;= end </span><span class="cov9" title="41">{
                entryErr := ls.backoff.Retry(ctx, func() (err error) </span><span class="cov9" title="41">{
                        var checkpoint sunlight.Checkpoint
                        if checkpoint, _, err = client.Checkpoint(ctx); err == nil </span><span class="cov9" title="41">{
                                for logindex, entry := range client.Entries(ctx, checkpoint.Tree, next) </span><span class="cov9" title="43">{
                                        le := ls.makeTileLogEntry(logindex, entry, historical)
                                        ls.seeIndex(logindex)
                                        if handleFn(ctx, time.Now(), le) </span><span class="cov8" title="23">{
                                                wanted = true
                                        }</span>
                                        <span class="cov9" title="43">next = logindex + 1
                                        if gapcounter != nil </span><span class="cov0" title="0">{
                                                gapcounter.Add(-1)
                                        }</span>
                                        <span class="cov9" title="43">if logindex &gt;= end </span><span class="cov9" title="41">{
                                                break</span>
                                        }
                                        <span class="cov2" title="2">ls.adjustTailLimiter(historical)</span>
                                }
                                <span class="cov9" title="41">err = client.Err()</span>
                        }
                        <span class="cov9" title="41">if err != nil </span><span class="cov0" title="0">{
                                if !ls.handleStreamError(err, "getTileEntries") </span><span class="cov0" title="0">{
                                        err = wrapLogStreamRetryable(err)
                                }</span>
                        }
                        <span class="cov9" title="41">return</span>
                })
                <span class="cov9" title="41">if entryErr != nil </span><span class="cov0" title="0">{
                        if gapcounter != nil &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                                _ = ls.LogError(entryErr, "gap not fillable", "url", ls.URL(), "start", next, "end", end)
                                gapcounter.Add(next - (end + 1))
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov9" title="41">return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package certstream

import (
        "net/url"
        "strings"
)

// OperatorDomain returns the TLD+1 given an URL.
func OperatorDomain(urlString string) string <span class="cov10" title="52">{
        opDom := urlString
        if u, err := url.Parse(urlString); err == nil </span><span class="cov10" title="52">{
                opDom = u.Hostname()
                if idx := strings.LastIndexByte(opDom, '.'); idx &gt; 0 </span><span class="cov9" title="51">{
                        if idx := strings.LastIndexByte(opDom[:idx], '.'); idx &gt; 0 </span><span class="cov9" title="49">{
                                opDom = opDom[idx+1:]
                        }</span>
                }
        }
        <span class="cov10" title="52">return opDom</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package certstream

import (
        "context"
        "database/sql"
        "errors"
        "strconv"
        "sync"
        "sync/atomic"
)

var ErrLogEntriesTooOld = errors.New("log entries are older than max age")

type errLogEntriesTooOld struct {
        MaxAge int
}

type rawEntriesFetcher func(ctx context.Context, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool)

func (e errLogEntriesTooOld) Error() string <span class="cov0" title="0">{
        return "log entries are older than " + strconv.Itoa(e.MaxAge) + " days"
}</span>

func (e errLogEntriesTooOld) Unwrap() error <span class="cov0" title="0">{
        return ErrLogEntriesTooOld
}</span>

func (cdb *PgDB) backfillGapsWithFetcher(ctx context.Context, ls *LogStream, fetchFn rawEntriesFetcher) <span class="cov9" title="50">{
        if cdb != nil &amp;&amp; ls != nil </span><span class="cov9" title="50">{
                var lastgap gap
                var nullableMaxIndex sql.NullInt64
                lastindex := ls.LastIndex.Load()
                row := cdb.QueryRow(ctx, cdb.stmtSelectMaxIdx, ls.Id)
                if err := row.Scan(&amp;nullableMaxIndex); cdb.LogError(err, "backfillGapsWithFetcher/MaxIndex", "url", ls.URL()) == nil </span><span class="cov9" title="50">{
                        if nullableMaxIndex.Valid </span><span class="cov2" title="2">{
                                ls.seeIndex(nullableMaxIndex.Int64)
                                if lastindex &lt; nullableMaxIndex.Int64 </span><span class="cov2" title="2">{
                                        lastindex = nullableMaxIndex.Int64
                                }</span>
                                <span class="cov2" title="2">if nullableMaxIndex.Int64 &lt; lastindex </span><span class="cov0" title="0">{
                                        lastgap = gap{start: nullableMaxIndex.Int64 + 1, end: lastindex}
                                }</span>
                        }
                }
                <span class="cov9" title="50">if gapCh := ls.getGapCh(); gapCh != nil </span><span class="cov9" title="50">{
                        allGapsFilled := true
                        fillGap := func(g gap) </span><span class="cov4" title="4">{
                                if ctx.Err() == nil </span><span class="cov4" title="4">{
                                        ls.Backfill.Add((g.end - g.start) + 1)
                                        cdb.LogInfo("gap", "url", ls.URL(), "stream", ls.Id, "logindex", g.start, "length", (g.end-g.start)+1)
                                        next, _ := fetchFn(ctx, g.start, g.end, true, ls.sendEntry, &amp;ls.Backfill)
                                        if allGapsFilled </span><span class="cov3" title="3">{
                                                _ = cdb.backfillSetGapStartIndex(ctx, ls, next)
                                        }</span>
                                        <span class="cov4" title="4">if next &lt; g.end+1 </span><span class="cov2" title="2">{
                                                allGapsFilled = false
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        allGapsFilled = false
                                }</span>
                        }
                        <span class="cov9" title="50">for gap := range gapCh </span><span class="cov4" title="4">{
                                fillGap(gap)
                        }</span>
                        <span class="cov9" title="50">if lastgap.end != 0 </span><span class="cov0" title="0">{
                                fillGap(lastgap)
                        }</span>
                        <span class="cov9" title="50">if lastindex &gt; 0 &amp;&amp; allGapsFilled </span><span class="cov9" title="47">{
                                _ = cdb.backfillSetGapStartIndex(ctx, ls, lastindex)
                        }</span>
                }
        }
}

// return MIN(logindex) for the stream
func (cdb *PgDB) backfillMinIndex(ctx context.Context, ls *LogStream) (minIndex int64, err error) <span class="cov9" title="48">{
        var minIndexRow sql.NullInt64
        row := cdb.QueryRow(ctx, cdb.stmtSelectMinIdx, ls.Id)
        if err = cdb.LogError(row.Scan(&amp;minIndexRow), "Backfill/MinIndex", "url", ls.URL()); err == nil </span><span class="cov9" title="48">{
                if minIndexRow.Valid </span><span class="cov1" title="1">{
                        minIndex = minIndexRow.Int64
                        ls.seeIndex(minIndex)
                }</span>
        }
        <span class="cov9" title="48">return</span>
}

func (cdb *PgDB) backfillGetGapStartIndex(ctx context.Context, ls *LogStream) (gapStartIndex int64, err error) <span class="cov2" title="2">{
        gapStartIndex = -1
        if cdb != nil &amp;&amp; ls != nil </span><span class="cov2" title="2">{
                var storedIndex int64
                row := cdb.QueryRow(ctx, cdb.stmtSelectBackfillIdx, ls.Id)
                if err = cdb.LogError(row.Scan(&amp;storedIndex), "Backfill/StoredIndex", "url", ls.URL()); err == nil </span><span class="cov2" title="2">{
                        if storedIndex &gt; 0 </span><span class="cov1" title="1">{
                                gapStartIndex = storedIndex
                        }</span> else<span class="cov1" title="1"> {
                                gapStartIndex, err = cdb.backfillMinIndex(ctx, ls)
                        }</span>
                        <span class="cov2" title="2">if err == nil </span><span class="cov2" title="2">{
                                if lastIndex := ls.LastIndex.Load(); lastIndex &gt;= 0 &amp;&amp; gapStartIndex &gt; lastIndex </span><span class="cov0" title="0">{
                                        gapStartIndex = lastIndex
                                }</span>
                        }
                }
        }
        <span class="cov2" title="2">return</span>
}

func (cdb *PgDB) backfillSetGapStartIndex(ctx context.Context, ls *LogStream, logindex int64) (err error) <span class="cov10" title="60">{
        if cdb != nil &amp;&amp; ls != nil </span><span class="cov10" title="60">{
                if ctx.Err() == nil </span><span class="cov10" title="60">{
                        if logindex &gt;= 0 </span><span class="cov10" title="60">{
                                _, err = cdb.Exec(ctx, cdb.stmtUpdateBackfillIdx, logindex, ls.Id)
                                err = cdb.LogError(err, "Backfill/UpdateIndex", "url", ls.URL(), "stream", ls.Id, "logindex", logindex)
                        }</span>
                }
        }
        <span class="cov10" title="60">return</span>
}

func (cdb *PgDB) backfillStream(ctx context.Context, ls *LogStream, wg *sync.WaitGroup) <span class="cov9" title="47">{
        defer wg.Done()
        var minIndex int64
        var err error

        cdb.backfillGapsWithFetcher(ctx, ls, ls.getEntries)
        if minIndex, err = cdb.backfillMinIndex(ctx, ls); err == nil &amp;&amp; minIndex &gt; 0 </span><span class="cov0" title="0">{
                cdb.LogInfo("backlog start", "url", ls.URL(), "stream", ls.Id, "logindex", minIndex)
                ls.Backfill.Add(minIndex)
                for minIndex &gt; 0 </span><span class="cov0" title="0">{
                        start := max(0, minIndex-LogBatchSize)
                        stop := minIndex - 1
                        minIndex = start
                        var wanted bool
                        if _, wanted = ls.getEntries(ctx, start, stop, true, ls.sendEntry, &amp;ls.Backfill); !wanted </span><span class="cov0" title="0">{
                                ls.addError(ls, errLogEntriesTooOld{MaxAge: cdb.PgMaxAge})
                                ls.Backfill.Store(0)
                                break</span>
                        }
                }
                <span class="cov0" title="0">if ctx.Err() == nil </span><span class="cov0" title="0">{
                        cdb.LogInfo("backlog stops", "url", ls.URL(), "stream", ls.Id, "logindex", minIndex)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package certstream

import (
        "context"
        "sync"
        "time"

        "github.com/jackc/pgx/v5/pgconn"
)

func (cdb *PgDB) runBatch(ctx context.Context, queued []*LogEntry) (err error) <span class="cov4" title="62">{
        var b []byte
        b = append(b, `[`...)
        for i, le := range queued </span><span class="cov6" title="729">{
                if i &gt; 0 </span><span class="cov6" title="667">{
                        b = append(b, `,`...)
                }</span>
                <span class="cov6" title="729">b = le.appendJSON(b)</span>
        }
        <span class="cov4" title="62">b = append(b, `]`...)
        now := time.Now()
        _, err = cdb.Exec(ctx, cdb.funcIngestBatch, string(b))
        elapsed := time.Since(now)
        if err != nil </span><span class="cov3" title="31">{
                if pe, ok := err.(*pgconn.PgError); ok </span><span class="cov0" title="0">{
                        if pe.SQLState() == "22P02" </span><span class="cov0" title="0">{
                                cdb.LogInfo("generated invalid JSON data", "json", string(b))
                        }</span>
                }
        }
        <span class="cov4" title="62">cdb.mu.Lock()
        cdb.newentrycount += int64(len(queued))
        cdb.newentrytime += elapsed
        cdb.mu.Unlock()
        return</span>
}

func (cdb *PgDB) worker(ctx context.Context, wg *sync.WaitGroup, workerID int) <span class="cov3" title="32">{
        defer wg.Done()
        if batchCh := cdb.getBatchCh(workerID); batchCh != nil </span><span class="cov3" title="32">{
                cdb.Workers.Add(1)
                defer cdb.Workers.Add(-1)
                const tickerInterval = time.Second * 10
                staggerInterval := tickerInterval / time.Duration(cdb.workerCount)
                tckr := time.NewTicker(1 + (staggerInterval * time.Duration(workerID)))
                stop := false
                var queued []*LogEntry
                for !stop </span><span class="cov6" title="815">{
                        ticked := false
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov3" title="32">
                                stop = true</span>
                        case &lt;-tckr.C:<span class="cov4" title="54">
                                ticked = true
                                if staggerInterval != 0 </span><span class="cov3" title="32">{
                                        staggerInterval = 0
                                        tckr.Stop()
                                        tckr = time.NewTicker(tickerInterval)
                                        defer tckr.Stop()
                                }</span>
                        case le := &lt;-batchCh:<span class="cov6" title="729">
                                queued = append(queued, le)</span>
                        }
                        <span class="cov6" title="815">if l := len(queued); l &gt; 0 &amp;&amp; (l &gt;= DbIngestBatchSize || ticked || stop) </span><span class="cov4" title="62">{
                                _ = cdb.LogError(cdb.runBatch(ctx, queued), "runBatch")
                                for _, le := range queued </span><span class="cov6" title="729">{
                                        if !stop </span><span class="cov4" title="105">{
                                                select </span>{
                                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                                        stop = true</span>
                                                case cdb.getSendEntryCh() &lt;- le:<span class="cov4" title="105"></span>
                                                }
                                        }
                                }
                                <span class="cov4" title="62">clear(queued)
                                queued = queued[:0]</span>
                        }
                }
        }
}

func (cdb *PgDB) AverageNewEntryTime() (d time.Duration) <span class="cov0" title="0">{
        cdb.mu.Lock()
        d = cdb.avgentrytime
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) runWorkers(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        const interval = time.Millisecond * 100
        defer func() </span><span class="cov1" title="1">{
                wg.Done()
        }</span>()

        <span class="cov1" title="1">wg.Add(cdb.workerCount)
        for i := 0; i &lt; cdb.workerCount; i++ </span><span class="cov3" title="32">{
                go cdb.worker(ctx, wg, i)
        }</span>

        <span class="cov1" title="1">ticks := 0
        ticker := time.NewTicker(interval)
        avgentrytimes := make([]time.Duration, time.Minute/interval)
        defer ticker.Stop()
        for </span><span class="cov4" title="166">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov4" title="165">
                        cdb.mu.Lock()
                        avgentrytime := cdb.newentrytime
                        if d := time.Duration(cdb.newentrycount); d &gt; 0 </span><span class="cov3" title="30">{
                                avgentrytime /= d
                        }</span>
                        <span class="cov4" title="165">cdb.newentrytime = 0
                        cdb.newentrycount = 0
                        avgentrytimes[ticks] = avgentrytime
                        ticks++
                        if ticks &gt;= cap(avgentrytimes) </span><span class="cov0" title="0">{
                                ticks = 0
                        }</span>
                        <span class="cov4" title="165">avgentrytime = 0
                        for _, d := range avgentrytimes </span><span class="cov10" title="99000">{
                                avgentrytime += d
                        }</span>
                        <span class="cov4" title="165">cdb.avgentrytime = avgentrytime / time.Duration(cap(avgentrytimes))
                        cdb.mu.Unlock()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package certstream

import (
        "time"
)

type PgCertificate struct {
        Id         int64
        NotBefore  time.Time
        NotAfter   time.Time
        CommonName string
        SubjectID  int
        IssuerID   int
        Sha256     []byte
        PreCert    bool
        Since      time.Time
}

func ScanCertificate(row Scanner, cert *PgCertificate) (err error) <span class="cov10" title="2">{
        var p_since *time.Time
        if err = row.Scan(
                &amp;cert.Id,
                &amp;cert.NotBefore,
                &amp;cert.NotAfter,
                &amp;cert.CommonName,
                &amp;cert.SubjectID,
                &amp;cert.IssuerID,
                &amp;cert.Sha256,
                &amp;cert.PreCert,
                &amp;p_since,
        ); err == nil </span><span class="cov10" title="2">{
                if p_since != nil </span><span class="cov10" title="2">{
                        cert.Since = *p_since
                }</span>
        }
        <span class="cov10" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package certstream

import (
        "context"
        "database/sql"
        _ "embed"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Scanner interface {
        Scan(dest ...any) error
}

type gap struct {
        start int64
        end   int64
}

// PgDB integrates with sql.DB to manage certificate stream data for a PostgreSQL database
type PgDB struct {
        *CertStream
        *pgxpool.Pool
        Pfx                   func(string) string // prefix replacer
        Workers               atomic.Int32
        funcOperatorID        string
        funcStreamID          string
        funcIngestBatch       string
        stmtFindGap           string
        stmtSelectMinIdx      string
        stmtSelectMaxIdx      string
        stmtSelectMinIdxFrom  string
        stmtSelectBackfillIdx string
        stmtUpdateBackfillIdx string
        mu                    sync.Mutex // protects following
        batchCh               []chan *LogEntry
        workerBits            int
        workerCount           int
        estimates             map[string]float64 // row count estimates
        newentrytime          time.Duration
        newentrycount         int64
        avgentrytime          time.Duration
}

func ensureSchema(ctx context.Context, db *pgxpool.Pool, pfx func(string) string) (err error) <span class="cov4" title="17">{
        if _, err = db.Exec(ctx, pfx(CreateSchema)); err == nil </span><span class="cov4" title="17">{
                if _, err = db.Exec(ctx, pfx(FunctionOperatorID)); err == nil </span><span class="cov4" title="17">{
                        if _, err = db.Exec(ctx, pfx(FunctionStreamID)); err == nil </span><span class="cov4" title="17">{
                                if _, err = db.Exec(ctx, pfx(FuncSetSince)); err == nil </span><span class="cov4" title="17">{
                                        if _, err = db.Exec(ctx, pfx(FuncSubdomain)); err == nil </span><span class="cov4" title="17">{
                                                _, err = db.Exec(ctx, pfx(FuncIngestBatch))
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov4" title="17">return</span>
}

// NewPgDB creates a PgDB and creates the needed tables and indices if they don't exist.
func NewPgDB(ctx context.Context, cs *CertStream) (cdb *PgDB, err error) <span class="cov5" title="20">{
        const callOperatorID = `SELECT CERTDB_operator_id($1,$2);`
        const callStreamID = `SELECT CERTDB_stream_id($1,$2,$3);`

        if cs.Config.PgAddr != "" </span><span class="cov4" title="17">{
                dsn := fmt.Sprintf("postgres://%s:%s@%s/%s?pool_max_conns=%d&amp;pool_max_conn_idle_time=1m",
                        cs.Config.PgUser, cs.Config.PgPass, cs.Config.PgAddr, cs.Config.PgName, cs.Config.PgConns)
                if !cs.Config.PgSyncCommit </span><span class="cov4" title="17">{
                        dsn += "&amp;synchronous_commit=off"
                }</span>
                <span class="cov4" title="17">if cs.Config.PgNoSSL </span><span class="cov4" title="17">{
                        dsn += "&amp;sslmode=disable"
                }</span>
                <span class="cov4" title="17">var poolcfg *pgxpool.Config
                if poolcfg, err = pgxpool.ParseConfig(dsn); err == nil </span><span class="cov4" title="17">{
                        poolcfg.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeSimpleProtocol
                        var pool *pgxpool.Pool
                        if pool, err = pgxpool.NewWithConfig(ctx, poolcfg); err == nil </span><span class="cov4" title="17">{
                                if err = pool.Ping(ctx); err == nil </span><span class="cov4" title="17">{
                                        cs.LogInfo("database", "addr", cs.Config.PgAddr, "name", cs.Config.PgName, "prefix", cs.Config.PgPrefix)
                                        pfx := func(s string) string </span><span class="cov9" title="460">{ return strings.ReplaceAll(s, "CERTDB_", cs.Config.PgPrefix) }</span>
                                        <span class="cov4" title="17">if err = ensureSchema(ctx, pool, pfx); err == nil </span><span class="cov4" title="17">{
                                                var pgversion string
                                                if cs.LogError(pool.QueryRow(ctx, `SELECT version();`).Scan(&amp;pgversion), "postgres version") == nil </span><span class="cov4" title="17">{
                                                        cs.LogInfo("postgres", "version", pgversion)
                                                }</span>
                                                <span class="cov4" title="17">workerBits := min(8, max(1, cs.Config.PgWorkerBits))
                                                workerCount := 1 &lt;&lt; workerBits
                                                batchChans := make([]chan *LogEntry, workerCount)
                                                for i := range batchChans </span><span class="cov9" title="544">{
                                                        batchChans[i] = make(chan *LogEntry, DbIngestBatchSize*2)
                                                }</span>
                                                <span class="cov4" title="17">cdb = &amp;PgDB{
                                                        CertStream:            cs,
                                                        Pool:                  pool,
                                                        Pfx:                   pfx,
                                                        funcOperatorID:        pfx(callOperatorID),
                                                        funcStreamID:          pfx(callStreamID),
                                                        funcIngestBatch:       pfx(`SELECT CERTDB_ingest_batch($1::jsonb);`),
                                                        stmtFindGap:           pfx(SelectFindGap),
                                                        stmtSelectMinIdx:      pfx(SelectMinIndex),
                                                        stmtSelectMaxIdx:      pfx(SelectMaxIndex),
                                                        stmtSelectMinIdxFrom:  pfx(SelectMinIndexFrom),
                                                        stmtSelectBackfillIdx: pfx(SelectBackfillIndex),
                                                        stmtUpdateBackfillIdx: pfx(UpdateBackfillIndex),
                                                        batchCh:               batchChans,
                                                        workerBits:            workerBits,
                                                        workerCount:           workerCount,
                                                        estimates: map[string]float64{
                                                                "cert":   0,
                                                                "domain": 0,
                                                                "entry":  0,
                                                        },
                                                }
                                                cdb.refreshEstimates(ctx)</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov5" title="20">if cdb != nil </span><span class="cov4" title="17">{
                cs.LogInfo("database workers", "count", cdb.workerCount, "bits", cdb.workerBits)
        }</span>
        <span class="cov5" title="20">return</span>
}

func (cdb *PgDB) Close() <span class="cov4" title="17">{
        cdb.mu.Lock()
        chans := cdb.batchCh
        cdb.batchCh = nil
        cdb.mu.Unlock()
        for _, ch := range chans </span><span class="cov9" title="544">{
                if ch != nil </span><span class="cov9" title="544">{
                        close(ch)
                }</span>
        }
        <span class="cov4" title="17">cdb.Pool.Close()</span>
}

func (cdb *PgDB) QueueUsage() (pct int) <span class="cov0" title="0">{
        cdb.mu.Lock()
        chans := cdb.batchCh
        cdb.mu.Unlock()
        totalLen := 0
        totalCap := 0
        for _, ch := range chans </span><span class="cov0" title="0">{
                if ch != nil </span><span class="cov0" title="0">{
                        totalLen += len(ch)
                        totalCap += cap(ch)
                }</span>
        }
        <span class="cov0" title="0">if totalCap &gt; 0 </span><span class="cov0" title="0">{
                pct = totalLen * 100 / totalCap
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) getBatchCh(idx int) (ch chan *LogEntry) <span class="cov10" title="761">{
        cdb.mu.Lock()
        ch = cdb.batchCh[idx]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) workerIndexFor(le *LogEntry) (idx int) <span class="cov9" title="729">{
        if cdb != nil &amp;&amp; le != nil </span><span class="cov9" title="729">{
                if cert := le.Cert(); cert != nil &amp;&amp; len(cert.Signature) &gt; 0 </span><span class="cov9" title="729">{
                        idx = int(cert.Signature[0] &gt;&gt; (8 - cdb.workerBits))
                }</span>
        }
        <span class="cov9" title="729">return</span>
}

func (cdb *PgDB) sendToBatcher(ctx context.Context, le *LogEntry) <span class="cov9" title="729">{
        if le != nil &amp;&amp; ctx.Err() == nil </span><span class="cov9" title="729">{
                if ch := cdb.getBatchCh(cdb.workerIndexFor(le)); ch != nil </span><span class="cov9" title="729">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        case ch &lt;- le:<span class="cov9" title="729"></span>
                        }
                }
        }
}

func (cdb *PgDB) ensureOperator(ctx context.Context, lo *LogOperator) (err error) <span class="cov3" title="8">{
        if cdb != nil </span><span class="cov3" title="8">{
                row := cdb.QueryRow(ctx, cdb.funcOperatorID, lo.operator.Name, strings.Join(lo.operator.Email, ","))
                err = wrapErr(row.Scan(&amp;lo.Id), cdb.funcOperatorID)
        }</span>
        <span class="cov3" title="8">return</span>
}

func (cdb *PgDB) ensureStream(ctx context.Context, ls *LogStream) (err error) <span class="cov6" title="47">{
        if cdb != nil </span><span class="cov6" title="47">{
                var b []byte
                if b, err = json.Marshal(ls.logInfo()); err == nil </span><span class="cov6" title="47">{
                        row := cdb.QueryRow(ctx, cdb.funcStreamID, ls.URL(), ls.LogOperator.Id, string(b))
                        err = wrapErr(row.Scan(&amp;ls.Id), cdb.funcStreamID)
                }</span>
        }
        <span class="cov6" title="47">return</span>
}

func (cdb *PgDB) fillIdentity(ctx context.Context, id int, ident *JsonIdentity) <span class="cov2" title="4">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT id, organization, province, country FROM CERTDB_ident WHERE id=$1;`), id)
        var dbident PgIdent
        if err := cdb.LogError(ScanIdent(row, &amp;dbident), "fillIdentity", "id", id); err == nil </span><span class="cov2" title="4">{
                ident.ID = id
                ident.Country = dbident.Country
                ident.Organization = dbident.Organization
                ident.Province = dbident.Province
        }</span>
}

func (cdb *PgDB) getCertStrings(ctx context.Context, id int64, tablename, colname string) (sl []string) <span class="cov3" title="8">{
        rows, err := cdb.Query(ctx, cdb.Pfx(fmt.Sprintf("SELECT %s::text FROM CERTDB_%s WHERE cert=$1;", colname, tablename)), id)
        if cdb.LogError(err, "getCertStrings/"+tablename, "id", id) == nil </span><span class="cov3" title="8">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var s string
                        if err := cdb.LogError(rows.Scan(&amp;s), "getCertStrings/scan/"+tablename); err == nil </span><span class="cov0" title="0">{
                                sl = append(sl, s)
                        }</span>
                }
        }
        <span class="cov3" title="8">return</span>
}

func (cdb *PgDB) getCertificate(ctx context.Context, dbcert *PgCertificate) (cert *JsonCertificate, err error) <span class="cov1" title="2">{
        cert = &amp;JsonCertificate{
                PreCert:        dbcert.PreCert,
                Signature:      dbcert.Sha256,
                CommonName:     dbcert.CommonName,
                DNSNames:       []string{},
                EmailAddresses: []string{},
                IPAddresses:    []string{},
                URIs:           []string{},
                NotBefore:      dbcert.NotBefore,
                NotAfter:       dbcert.NotAfter,
                Since:          dbcert.Since,
        }
        cdb.fillIdentity(ctx, dbcert.IssuerID, &amp;cert.Issuer)
        cdb.fillIdentity(ctx, dbcert.SubjectID, &amp;cert.Subject)
        cert.Subject.CommonName = dbcert.CommonName
        cert.DNSNames = cdb.getCertStrings(ctx, dbcert.Id, "dnsnames", "fqdn")
        cert.EmailAddresses = cdb.getCertStrings(ctx, dbcert.Id, "email", "email")
        cert.IPAddresses = cdb.getCertStrings(ctx, dbcert.Id, "ipaddress", "addr")
        for i := range cert.IPAddresses </span><span class="cov0" title="0">{
                cert.IPAddresses[i] = strings.TrimSuffix(cert.IPAddresses[i], "/32")
        }</span>
        <span class="cov1" title="2">cert.URIs = cdb.getCertStrings(ctx, dbcert.Id, "uri", "uri")
        cert.SetCommonName()
        return</span>
}

func (cdb *PgDB) GetCertificateByLogEntry(ctx context.Context, entry *PgLogEntry) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        return cdb.GetCertificateByID(ctx, entry.CertID)
}</span>

func RenderSQL(query string, args ...any) string <span class="cov0" title="0">{
        for i, arg := range args </span><span class="cov0" title="0">{
                var s string
                switch v := arg.(type) </span>{
                case string:<span class="cov0" title="0">
                        s = fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))</span>
                case time.Time:<span class="cov0" title="0">
                        s = fmt.Sprintf("'%s'", v.Format(time.RFC3339))</span>
                default:<span class="cov0" title="0">
                        s = fmt.Sprint(v)</span>
                }
                <span class="cov0" title="0">query = strings.ReplaceAll(query, fmt.Sprintf("$%d", i+1), s)</span>
        }
        <span class="cov0" title="0">return query</span>
}

func (cdb *PgDB) GetCertificatesByCommonName(ctx context.Context, commonname string) (certs []*JsonCertificate, err error) <span class="cov0" title="0">{
        var rows pgx.Rows
        if rows, err = cdb.Query(ctx, cdb.Pfx(`SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since FROM CERTDB_cert WHERE commonname=$1 ORDER BY notbefore DESC;`), commonname); err == nil </span><span class="cov0" title="0">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var dbcert PgCertificate
                        e := ScanCertificate(rows, &amp;dbcert)
                        if e == nil </span><span class="cov0" title="0">{
                                var cert *JsonCertificate
                                if cert, e = cdb.getCertificate(ctx, &amp;dbcert); e == nil </span><span class="cov0" title="0">{
                                        certs = append(certs, cert)
                                }</span>
                        }
                        <span class="cov0" title="0">err = errors.Join(err, e)</span>
                }
                <span class="cov0" title="0">err = errors.Join(err, rows.Err())</span>
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByHash(ctx context.Context, hash []byte) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since FROM CERTDB_cert WHERE sha256=$1;`), hash)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByID(ctx context.Context, id int64) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since FROM CERTDB_cert WHERE id=$1;`), id)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetHistoricalCertificates(ctx context.Context, expiresAfter time.Time, callback func(ctx context.Context, cert *JsonCertificate) (err error)) (err error) <span class="cov1" title="1">{
        if cdb != nil </span><span class="cov1" title="1">{
                expiresAfter = expiresAfter.UTC()
                var maxNotAfter *time.Time
                if err = cdb.QueryRow(ctx, cdb.Pfx(`SELECT MAX(notafter) FROM CERTDB_cert;`)).Scan(&amp;maxNotAfter); err == nil </span><span class="cov1" title="1">{
                        if maxNotAfter != nil </span><span class="cov1" title="1">{
                                maxAtStart := maxNotAfter.UTC()
                                lastNotAfter := expiresAfter
                                lastID := int64(0)
                                query := cdb.Pfx(`
SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since
FROM CERTDB_cert
WHERE notafter &gt; $1
  AND notafter &lt;= $2
  AND (notafter &gt; $3 OR (notafter = $3 AND id &gt; $4))
ORDER BY notafter ASC, id ASC
LIMIT $5;
`)
                                for err == nil </span><span class="cov1" title="2">{
                                        var rows pgx.Rows
                                        if rows, err = cdb.Query(ctx, query, expiresAfter, maxAtStart, lastNotAfter, lastID, max(100, HistoricalBatchSize)); err == nil </span><span class="cov1" title="2">{
                                                var dbcerts []PgCertificate
                                                for rows.Next() &amp;&amp; err == nil </span><span class="cov1" title="2">{
                                                        var dbcert PgCertificate
                                                        if err = ScanCertificate(rows, &amp;dbcert); err == nil </span><span class="cov1" title="2">{
                                                                dbcerts = append(dbcerts, dbcert)
                                                        }</span>
                                                }
                                                <span class="cov1" title="2">if err == nil </span><span class="cov1" title="2">{
                                                        err = rows.Err()
                                                }</span>
                                                <span class="cov1" title="2">rows.Close()
                                                if err == nil </span><span class="cov1" title="2">{
                                                        if len(dbcerts) == 0 </span><span class="cov1" title="1">{
                                                                break</span>
                                                        }
                                                        <span class="cov1" title="1">for i := range dbcerts </span><span class="cov1" title="2">{
                                                                if err == nil </span><span class="cov1" title="2">{
                                                                        dbcert := dbcerts[i]
                                                                        var cert *JsonCertificate
                                                                        if cert, err = cdb.getCertificate(ctx, &amp;dbcert); err == nil </span><span class="cov1" title="2">{
                                                                                if err = callback(ctx, cert); err == nil </span><span class="cov1" title="2">{
                                                                                        lastNotAfter = dbcert.NotAfter
                                                                                        lastID = dbcert.Id
                                                                                }</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

func (cdb *PgDB) DeleteCertificates(ctx context.Context, cutoff time.Time, batchSize int) (rowsDeleted int64, err error) <span class="cov2" title="3">{
        if cdb != nil </span><span class="cov2" title="3">{
                if batchSize &gt; 0 </span><span class="cov2" title="3">{
                        cutoff = cutoff.UTC()
                        query := cdb.Pfx(`WITH CERTDB_clean_cert AS (
  SELECT ctid
  FROM CERTDB_cert
  WHERE notafter &lt;= $1
  ORDER BY notafter DESC
  LIMIT $2
  FOR UPDATE SKIP LOCKED
)
DELETE FROM CERTDB_cert
USING CERTDB_clean_cert
WHERE CERTDB_cert.ctid = CERTDB_clean_cert.ctid;`)
                        var tag pgconn.CommandTag
                        if tag, err = cdb.Exec(ctx, query, cutoff, batchSize); err == nil </span><span class="cov2" title="3">{
                                rowsDeleted = tag.RowsAffected()
                        }</span>
                }
        }
        <span class="cov2" title="3">return</span>
}

func (cdb *PgDB) DeleteStream(ctx context.Context, streamId int32, batchSize int) (rowsDeleted int64, err error) <span class="cov2" title="4">{
        if cdb != nil </span><span class="cov2" title="4">{
                if batchSize &gt; 0 </span><span class="cov2" title="4">{
                        query := cdb.Pfx(`WITH CERTDB_clean_stream AS (
  SELECT ctid
  FROM CERTDB_entry
  WHERE stream = $1
  ORDER BY logindex ASC
  LIMIT $2
  FOR UPDATE SKIP LOCKED
)
DELETE FROM CERTDB_entry
USING CERTDB_clean_stream
WHERE CERTDB_entry.ctid = CERTDB_clean_stream.ctid;`)
                        var tag pgconn.CommandTag
                        if tag, err = cdb.Exec(ctx, query, streamId, batchSize); err == nil </span><span class="cov2" title="4">{
                                rowsDeleted = tag.RowsAffected()
                                if rowsDeleted == 0 </span><span class="cov1" title="2">{
                                        if tag, err = cdb.Exec(ctx, cdb.Pfx(`DELETE FROM CERTDB_stream WHERE id = $1;`), streamId); err == nil </span><span class="cov1" title="2">{
                                                rowsDeleted = tag.RowsAffected()
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov2" title="4">return</span>
}

func (cdb *PgDB) Estimate(table string) (f float64) <span class="cov0" title="0">{
        table = strings.TrimPrefix(table, "CERTDB_")
        table = strings.TrimPrefix(table, cdb.CertStream.Config.PgPrefix)
        cdb.mu.Lock()
        f = cdb.estimates[table]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) refreshEstimatesBatch() (batch *pgx.Batch) <span class="cov4" title="17">{
        batch = &amp;pgx.Batch{}
        cdb.mu.Lock()
        defer cdb.mu.Unlock()
        for k := range cdb.estimates </span><span class="cov6" title="51">{
                table := cdb.Pfx("CERTDB_" + k)
                batch.Queue(SelectEstimate, table).QueryRow(func(row pgx.Row) error </span><span class="cov6" title="51">{
                        var estimate float64
                        if cdb.LogError(row.Scan(&amp;estimate), "refreshEstimates", "table", table) == nil </span><span class="cov6" title="51">{
                                cdb.mu.Lock()
                                cdb.estimates[k] = estimate
                                cdb.mu.Unlock()
                        }</span>
                        <span class="cov6" title="51">return nil</span>
                })
        }
        <span class="cov4" title="17">return</span>
}

func (cdb *PgDB) refreshEstimates(ctx context.Context) <span class="cov4" title="17">{
        if batch := cdb.refreshEstimatesBatch(); batch != nil </span><span class="cov4" title="17">{
                ctx, cancel := context.WithTimeout(ctx, time.Minute)
                defer cancel()
                _ = cdb.LogError(cdb.SendBatch(ctx, batch).Close(), "refreshEstimates")
        }</span>
}

func (cdb *PgDB) estimator(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        defer wg.Done()
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()
        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cdb.refreshEstimates(ctx)</span>
                }
        }
}

type gapTotals struct {
        count atomic.Int64
        size  atomic.Int64
}

func (gt *gapTotals) add(g gap) <span class="cov1" title="2">{
        if gt != nil </span><span class="cov1" title="2">{
                gt.count.Add(1)
                gt.size.Add((g.end - g.start) + 1)
        }</span>
}

func (gt *gapTotals) values() (count int64, size int64) <span class="cov1" title="2">{
        if gt != nil </span><span class="cov1" title="2">{
                count = gt.count.Load()
                size = gt.size.Load()
        }</span>
        <span class="cov1" title="2">return</span>
}

func (cdb *PgDB) selectStreamGaps(ctx context.Context, wg *sync.WaitGroup, ls *LogStream, totals *gapTotals) <span class="cov6" title="56">{
        defer wg.Done()

        gapCh := ls.getGapCh()
        if gapCh != nil </span><span class="cov6" title="56">{
                defer func() </span><span class="cov6" title="56">{
                        ls.mu.Lock()
                        if ls.gapCh == gapCh </span><span class="cov6" title="56">{
                                close(gapCh)
                        }</span>
                        <span class="cov6" title="56">ls.mu.Unlock()</span>
                }()
                <span class="cov6" title="56">var err error
                var maxIndex sql.NullInt64
                if err = cdb.QueryRow(ctx, cdb.stmtSelectMaxIdx, ls.Id).Scan(&amp;maxIndex); err == nil </span><span class="cov6" title="56">{
                        endIndex := int64(-1)
                        if maxIndex.Valid </span><span class="cov3" title="9">{
                                endIndex = maxIndex.Int64
                        }</span>
                        <span class="cov6" title="56">if endIndex &gt;= 0 </span><span class="cov3" title="9">{
                                var lastIndex int64
                                if err = cdb.QueryRow(ctx, cdb.stmtSelectBackfillIdx, ls.Id).Scan(&amp;lastIndex); err == nil </span><span class="cov3" title="9">{
                                        var startIndex sql.NullInt64
                                        if err = cdb.QueryRow(ctx, cdb.stmtSelectMinIdxFrom, ls.Id, lastIndex).Scan(&amp;startIndex); err == nil </span><span class="cov3" title="9">{
                                                if startIndex.Valid </span><span class="cov3" title="9">{
                                                        hadGaps := false
                                                        if startIndex.Int64 &gt; lastIndex </span><span class="cov2" title="4">{
                                                                if lastIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov1" title="1">{
                                                                        g := gap{start: lastIndex, end: startIndex.Int64 - 1}
                                                                        select </span>{
                                                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                                                        case gapCh &lt;- g:<span class="cov1" title="1">
                                                                                hadGaps = true
                                                                                if totals != nil </span><span class="cov0" title="0">{
                                                                                        totals.add(g)
                                                                                }</span>
                                                                        }
                                                                } else<span class="cov2" title="3"> if ctx.Err() == nil </span><span class="cov2" title="3">{
                                                                        _ = cdb.backfillSetGapStartIndex(ctx, ls, startIndex.Int64)
                                                                }</span>
                                                                <span class="cov2" title="4">lastIndex = startIndex.Int64</span>
                                                        }
                                                        <span class="cov3" title="9">stmt := cdb.stmtFindGap
                                                        for err == nil &amp;&amp; ctx.Err() == nil &amp;&amp; lastIndex &lt; endIndex </span><span class="cov4" title="17">{
                                                                row := cdb.QueryRow(ctx, stmt, ls.Id, lastIndex, endIndex)
                                                                var gapStart sql.NullInt64
                                                                var gapEnd sql.NullInt64
                                                                if err = row.Scan(&amp;gapStart, &amp;gapEnd); err == nil </span><span class="cov4" title="17">{
                                                                        if gapStart.Valid &amp;&amp; gapEnd.Valid </span><span class="cov4" title="13">{
                                                                                g := gap{start: gapStart.Int64, end: gapEnd.Int64}
                                                                                select </span>{
                                                                                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                                                                case gapCh &lt;- g:<span class="cov4" title="13">
                                                                                        lastIndex = gapEnd.Int64 + 1
                                                                                        hadGaps = true
                                                                                        if totals != nil </span><span class="cov1" title="2">{
                                                                                                totals.add(g)
                                                                                        }</span>
                                                                                }
                                                                        } else<span class="cov2" title="4"> if ctx.Err() == nil </span><span class="cov2" title="4">{
                                                                                if !hadGaps </span><span class="cov1" title="1">{
                                                                                        if err = cdb.backfillSetGapStartIndex(ctx, ls, endIndex); err == nil </span><span class="cov1" title="1">{
                                                                                                lastIndex = endIndex
                                                                                        }</span>
                                                                                }
                                                                                <span class="cov2" title="4">break</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
                <span class="cov6" title="56">_ = cdb.LogError(err, "selectAllGaps.stream", "stream", ls.Id, "url", ls.URL())</span>
        }
}

func (cdb *PgDB) selectAllGaps(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="2">{
        defer wg.Done()

        streams := make(map[int32]*LogStream)

        cdb.mu.Lock()
        for _, logop := range cdb.operators </span><span class="cov3" title="9">{
                logop.mu.Lock()
                for _, ls := range logop.streams </span><span class="cov6" title="49">{
                        if ls.gapCh == nil </span><span class="cov6" title="47">{
                                ls.gapCh = make(chan gap, 8)
                        }</span>
                        <span class="cov6" title="49">streams[ls.Id] = ls</span>
                }
                <span class="cov3" title="9">logop.mu.Unlock()</span>
        }
        <span class="cov1" title="2">cdb.mu.Unlock()

        start := time.Now()
        cdb.LogInfo("selectAllGaps starts", "streams", len(streams))

        var totals gapTotals
        var streamWG sync.WaitGroup
        for _, ls := range streams </span><span class="cov6" title="49">{
                streamWG.Add(1)
                go cdb.selectStreamGaps(ctx, &amp;streamWG, ls, &amp;totals)
        }</span>
        <span class="cov1" title="2">streamWG.Wait()

        if ctx.Err() == nil </span><span class="cov1" title="2">{
                totalgaps, totalgapsize := totals.values()
                cdb.LogInfo("selectAllGaps completed", "totalgapsize", totalgapsize, "totalgaps", totalgaps, "elapsed", time.Since(start).Round(time.Second))
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package certstream

type PgDnsname struct {
        Dnsname string
        CertID  int64
}

func ScanDnsname(row Scanner, p *PgDnsname) error <span class="cov0" title="0">{
        return row.Scan(
                &amp;p.Dnsname,
                &amp;p.CertID,
        )
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package certstream

import (
        "time"
)

type PgDnsnamesView struct {
        CertID    int64
        FQDN      string
        NotBefore time.Time
        Idna      bool
        Valid     bool
        PreCert   bool
        Issuer    string
        Subject   string
        Crtsh     string
        Domain    string
        Tld       string
}

func ScanDnsnamesView(row Scanner, dnsname *PgDnsnamesView) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;dnsname.CertID,
                &amp;dnsname.FQDN,
                &amp;dnsname.NotBefore,
                &amp;dnsname.Idna,
                &amp;dnsname.Valid,
                &amp;dnsname.PreCert,
                &amp;dnsname.Issuer,
                &amp;dnsname.Subject,
                &amp;dnsname.Crtsh,
                &amp;dnsname.Domain,
                &amp;dnsname.Tld,
        )
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package certstream

type PgIdent struct {
        Id           int
        Organization string
        Province     string
        Country      string
}

func ScanIdent(row Scanner, ident *PgIdent) error <span class="cov10" title="4">{
        return row.Scan(
                &amp;ident.Id,
                &amp;ident.Organization,
                &amp;ident.Province,
                &amp;ident.Country,
        )
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package certstream

import (
        "time"
)

type PgLogEntry struct {
        Seen     time.Time // CT log entry timestamp
        LogIndex int64     // CT log index for the stream
        CertID   int64     // database ID of cert
        StreamID int32     // database ID of stream
}

func ScanLogEntry(row Scanner, entry *PgLogEntry) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;entry.Seen,
                &amp;entry.LogIndex,
                &amp;entry.CertID,
                &amp;entry.StreamID,
        )
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"
)

var ErrTailLogOpen = errors.New("tail log open failed")
var ErrHeadLogOpen = errors.New("head log open failed")

type errTailLogOpen struct {
        err error
}

func (e errTailLogOpen) Error() string <span class="cov0" title="0">{
        return ErrTailLogOpen.Error() + ": " + e.err.Error()
}</span>

func (e errTailLogOpen) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func (e errTailLogOpen) Is(target error) bool <span class="cov0" title="0">{
        return target == ErrTailLogOpen
}</span>

type errHeadLogOpen struct {
        err error
}

func (e errHeadLogOpen) Error() string <span class="cov0" title="0">{
        return ErrHeadLogOpen.Error() + ": " + e.err.Error()
}</span>

func (e errHeadLogOpen) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

func (e errHeadLogOpen) Is(target error) bool <span class="cov0" title="0">{
        return target == ErrHeadLogOpen
}</span>

type requestLogTransport struct {
        next   http.RoundTripper
        writer io.Writer
        mu     sync.Mutex
}

type tailLogTransport = requestLogTransport
type headLogTransport = requestLogTransport

func newRequestLogTransport(next http.RoundTripper, writer io.Writer) (rlt *requestLogTransport) <span class="cov10" title="4">{
        if next != nil &amp;&amp; writer != nil </span><span class="cov10" title="4">{
                rlt = &amp;requestLogTransport{next: next, writer: writer}
        }</span>
        <span class="cov10" title="4">return</span>
}

func newTailLogTransport(next http.RoundTripper, writer io.Writer) (tlt *tailLogTransport) <span class="cov8" title="3">{
        tlt = newRequestLogTransport(next, writer)
        return
}</span>

func newHeadLogTransport(next http.RoundTripper, writer io.Writer) (hlt *headLogTransport) <span class="cov1" title="1">{
        hlt = newRequestLogTransport(next, writer)
        return
}</span>

func (rlt *requestLogTransport) RoundTrip(req *http.Request) (resp *http.Response, err error) <span class="cov8" title="3">{
        if rlt != nil </span><span class="cov8" title="3">{
                resp, err = rlt.next.RoundTrip(req)
                rlt.logRequest(req, resp, err)
        }</span>
        <span class="cov8" title="3">return</span>
}

func (rlt *requestLogTransport) logRequest(req *http.Request, resp *http.Response, err error) <span class="cov8" title="3">{
        if rlt != nil &amp;&amp; rlt.writer != nil </span><span class="cov8" title="3">{
                if !errors.Is(err, context.Canceled) </span><span class="cov5" title="2">{
                        var scheme, host, method, uri, result string
                        reqcl := int64(-1)
                        respcl := int64(-1)
                        if req != nil </span><span class="cov5" title="2">{
                                reqcl = req.ContentLength
                                host = req.Host
                                method = req.Method
                                if req.URL != nil </span><span class="cov5" title="2">{
                                        scheme = req.URL.Scheme
                                        uri = req.URL.Path
                                        if raw := req.URL.RawQuery; raw != "" </span><span class="cov5" title="2">{
                                                uri += "?" + raw
                                        }</span>
                                }
                                <span class="cov5" title="2">if resp != nil </span><span class="cov1" title="1">{
                                        if result = resp.Status; result == "" </span><span class="cov0" title="0">{
                                                result = fmt.Sprintf("%03d", resp.StatusCode)
                                        }</span>
                                        <span class="cov1" title="1">respcl = resp.ContentLength</span>
                                } else<span class="cov1" title="1"> {
                                        result = "000 missing response"
                                }</span>
                        } else<span class="cov0" title="0"> {
                                result = "000 missing request"
                        }</span>
                        <span class="cov5" title="2">if err != nil </span><span class="cov1" title="1">{
                                result += "; " + err.Error()
                        }</span>
                        <span class="cov5" title="2">rlt.mu.Lock()
                        _, _ = fmt.Fprintf(rlt.writer, "%s %s %s://%s%s (%d) =&gt; %q (%d)\n",
                                time.Now().UTC().Format(time.RFC3339), method, scheme, host, uri, reqcl, result, respcl)
                        rlt.mu.Unlock()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type StreamError struct {
        *LogStream
        When time.Time
        Err  error
}

func (ewt StreamError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("%v %s", ewt.When.Format(time.DateTime), ewt.Err.Error())
}</span>

func (ewt StreamError) Unwrap() error <span class="cov10" title="2">{
        return ewt.Err
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package certstream

import (
        "context"
        "errors"
        "io/fs"
        "os"
        "path"
        "path/filepath"
        "sync"
        "syscall"
        "time"
)

func getCacheDir(baseDir string, monitoringURL string) (cacheDir string) <span class="cov10" title="29">{
        if baseDir != "" </span><span class="cov9" title="28">{
                cacheDir = path.Join(baseDir, "tilecache")
                if monitoringURL != "" </span><span class="cov9" title="20">{
                        cacheDir = path.Join(cacheDir, urlToFileString(monitoringURL))
                }</span>
        }
        <span class="cov10" title="29">return</span>
}

func pruneCacheFiles(cacheDir string, maxAge time.Duration, now time.Time) (removed int, err error) <span class="cov5" title="5">{
        cutoff := now.Add(-maxAge)
        var dirs []string
        var walkErr error
        walkErr = filepath.WalkDir(cacheDir, func(path string, d fs.DirEntry, walkErr error) error </span><span class="cov6" title="8">{
                err = errors.Join(err, walkErr)
                if walkErr == nil </span><span class="cov6" title="8">{
                        if d.IsDir() </span><span class="cov5" title="6">{
                                if path != cacheDir </span><span class="cov1" title="1">{
                                        dirs = append(dirs, path)
                                }</span>
                        } else<span class="cov2" title="2"> {
                                var info fs.FileInfo
                                info, walkErr = d.Info()
                                err = errors.Join(err, walkErr)
                                if walkErr == nil </span><span class="cov2" title="2">{
                                        if info.ModTime().Before(cutoff) </span><span class="cov1" title="1">{
                                                walkErr = os.Remove(path)
                                                err = errors.Join(err, walkErr)
                                                if walkErr == nil </span><span class="cov1" title="1">{
                                                        removed++
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov6" title="8">return nil</span>
        })

        <span class="cov5" title="5">err = errors.Join(err, walkErr)

        // try removing directories
        for i := len(dirs) - 1; i &gt;= 0; i-- </span><span class="cov1" title="1">{
                if walkErr = os.Remove(dirs[i]); walkErr != nil </span><span class="cov0" title="0">{
                        if !errors.Is(walkErr, syscall.ENOTEMPTY) &amp;&amp; !errors.Is(walkErr, os.ErrNotExist) </span><span class="cov0" title="0">{
                                err = errors.Join(err, walkErr)
                        }</span>
                }
        }
        <span class="cov5" title="5">return</span>
}

func (cs *CertStream) runCachePruner(ctx context.Context, wg *sync.WaitGroup, cacheDir string, maxAge time.Duration) <span class="cov4" title="4">{
        ticker := time.NewTicker(min(time.Minute, maxAge))
        defer func() </span><span class="cov4" title="4">{
                ticker.Stop()
                wg.Done()
        }</span>()
        <span class="cov4" title="4">for </span><span class="cov4" title="4">{
                if _, err := pruneCacheFiles(cacheDir, maxAge, time.Now()); err != nil </span><span class="cov0" title="0">{
                        _ = cs.LogError(err, "runCachePruner", "dir", cacheDir)
                }</span>
                <span class="cov4" title="4">select </span>{
                case &lt;-ctx.Done():<span class="cov4" title="4">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0"></span>
                }
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package certstream

import (
        "crypto/x509"
        "errors"
        "log/slog"
        "net/http"
        "os"

        "filippo.io/sunlight"
        "github.com/google/certificate-transparency-go/loglist3"
)

const sunlightUserAgent = "certstream (+https://github.com/linkdata/certstream)"

var ErrSunlightClientMissing = errors.New("sunlight client missing")

func newSunlightClient(log *loglist3.TiledLog, httpClient *http.Client, logger *slog.Logger, concurrency int, cacheDir string) (client *sunlight.Client, err error) <span class="cov10" title="44">{
        var pub any
        if cacheDir != "" </span><span class="cov9" title="41">{
                err = os.MkdirAll(cacheDir, 0o755)
        }</span>
        <span class="cov10" title="44">if err == nil </span><span class="cov10" title="44">{
                if log != nil </span><span class="cov10" title="44">{
                        if pub, err = x509.ParsePKIXPublicKey(log.Key); err == nil </span><span class="cov10" title="44">{
                                cfg := &amp;sunlight.ClientConfig{
                                        MonitoringPrefix: log.MonitoringURL,
                                        PublicKey:        pub,
                                        HTTPClient:       httpClient,
                                        UserAgent:        sunlightUserAgent,
                                        ConcurrencyLimit: max(concurrency, 1),
                                        Cache:            cacheDir,
                                        Logger:           logger,
                                }
                                client, err = sunlight.NewClient(cfg)
                        }</span>
                }
        }
        <span class="cov10" title="44">return</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package certstream

import (
        "context"
        "log/slog"
        "os"
        "sync/atomic"
)

type lazyFileWriter struct {
        path string
        perm os.FileMode
}

func newLazyFileWriter(path string) *lazyFileWriter <span class="cov7" title="48">{
        return &amp;lazyFileWriter{
                path: path,
                perm: 0o644,
        }
}</span>

func (lw *lazyFileWriter) Write(p []byte) (n int, err error) <span class="cov1" title="1">{
        var file *os.File
        if file, err = os.OpenFile(lw.path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, lw.perm); err == nil </span><span class="cov1" title="1">{
                defer file.Close()
                n, err = file.Write(p)
        }</span>
        <span class="cov1" title="1">return</span>
}

type toggledHandler struct {
        toggle  *atomic.Bool
        handler slog.Handler
}

func newToggledHandler(toggle *atomic.Bool, handler slog.Handler) slog.Handler <span class="cov7" title="48">{
        return &amp;toggledHandler{toggle: toggle, handler: handler}
}</span>

func (th *toggledHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov10" title="257">{
        return th.toggle.Load()
}</span>

func (th *toggledHandler) Handle(ctx context.Context, record slog.Record) (err error) <span class="cov1" title="1">{
        if th.toggle.Load() </span><span class="cov1" title="1">{
                err = th.handler.Handle(ctx, record)
        }</span>
        <span class="cov1" title="1">return</span>
}

func (th *toggledHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        handler := th.handler.WithAttrs(attrs)
        return &amp;toggledHandler{toggle: th.toggle, handler: handler}
}</span>

func (th *toggledHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        handler := th.handler.WithGroup(name)
        return &amp;toggledHandler{toggle: th.toggle, handler: handler}
}</span>

func newToggledLogger(filepath string, toggle *atomic.Bool) (l *slog.Logger) <span class="cov7" title="48">{
        handler := newToggledHandler(toggle, slog.NewTextHandler(newLazyFileWriter(filepath), nil))
        l = slog.New(handler)
        return
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "slices"
        "sort"
        "sync"

        "github.com/google/certificate-transparency-go/loglist3"
)

func (cs *CertStream) ensureOperator(ctx context.Context, op *loglist3.Operator, opDom string) (logop *LogOperator, err error) <span class="cov7" title="47">{
        cs.mu.Lock()
        logop = cs.operators[opDom]
        cs.mu.Unlock()

        if logop == nil </span><span class="cov4" title="8">{
                logop = &amp;LogOperator{
                        CertStream: cs,
                        operator:   op,
                        Domain:     opDom,
                        streams:    make(map[string]*LogStream),
                }
                sort.Strings(op.Email)
                if db := cs.DB(); db != nil </span><span class="cov4" title="8">{
                        if err = db.ensureOperator(ctx, logop); err == nil </span><span class="cov4" title="8">{
                                cs.mu.Lock()
                                cs.operators[opDom] = logop
                                cs.mu.Unlock()
                        }</span>
                }
        }
        <span class="cov7" title="47">return</span>
}

func (cs *CertStream) ensureOperatorAndLog(ctx context.Context, op *loglist3.Operator, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov6" title="27">{
        opDom := OperatorDomain(log.URL)

        var logop *LogOperator
        if logop, err = cs.ensureOperator(ctx, op, opDom); err == nil </span><span class="cov6" title="27">{
                err = logop.ensureStream(ctx, log, wg)
        }</span>

        <span class="cov6" title="27">return</span>
}

func (cs *CertStream) ensureOperatorAndTiledLog(ctx context.Context, op *loglist3.Operator, log *loglist3.TiledLog, wg *sync.WaitGroup) (err error) <span class="cov6" title="20">{
        opDom := OperatorDomain(log.MonitoringURL)

        var logop *LogOperator
        if logop, err = cs.ensureOperator(ctx, op, opDom); err == nil </span><span class="cov6" title="20">{
                err = logop.ensureTiledStream(ctx, log, wg)
        }</span>

        <span class="cov6" title="20">return</span>
}

func (cs *CertStream) updateStreams(ctx context.Context, wg *sync.WaitGroup) (err error) <span class="cov3" title="4">{
        defer wg.Done()
        var logList *loglist3.LogList
        if logList, err = getLogList(ctx, cs.HeadClient, loglist3.AllLogListURL); err == nil </span><span class="cov1" title="1">{
                for _, op := range logList.Operators </span><span class="cov6" title="24">{
                        for _, log := range op.Logs </span><span class="cov10" title="187">{
                                if log.State.LogStatus() == loglist3.UsableLogStatus </span><span class="cov6" title="27">{
                                        if e := cs.ensureOperatorAndLog(ctx, op, log, wg); e != nil </span><span class="cov0" title="0">{
                                                err = errors.Join(err, e)
                                        }</span>
                                }
                        }
                        <span class="cov6" title="24">for _, log := range op.TiledLogs </span><span class="cov8" title="60">{
                                if log.State.LogStatus() == loglist3.UsableLogStatus </span><span class="cov6" title="20">{
                                        if e := cs.ensureOperatorAndTiledLog(ctx, op, log, wg); e != nil </span><span class="cov0" title="0">{
                                                err = errors.Join(err, e)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov3" title="4">var operators []string
        for _, lo := range cs.Operators() </span><span class="cov4" title="8">{
                operators = append(operators, fmt.Sprintf("%s*%d", lo.Domain, len(lo.Streams())))
        }</span>
        <span class="cov3" title="4">slices.Sort(operators)
        cs.LogInfo("active", "streams", operators)
        return</span>
}

func (cs *CertStream) removeStream(ls *LogStream) <span class="cov7" title="47">{
        lo := ls.LogOperator
        lo.mu.Lock()
        delete(lo.streams, ls.URL())
        empty := len(lo.streams) == 0
        lo.mu.Unlock()
        if empty </span><span class="cov4" title="8">{
                cs.mu.Lock()
                delete(cs.operators, lo.Domain)
                cs.mu.Unlock()
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package certstream

type wrappedErr struct {
        err error
        msg string
}

func (we wrappedErr) Error() string <span class="cov0" title="0">{
        return we.msg + ": " + we.err.Error()
}</span>

func (we wrappedErr) Unwrap() error <span class="cov0" title="0">{
        return we.err
}</span>

func wrapErr(err error, msg string) error <span class="cov10" title="55">{
        if err == nil </span><span class="cov10" title="55">{
                return nil
        }</span>
        <span class="cov0" title="0">return wrappedErr{err: err, msg: msg}</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
