
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>certstream: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/certstream/certificate.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/certstream/certstream.go (78.7%)</option>
				
				<option value="file2">github.com/linkdata/certstream/config.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/certstream/errlogidle.go (0.0%)</option>
				
				<option value="file4">github.com/linkdata/certstream/getloglist.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/certstream/jsoncertificate.go (63.0%)</option>
				
				<option value="file6">github.com/linkdata/certstream/jsonidentity.go (91.7%)</option>
				
				<option value="file7">github.com/linkdata/certstream/logentry.go (85.1%)</option>
				
				<option value="file8">github.com/linkdata/certstream/logoperator.go (75.0%)</option>
				
				<option value="file9">github.com/linkdata/certstream/logstream.go (81.4%)</option>
				
				<option value="file10">github.com/linkdata/certstream/operatordomain.go (100.0%)</option>
				
				<option value="file11">github.com/linkdata/certstream/pgbackfill.go (90.0%)</option>
				
				<option value="file12">github.com/linkdata/certstream/pgbatcher.go (89.9%)</option>
				
				<option value="file13">github.com/linkdata/certstream/pgcertificate.go (100.0%)</option>
				
				<option value="file14">github.com/linkdata/certstream/pgdb.go (84.9%)</option>
				
				<option value="file15">github.com/linkdata/certstream/pgdnsname.go (0.0%)</option>
				
				<option value="file16">github.com/linkdata/certstream/pgdnsnamesview.go (0.0%)</option>
				
				<option value="file17">github.com/linkdata/certstream/pgident.go (100.0%)</option>
				
				<option value="file18">github.com/linkdata/certstream/pglogentry.go (0.0%)</option>
				
				<option value="file19">github.com/linkdata/certstream/streamerror.go (100.0%)</option>
				
				<option value="file20">github.com/linkdata/certstream/sunlight_client.go (100.0%)</option>
				
				<option value="file21">github.com/linkdata/certstream/updatestreams.go (95.9%)</option>
				
				<option value="file22">github.com/linkdata/certstream/wraperr.go (60.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package certstream

import (
        "slices"
        "time"

        "github.com/google/certificate-transparency-go/x509"
)

type Certificate struct {
        PreCert   bool
        Seen      time.Time
        Signature []byte
        *x509.Certificate
}

func (c *Certificate) GetCommonName() (s string) <span class="cov10" title="652">{
        if s = c.Subject.CommonName; s == "" </span><span class="cov4" title="11">{
                if len(c.DNSNames) &gt; 0 </span><span class="cov4" title="9">{
                        names := slices.Clone(c.DNSNames)
                        slices.Sort(names)
                        s = c.DNSNames[0]
                }</span>
        }
        <span class="cov10" title="652">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package certstream

import (
        "context"
        "errors"
        "net/http"
        "slices"
        "strings"
        "sync"
        "time"

        "github.com/linkdata/bwlimit"
)

type CertStream struct {
        Config                       // copy of config
        C           &lt;-chan *LogEntry // log entry channel
        HeadClient  *http.Client     // main HTTP client, uses Config.HeadDialer
        TailClient  *http.Client     // may be nil if not backfilling
        tailLimiter *bwlimit.Limiter // master tail limiter, if known
        subLimiter  *bwlimit.Limiter // sub tail limiter
        mu          sync.Mutex       // protects following
        db          *PgDB
        sendEntryCh chan *LogEntry
        operators   map[string]*LogOperator // operators by operator domain, valid after Start()
}

var DefaultTransport = &amp;http.Transport{
        TLSHandshakeTimeout:   30 * time.Second,
        ResponseHeaderTimeout: 30 * time.Second,
        MaxIdleConnsPerHost:   2,
        DisableKeepAlives:     false,
        ExpectContinueTimeout: 1 * time.Second,
        ForceAttemptHTTP2:     true,
}

func (cs *CertStream) LogInfo(msg string, args ...any) <span class="cov7" title="145">{
        if cs.Config.Logger != nil </span><span class="cov7" title="109">{
                cs.Config.Logger.Info("certstream: "+msg, args...)
        }</span>
}

func (cs *CertStream) LogError(err error, msg string, args ...any) error <span class="cov9" title="472">{
        if err != nil &amp;&amp; cs.Config.Logger != nil </span><span class="cov6" title="85">{
                if !errors.Is(err, context.Canceled) &amp;&amp; !errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        if unwrapper, ok := err.(interface{ Unwrap() []error }); ok </span><span class="cov0" title="0">{
                                for _, e := range unwrapper.Unwrap() </span><span class="cov0" title="0">{
                                        cs.Config.Logger.Error("certstream: "+msg, append(args, "err", e)...)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                cs.Config.Logger.Error("certstream: "+msg, append(args, "err", err)...)
                        }</span>
                }
        }
        <span class="cov9" title="472">return err</span>
}

func (cs *CertStream) Operators() (operators []*LogOperator) <span class="cov1" title="1">{
        cs.mu.Lock()
        for _, logop := range cs.operators </span><span class="cov3" title="8">{
                operators = append(operators, logop)
        }</span>
        <span class="cov1" title="1">cs.mu.Unlock()
        slices.SortFunc(operators, func(a, b *LogOperator) int </span><span class="cov4" title="16">{ return strings.Compare(a.operator.Name, b.operator.Name) }</span>)
        <span class="cov1" title="1">return</span>
}

func (cs *CertStream) CountStreams() (n int) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, logop := range cs.operators </span><span class="cov0" title="0">{
                logop.mu.Lock()
                n += len(logop.streams)
                logop.mu.Unlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cs *CertStream) GetLogStreamByID(id int32) (ls *LogStream) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, logop := range cs.operators </span><span class="cov0" title="0">{
                if ls = logop.GetStreamByID(id); ls != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (cs *CertStream) getSendEntryCh() (ch chan *LogEntry) <span class="cov7" title="104">{
        cs.mu.Lock()
        ch = cs.sendEntryCh
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) DB() (db *PgDB) <span class="cov10" title="863">{
        cs.mu.Lock()
        db = cs.db
        cs.mu.Unlock()
        return
}</span>

func (cs *CertStream) Close() <span class="cov1" title="2">{
        cs.mu.Lock()
        seCh := cs.sendEntryCh
        cs.sendEntryCh = nil
        db := cs.db
        cs.db = nil
        cs.mu.Unlock()
        if seCh != nil </span><span class="cov1" title="1">{
                // drain
                ok := true
                for ok </span><span class="cov3" title="5">{
                        select </span>{
                        case _, ok = &lt;-seCh:<span class="cov2" title="4"></span>
                        default:<span class="cov1" title="1">
                                ok = false</span>
                        }
                }
                <span class="cov1" title="1">close(seCh)</span>
        }
        <span class="cov1" title="2">if db != nil </span><span class="cov1" title="1">{
                db.Close()
        }</span>
}

func (cs *CertStream) run(ctx context.Context, pwg *sync.WaitGroup) <span class="cov1" title="1">{
        var wg sync.WaitGroup
        ticker := time.NewTicker(time.Hour * 24)

        defer func() </span><span class="cov1" title="1">{
                ticker.Stop()
                wg.Wait()
                cs.Close()
                pwg.Done()
        }</span>()

        <span class="cov1" title="1">wg.Add(1)
        _ = cs.LogError(cs.updateStreams(ctx, &amp;wg), "CertStream:run@1")

        if db := cs.DB(); db != nil </span><span class="cov1" title="1">{
                wg.Add(3)
                go db.runWorkers(ctx, &amp;wg)
                go db.estimator(ctx, &amp;wg)
                go db.selectAllGaps(ctx, &amp;wg)
        }</span>

        <span class="cov1" title="1">for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        wg.Add(1)
                        _ = cs.LogError(cs.updateStreams(ctx, &amp;wg), "CertStream:run@2")</span>
                }
        }
}

func Start(ctx context.Context, wg *sync.WaitGroup, cfg *Config) (cs *CertStream, err error) <span class="cov1" title="1">{
        tailDialer := cfg.TailDialer
        if tailDialer == nil </span><span class="cov0" title="0">{
                tailDialer = cfg.HeadDialer
        }</span>
        <span class="cov1" title="1">subLimiter := bwlimit.NewLimiter()
        var tailLimiter *bwlimit.Limiter
        if bwdialer, ok := tailDialer.(*bwlimit.Dialer); ok </span><span class="cov1" title="1">{
                tailLimiter = bwdialer.Limiter
                subLimiter.Reads.Limit.Store(tailLimiter.Reads.Limit.Load())
        }</span>
        <span class="cov1" title="1">tailDialer = subLimiter.Wrap(tailDialer)

        tphead := DefaultTransport.Clone()
        tphead.DialContext = cfg.HeadDialer.DialContext
        tptail := DefaultTransport.Clone()
        tptail.DialContext = tailDialer.DialContext

        cs = &amp;CertStream{
                Config: *cfg,
                HeadClient: &amp;http.Client{
                        Timeout:   10 * time.Second,
                        Transport: tphead,
                },
                TailClient: &amp;http.Client{
                        Timeout:   10 * time.Second,
                        Transport: tptail,
                },
                tailLimiter: tailLimiter,
                subLimiter:  subLimiter,
                operators:   map[string]*LogOperator{},
        }

        var db *PgDB
        if db, err = NewPgDB(ctx, cs); err == nil </span><span class="cov1" title="1">{
                cs.mu.Lock()
                cs.db = db
                cs.sendEntryCh = make(chan *LogEntry, 1024*8)
                cs.C = cs.sendEntryCh
                cs.mu.Unlock()
                wg.Add(1)
                go cs.run(ctx, wg)
        }</span>

        <span class="cov1" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package certstream

import (
        "net"

        "golang.org/x/net/proxy"
)

type Config struct {
        Logger                Logger              // if not nil Logger to use, no default
        HeadDialer            proxy.ContextDialer // dialer for following the head, defaults to &amp;net.Dialer{}
        TailDialer            proxy.ContextDialer // if not nil, backfill db using this dialer, no default
        PgUser                string              // PostgreSQL user, default "certstream"
        PgPass                string              // PostgreSQL password, default "certstream"
        PgName                string              // PostgreSQL db name, default "certstream"
        PgAddr                string              // PostgreSQL address, no default
        PgPrefix              string              // PostgreSQL naming prefix, default "certdb_"
        PgConns               int                 // max number of database connections, default 100
        PgWorkerBits          int                 // number of prefix bits that determine DB workers, default 5 (32 workers)
        PgMaxAge              int                 // maximum age in days to backfill
        PgNoSSL               bool                // if true, do not use SSL
        GetEntriesParallelism int                 // number of concurrent GetRawEntries requests per range, default 8
}

// NewConfig returns a new default Config
func NewConfig() *Config <span class="cov10" title="12">{
        return &amp;Config{
                Logger:                nil,
                HeadDialer:            &amp;net.Dialer{},
                TailDialer:            nil,
                PgUser:                "certstream",
                PgPass:                "certstream",
                PgName:                "certstream",
                PgAddr:                "",
                PgPrefix:              "certdb_",
                PgConns:               100,
                PgWorkerBits:          5,
                PgMaxAge:              90,
                GetEntriesParallelism: 8,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type errLogIdle struct {
        Since time.Time
}

func (err errLogIdle) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("log idle since %v", err.Since.Round(time.Second))
}</span>

var ErrLogIdle errLogIdle
</pre>
		
		<pre class="file" id="file4" style="display: none">package certstream

import (
        "context"
        "io"
        "net/http"

        "github.com/google/certificate-transparency-go/loglist3"
)

// getLogList fetches a CT log list from the given listUrl.
// Usually you would pass loglist3.AllLogListURL for the listUrl.
func getLogList(ctx context.Context, httpClient *http.Client, listUrl string) (logList *loglist3.LogList, err error) <span class="cov10" title="2">{
        var req *http.Request
        if req, err = http.NewRequestWithContext(ctx, http.MethodGet, listUrl, nil); err == nil </span><span class="cov10" title="2">{
                var resp *http.Response
                if resp, err = httpClient.Do(req); err == nil </span><span class="cov10" title="2">{
                        var b []byte
                        if b, err = io.ReadAll(resp.Body); err == nil </span><span class="cov10" title="2">{
                                logList, err = loglist3.NewFromJSON(b)
                        }</span>
                }
        }
        <span class="cov10" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package certstream

import (
        "encoding/hex"
        "net/mail"
        "slices"
        "sort"
        "strings"
        "time"

        "golang.org/x/net/idna"
)

type hexEncoded []byte

func (h hexEncoded) MarshalText() (text []byte, err error) <span class="cov0" title="0">{
        return hex.AppendEncode(nil, h), nil
}</span>

type JsonCertificate struct {
        PreCert        bool         `json:",omitempty"`
        Signature      hexEncoded   `json:",omitempty"` // SHA256 signature, searchable on crt.sh
        Issuer         JsonIdentity `json:",omitempty"`
        Subject        JsonIdentity `json:",omitempty"`
        CommonName     string       `json:",omitempty"` // Subject common name
        DNSNames       []string     `json:",omitempty"`
        EmailAddresses []string     `json:",omitempty"`
        IPAddresses    []string     `json:",omitempty"`
        URIs           []string     `json:",omitempty"`
        NotBefore      time.Time    `json:",omitempty"`
        NotAfter       time.Time    `json:",omitempty"`
        Since          time.Time    `json:",omitzero"`
}

func NewJSONCertificate(cert *Certificate) (jsoncert *JsonCertificate) <span class="cov7" title="3">{
        jsoncert = &amp;JsonCertificate{
                PreCert:    cert.PreCert,
                Signature:  cert.Signature,
                CommonName: cert.GetCommonName(),
                NotBefore:  cert.NotBefore,
                NotAfter:   cert.NotAfter,
        }
        jsoncert.Issuer.fill(&amp;cert.Issuer)
        jsoncert.Subject.fill(&amp;cert.Subject)

        for _, dnsname := range cert.DNSNames </span><span class="cov4" title="2">{
                dnsname = strings.ToLower(dnsname)
                if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov0" title="0">{
                        jsoncert.DNSNames = append(jsoncert.DNSNames, uniname)
                }</span> else<span class="cov4" title="2"> {
                        jsoncert.DNSNames = append(jsoncert.DNSNames, dnsname)
                }</span>
        }
        <span class="cov7" title="3">sort.Strings(jsoncert.DNSNames)

        for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                jsoncert.IPAddresses = append(jsoncert.IPAddresses, ip.String())
        }</span>
        <span class="cov7" title="3">sort.Strings(jsoncert.IPAddresses)

        for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                if m, e := mail.ParseAddress(email); e == nil </span><span class="cov0" title="0">{
                        email = m.Address
                }</span>
                <span class="cov0" title="0">jsoncert.EmailAddresses = append(jsoncert.EmailAddresses, email)</span>
        }
        <span class="cov7" title="3">sort.Strings(jsoncert.EmailAddresses)

        for _, u := range cert.URIs </span><span class="cov0" title="0">{
                jsoncert.URIs = append(jsoncert.URIs, u.String())
        }</span>
        <span class="cov7" title="3">sort.Strings(jsoncert.URIs)
        return</span>
}

func (js *JsonCertificate) SetCommonName() <span class="cov10" title="5">{
        if js.CommonName == "" </span><span class="cov1" title="1">{
                if len(js.DNSNames) &gt; 0 </span><span class="cov0" title="0">{
                        names := slices.Clone(js.DNSNames)
                        slices.Sort(names)
                        js.CommonName = js.DNSNames[0]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package certstream

import (
        "strings"

        "github.com/google/certificate-transparency-go/x509/pkix"
)

type JsonIdentity struct {
        ID           int    `json:",omitempty"`
        Country      string `json:",omitempty"`
        Organization string `json:",omitempty"`
        Province     string `json:",omitempty"`
        CommonName   string `json:",omitempty"`
}

func join(l []string) string <span class="cov10" title="21">{
        var b []byte
        for _, s := range l </span><span class="cov4" title="3">{
                if s = strings.TrimSpace(s); s != "" </span><span class="cov4" title="3">{
                        if len(b) &gt; 0 </span><span class="cov0" title="0">{
                                b = append(b, ' ')
                        }</span>
                        <span class="cov4" title="3">b = append(b, s...)</span>
                }
        }
        <span class="cov10" title="21">return string(b)</span>
}

func (id *JsonIdentity) fill(name *pkix.Name) <span class="cov6" title="7">{
        if name != nil </span><span class="cov6" title="7">{
                id.Country = join(name.Country)
                id.Organization = join(name.Organization)
                id.Province = join(name.Province)
                id.CommonName = strings.TrimSpace(name.CommonName)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package certstream

import (
        "encoding/hex"
        "strconv"
        "strings"
        "time"

        "github.com/google/certificate-transparency-go/x509"
        "golang.org/x/net/idna"
)

type LogEntry struct {
        *LogStream
        Err         error // error from RawLogEntryFromLeaf or ToLogEntry, or nil
        LogIndex    int64
        PreCert     bool
        Certificate *x509.Certificate
        Id          int64 // database id, if available
        Historical  bool  // true if the entry is from gap or backfilling
        Signature   []byte
        Seen        time.Time
}

func (le *LogEntry) appendJSON(b []byte) []byte <span class="cov8" title="646">{
        if cert := le.Cert(); cert != nil </span><span class="cov8" title="646">{
                logindex := le.Index()
                var dnsnames []string
                for _, dnsname := range cert.DNSNames </span><span class="cov9" title="1187">{
                        dnsname = strings.ToLower(dnsname)
                        if uniname, err := idna.ToUnicode(dnsname); err == nil &amp;&amp; uniname != dnsname </span><span class="cov4" title="19">{
                                ok := true
                                for _, r := range uniname </span><span class="cov8" title="605">{
                                        ok = ok &amp;&amp; strconv.IsPrint(r)
                                }</span>
                                <span class="cov4" title="19">if ok </span><span class="cov4" title="19">{
                                        dnsname = uniname
                                }</span>
                        }
                        <span class="cov9" title="1187">dnsnames = append(dnsnames, dnsname)</span>
                }

                <span class="cov8" title="646">var ipaddrs []string
                for _, ip := range cert.IPAddresses </span><span class="cov0" title="0">{
                        ipaddrs = append(ipaddrs, ip.String())
                }</span>

                <span class="cov8" title="646">var emails []string
                for _, email := range cert.EmailAddresses </span><span class="cov0" title="0">{
                        emails = append(emails, strings.ReplaceAll(email, " ", "_"))
                }</span>

                <span class="cov8" title="646">var uris []string
                for _, uri := range cert.URIs </span><span class="cov0" title="0">{
                        uris = append(uris, strings.ReplaceAll(uri.String(), " ", "%20"))
                }</span>

                <span class="cov8" title="646">b = append(b, `{`...)
                b = append(b, `"iss_org":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Organization, ","))
                b = append(b, `,"iss_prov":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Province, ","))
                b = append(b, `,"iss_country":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Issuer.Country, ","))
                b = append(b, `,"sub_org":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Organization, ","))
                b = append(b, `,"sub_prov":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Province, ","))
                b = append(b, `,"sub_country":`...)
                b = strconv.AppendQuote(b, strings.Join(cert.Subject.Country, ","))
                b = append(b, `,"notbefore":"`...)
                b = append(b, cert.NotBefore.UTC().Format(time.RFC3339)...)
                b = append(b, `","notafter":"`...)
                b = append(b, cert.NotAfter.UTC().Format(time.RFC3339)...)
                b = append(b, `","commonname":`...)
                b = strconv.AppendQuote(b, cert.GetCommonName())
                b = append(b, `,"sha256_hex":"`...)
                b = append(b, hex.EncodeToString(cert.Signature)...)
                b = append(b, `","precert":`...)
                b = strconv.AppendBool(b, cert.PreCert)
                b = append(b, `,"seen":"`...)
                b = append(b, cert.Seen.UTC().Format(time.RFC3339)...)
                b = append(b, `","stream":`...)
                b = strconv.AppendInt(b, int64(le.LogStream.Id), 10)
                b = append(b, `,"logindex":`...)
                b = strconv.AppendInt(b, logindex, 10)
                b = append(b, `,"dnsnames":`...)
                b = strconv.AppendQuote(b, strings.Join(dnsnames, " "))
                b = append(b, `,"ipaddrs":`...)
                b = strconv.AppendQuote(b, strings.Join(ipaddrs, " "))
                b = append(b, `,"emails":`...)
                b = strconv.AppendQuote(b, strings.Join(emails, " "))
                b = append(b, `,"uris":`...)
                b = strconv.AppendQuote(b, strings.Join(uris, " "))
                b = append(b, `}`...)</span>
        } else<span class="cov0" title="0"> {
                b = append(b, `{}`...)
        }</span>
        <span class="cov8" title="646">return b</span>
}

func (le *LogEntry) String() (s string) <span class="cov1" title="1">{
        var b []byte
        b = append(b, "LogEntry{"...)
        if le != nil </span><span class="cov1" title="1">{
                if le.LogStream != nil </span><span class="cov0" title="0">{
                        if le.operator != nil </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, le.operator.Name)
                                b = append(b, ", "...)
                        }</span>
                        <span class="cov0" title="0">if url := le.URL(); url != "" </span><span class="cov0" title="0">{
                                b = strconv.AppendQuote(b, url)
                                b = append(b, ", "...)
                        }</span>
                }
                <span class="cov1" title="1">b = strconv.AppendInt(b, le.Index(), 10)
                if le.Err != nil </span><span class="cov0" title="0">{
                        b = append(b, ", "...)
                        b = strconv.AppendQuote(b, le.Err.Error())
                }</span>
        }
        <span class="cov1" title="1">b = append(b, '}')
        return string(b)</span>
}

// Cert returns the Certificate given a LogEntry or nil.
func (le *LogEntry) Cert() (crt *Certificate) <span class="cov10" title="2101">{
        if le != nil &amp;&amp; le.Certificate != nil </span><span class="cov9" title="2099">{
                crt = &amp;Certificate{
                        PreCert:     le.PreCert,
                        Certificate: le.Certificate,
                        Signature:   le.Signature,
                        Seen:        le.Seen,
                }
                if le.Seen.IsZero() </span><span class="cov0" title="0">{
                        crt.Seen = time.Now().UTC()
                }</span>
        }
        <span class="cov10" title="2101">return</span>
}

// Index returns the log index or -1 if none is available.
func (le *LogEntry) Index() (index int64) <span class="cov8" title="649">{
        index = -1
        if le != nil </span><span class="cov8" title="649">{
                if le.LogIndex != 0 || le.Certificate != nil || le.PreCert || le.Err != nil </span><span class="cov8" title="648">{
                        index = le.LogIndex
                }</span>
        }
        <span class="cov8" title="649">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package certstream

import (
        "context"
        "slices"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "filippo.io/sunlight"
        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
)

type LogOperator struct {
        *CertStream
        Domain   string             // e.g. "letsencrypt.org" or "googleapis.com"
        Count    atomic.Int64       // atomic; sum of the stream's Count
        Id       int32              // database ID, if available
        operator *loglist3.Operator // read-only
        mu       sync.Mutex         // protects following
        streams  map[string]*LogStream
        errcount int
        errors   []*StreamError
}

func (lo *LogOperator) Name() string <span class="cov0" title="0">{
        return lo.operator.Name
}</span>

func (lo *LogOperator) Email() []string <span class="cov0" title="0">{
        return lo.operator.Email
}</span>

func (lo *LogOperator) StreamCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = len(lo.streams)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) ErrorCount() (n int) <span class="cov0" title="0">{
        lo.mu.Lock()
        n = lo.errcount
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) Errors() (errs []*StreamError) <span class="cov0" title="0">{
        lo.mu.Lock()
        errs = append(errs, lo.errors...)
        lo.mu.Unlock()
        return
}</span>

func (lo *LogOperator) addError(ls *LogStream, err error) (errcount int) <span class="cov10" title="203">{
        if err != nil </span><span class="cov10" title="203">{
                now := time.Now()
                lo.mu.Lock()
                defer lo.mu.Unlock()
                lo.errors = append(lo.errors, &amp;StreamError{LogStream: ls, When: now, Err: err})
                if len(lo.errors) &gt; MaxErrors </span><span class="cov0" title="0">{
                        lo.errors = slices.Delete(lo.errors, 0, len(lo.errors)-MaxErrors)
                }</span>
                <span class="cov10" title="203">ls.errcount++
                errcount = ls.errcount</span>
        }
        <span class="cov10" title="203">return</span>
}

func (lo *LogOperator) Streams() (sl []*LogStream) <span class="cov4" title="8">{
        lo.mu.Lock()
        for _, s := range lo.streams </span><span class="cov7" title="61">{
                sl = append(sl, s)
        }</span>
        <span class="cov4" title="8">lo.mu.Unlock()
        slices.SortFunc(sl, func(a, b *LogStream) int </span><span class="cov9" title="151">{ return strings.Compare(a.URL(), b.URL()) }</span>)
        <span class="cov4" title="8">return</span>
}

func (lo *LogOperator) GetStreamByID(id int32) (ls *LogStream) <span class="cov0" title="0">{
        lo.mu.Lock()
        for _, ls = range lo.streams </span><span class="cov0" title="0">{
                if ls.Id == id </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">lo.mu.Unlock()
        return</span>
}

func (lo *LogOperator) makeStream(log *loglist3.Log) (ls *LogStream, err error) <span class="cov7" title="36">{
        var headLogClient *client.LogClient
        if headLogClient, err = client.New(log.URL, lo.HeadClient, jsonclient.Options{}); err == nil </span><span class="cov7" title="36">{
                var tailLogClient *client.LogClient
                if lo.TailClient != nil </span><span class="cov7" title="36">{
                        tailLogClient, err = client.New(log.URL, lo.TailClient, jsonclient.Options{})
                }</span>
                <span class="cov7" title="36">ls = &amp;LogStream{
                        LogOperator: lo,
                        log:         log,
                        headClient:  headLogClient,
                        tailClient:  tailLogClient,
                }
                ls.MinIndex.Store(-1)
                ls.MaxIndex.Store(-1)
                ls.LastIndex.Store(-1)</span>
        }
        <span class="cov7" title="36">return</span>
}

func (lo *LogOperator) ensureStream(ctx context.Context, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov7" title="36">{
        lo.mu.Lock()
        ls := lo.streams[log.URL]
        lo.mu.Unlock()
        if ls == nil </span><span class="cov7" title="36">{
                if ls, err = lo.makeStream(log); err == nil </span><span class="cov7" title="36">{
                        if db := lo.DB(); db != nil </span><span class="cov7" title="36">{
                                if err = db.ensureStream(ctx, ls); err == nil </span><span class="cov7" title="36">{
                                        lo.mu.Lock()
                                        lo.streams[log.URL] = ls
                                        lo.mu.Unlock()
                                        wg.Add(1)
                                        go ls.run(ctx, wg)
                                }</span>
                        }
                }
        }
        <span class="cov7" title="36">return</span>
}

func (lo *LogOperator) makeTiledStream(log *loglist3.TiledLog) (ls *LogStream, err error) <span class="cov6" title="26">{
        var headTile *sunlight.Client
        if headTile, err = newSunlightClient(log, lo.HeadClient, lo.Config.GetEntriesParallelism); err == nil </span><span class="cov6" title="26">{
                var tailTile *sunlight.Client
                if lo.TailClient != nil </span><span class="cov6" title="26">{
                        tailTile, err = newSunlightClient(log, lo.TailClient, lo.Config.GetEntriesParallelism)
                }</span>
                <span class="cov6" title="26">if err == nil </span><span class="cov6" title="26">{
                        ls = &amp;LogStream{
                                LogOperator: lo,
                                tiledLog:    log,
                                headTile:    headTile,
                                tailTile:    tailTile,
                        }
                        ls.MinIndex.Store(-1)
                        ls.MaxIndex.Store(-1)
                        ls.LastIndex.Store(-1)
                }</span>
        }
        <span class="cov6" title="26">return</span>
}

func (lo *LogOperator) ensureTiledStream(ctx context.Context, log *loglist3.TiledLog, wg *sync.WaitGroup) (err error) <span class="cov6" title="25">{
        lo.mu.Lock()
        ls := lo.streams[log.MonitoringURL]
        lo.mu.Unlock()
        if ls == nil </span><span class="cov6" title="25">{
                if ls, err = lo.makeTiledStream(log); err == nil </span><span class="cov6" title="25">{
                        if db := lo.DB(); db != nil </span><span class="cov6" title="25">{
                                if err = db.ensureStream(ctx, ls); err == nil </span><span class="cov6" title="25">{
                                        lo.mu.Lock()
                                        lo.streams[log.MonitoringURL] = ls
                                        lo.mu.Unlock()
                                        wg.Add(1)
                                        go ls.run(ctx, wg)
                                }</span>
                        }
                }
        }
        <span class="cov6" title="25">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package certstream

import (
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "math/rand/v2"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "filippo.io/sunlight"
        ct "github.com/google/certificate-transparency-go"
        "github.com/google/certificate-transparency-go/client"
        "github.com/google/certificate-transparency-go/jsonclient"
        "github.com/google/certificate-transparency-go/loglist3"
        "github.com/google/certificate-transparency-go/x509"
        "github.com/google/trillian/client/backoff"
)

var DbIngestBatchSize = 100    // number of entries to send to ingest at a time
var HistoricalBatchSize = 1000 // number of rows to SELECT when getting historical certificates
var FindGapsBatchSize = 10000  // logindex range to SELECT when looking for gaps
var LogBatchSize = int64(1000)
var MaxErrors = 100
var IdleCloseTime = time.Hour * 24 * 7

type handleLogEntryFn func(ctx context.Context, now time.Time, entry *LogEntry) (wanted bool)

type rawEntriesClient interface {
        GetRawEntries(ctx context.Context, start, end int64) (*ct.GetEntriesResponse, error)
}

type LogStream struct {
        *LogOperator
        Count      atomic.Int64 // number of certificates sent to the channel
        MinIndex   atomic.Int64 // atomic: lowest index seen so far, -1 if none seen yet
        MaxIndex   atomic.Int64 // atomic: highest index seen so far, -1 if none seen yet
        LastIndex  atomic.Int64 // atomic: highest index that is available from stream source
        Backfill   atomic.Int64 // atomic: number of remaining entries to backfill until we reach head
        Id         int32        // database ID, if available
        gapCh      chan gap     // protected by LogOperator.mu
        log        *loglist3.Log
        tiledLog   *loglist3.TiledLog
        headClient *client.LogClient
        tailClient *client.LogClient
        headTile   *sunlight.Client
        tailTile   *sunlight.Client
}

func (ls *LogStream) URL() string <span class="cov9" title="881">{
        if ls.log != nil </span><span class="cov8" title="511">{
                return ls.log.URL
        }</span>
        <span class="cov8" title="370">if ls.tiledLog != nil </span><span class="cov8" title="365">{
                return ls.tiledLog.MonitoringURL
        }</span>
        <span class="cov2" title="5">return ""</span>
}

func (ls *LogStream) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("LogStream{%q}", ls.URL())
}</span>

func (ls *LogStream) logInfo() any <span class="cov6" title="61">{
        if ls != nil </span><span class="cov6" title="61">{
                if ls.log != nil </span><span class="cov5" title="36">{
                        return ls.log
                }</span>
                <span class="cov4" title="25">if ls.tiledLog != nil </span><span class="cov4" title="25">{
                        return ls.tiledLog
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ls *LogStream) isTiled() bool <span class="cov8" title="331">{
        return ls != nil &amp;&amp; ls.tiledLog != nil
}</span>

func (ls *LogStream) adjustTailLimiter(historical bool) <span class="cov7" title="280">{
        if historical </span><span class="cov6" title="93">{
                if db := ls.DB(); db != nil </span><span class="cov6" title="93">{
                        if qu := db.QueueUsage(); qu &gt; 50 </span><span class="cov0" title="0">{
                                readLimit := int64(1) // 1 byte / sec
                                if ls.tailLimiter != nil </span><span class="cov0" title="0">{
                                        // set rate limit according to queue size
                                        scaleFactor := int64(50 - (qu - 50))
                                        readLimit = ls.tailLimiter.Reads.Limit.Load() * scaleFactor / 50
                                }</span>
                                <span class="cov0" title="0">ls.subLimiter.Reads.Limit.Store(readLimit)</span>
                        } else<span class="cov6" title="93"> {
                                ls.subLimiter.Reads.Limit.Store(0)
                        }</span>
                }
        }
}

func (ls *LogStream) getGapCh() (ch chan gap) <span class="cov6" title="122">{
        ls.mu.Lock()
        ch = ls.gapCh
        ls.mu.Unlock()
        return
}</span>

func sleep(ctx context.Context, d time.Duration) <span class="cov0" title="0">{
        tmr := time.NewTimer(d)
        defer tmr.Stop()
        select </span>{
        case &lt;-tmr.C:<span class="cov0" title="0"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        }
}

func (ls *LogStream) getEndSeen(ctx context.Context, end int64) (seen time.Time) <span class="cov6" title="61">{
        fn := func(ctx context.Context, now time.Time, le *LogEntry) (wanted bool) </span><span class="cov6" title="61">{
                if cert := le.Cert(); cert != nil </span><span class="cov6" title="61">{
                        seen = cert.Seen
                }</span>
                <span class="cov6" title="61">return</span>
        }
        <span class="cov6" title="61">ls.getRawEntries(ctx, end, end, false, fn, nil)
        return</span>
}

func (ls *LogStream) run(ctx context.Context, wg *sync.WaitGroup) <span class="cov6" title="61">{
        var end int64
        var err error
        var wg2 sync.WaitGroup
        defer func() </span><span class="cov6" title="61">{
                ls.addError(ls, err)
                wg2.Wait()
                ls.removeStream(ls)
                if e, ok := err.(errLogIdle); ok </span><span class="cov3" title="7">{
                        ls.LogInfo("stream stopped", "url", ls.URL(), "stream", ls.Id, "idle-since", e.Since)
                }</span> else<span class="cov5" title="54"> {
                        _ = ls.LogError(err, "stream stopped", "url", ls.URL(), "stream", ls.Id)
                }</span>
                <span class="cov6" title="61">wg.Done()</span>
        }()

        <span class="cov6" title="61">end, err = ls.newLastIndex(ctx)
        if seen := ls.getEndSeen(ctx, end); !seen.IsZero() </span><span class="cov6" title="61">{
                if time.Since(seen) &gt; IdleCloseTime </span><span class="cov3" title="7">{
                        err = errLogIdle{Since: seen}
                        return
                }</span>
        }

        <span class="cov5" title="54">start := end
        if cdb := ls.DB(); cdb != nil </span><span class="cov5" title="54">{
                if ls.CertStream.Config.TailDialer != nil </span><span class="cov5" title="54">{
                        wg2.Add(1)
                        go cdb.backfillStream(ctx, ls, &amp;wg2)
                }</span>
        }

        <span class="cov5" title="54">for err == nil </span><span class="cov5" title="54">{
                if start &lt; end </span><span class="cov0" title="0">{
                        startBefore := start
                        start, _ = ls.getRawEntries(ctx, start, end, false, ls.sendEntry, nil)
                        if end-startBefore &lt;= LogBatchSize/2 </span><span class="cov0" title="0">{
                                sleep(ctx, time.Second*time.Duration(10+rand.IntN(10) /*#nosec G404*/))
                        }</span>
                }
                <span class="cov5" title="54">end, err = ls.newLastIndex(ctx)</span>
        }
}

func (ls *LogStream) newLastIndex(ctx context.Context) (lastIndex int64, err error) <span class="cov6" title="115">{
        bo := &amp;backoff.Backoff{
                Min:    1 * time.Second,
                Max:    5 * time.Minute,
                Factor: 2,
                Jitter: true,
        }
        now := time.Now()
        lastIndex = ls.LastIndex.Load()
        err = bo.Retry(ctx, func() error </span><span class="cov7" title="216">{
                var newIndex int64
                var errFrom string
                if ls.isTiled() </span><span class="cov6" title="84">{
                        errFrom = "Checkpoint"
                        if ls.headTile != nil </span><span class="cov6" title="84">{
                                var checkpoint sunlight.Checkpoint
                                checkpoint, _, err = ls.headTile.Checkpoint(ctx)
                                if err == nil </span><span class="cov6" title="83">{
                                        newIndex = checkpoint.N - 1
                                }</span>
                        } else<span class="cov0" title="0"> {
                                err = ErrSunlightClientMissing
                        }</span>
                } else<span class="cov7" title="132"> {
                        errFrom = "GetSTH"
                        var sth *ct.SignedTreeHead
                        sth, err = ls.headClient.GetSTH(ctx)
                        if err == nil </span><span class="cov7" title="132">{
                                newIndex = int64(sth.TreeSize) - 1 //#nosec G115
                        }</span>
                }
                <span class="cov7" title="216">if err == nil </span><span class="cov7" title="215">{
                        if lastIndex &lt; newIndex </span><span class="cov6" title="114">{
                                if lastIndex+LogBatchSize &lt; newIndex || time.Since(now) &gt; time.Second*15 </span><span class="cov6" title="61">{
                                        lastIndex = newIndex
                                        ls.LastIndex.Store(lastIndex)
                                        return nil
                                }</span>
                        } else<span class="cov6" title="101"> {
                                if time.Since(now) &gt; IdleCloseTime </span><span class="cov0" title="0">{
                                        return errLogIdle{Since: now}
                                }</span>
                        }
                        <span class="cov7" title="154">return backoff.RetriableError("STH diff too low")</span>
                }
                <span class="cov1" title="1">if ls.handleStreamError(err, errFrom) </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">return backoff.RetriableError(err.Error())</span>
        })
        <span class="cov6" title="115">return</span>
}

func (ls *LogStream) seeIndex(logindex int64) <span class="cov10" title="1409">{
        if logindex &gt;= 0 </span><span class="cov10" title="1409">{
                if x := ls.MinIndex.Load(); x &gt; logindex || x == -1 </span><span class="cov6" title="73">{
                        ls.MinIndex.CompareAndSwap(x, logindex)
                }</span>
                <span class="cov10" title="1409">if x := ls.MaxIndex.Load(); x &lt; logindex || x == -1 </span><span class="cov6" title="63">{
                        ls.MaxIndex.CompareAndSwap(x, logindex)
                }</span>
        }
}

func (ls *LogStream) makeLogEntry(logindex int64, entry ct.LeafEntry, historical bool) *LogEntry <span class="cov9" title="684">{
        ctrle, leaferr := ct.RawLogEntryFromLeaf(logindex, &amp;entry)
        var ctle *ct.LogEntry
        if leaferr == nil </span><span class="cov9" title="682">{
                ctle, leaferr = ctrle.ToLogEntry()
        }</span>
        <span class="cov9" title="684">le := &amp;LogEntry{
                LogStream:  ls,
                Err:        leaferr,
                LogIndex:   logindex,
                Historical: historical,
        }
        if ctle != nil </span><span class="cov9" title="682">{
                if ctle.X509Cert != nil </span><span class="cov8" title="391">{
                        le.Certificate = ctle.X509Cert
                }</span> else<span class="cov8" title="291"> if ctle.Precert != nil </span><span class="cov8" title="291">{
                        le.PreCert = true
                        le.Certificate = ctle.Precert.TBSCertificate
                }</span>
        }
        <span class="cov9" title="684">if ctrle != nil </span><span class="cov9" title="682">{
                if len(ctrle.Cert.Data) &gt; 0 </span><span class="cov9" title="682">{
                        shasig := sha256.Sum256(ctrle.Cert.Data)
                        le.Signature = shasig[:]
                }</span>
                <span class="cov9" title="682">if tse := ctrle.Leaf.TimestampedEntry; tse != nil </span><span class="cov9" title="682">{
                        ts := int64(tse.Timestamp) //#nosec G115
                        le.Seen = time.UnixMilli(ts).UTC()
                }</span>
        }
        <span class="cov9" title="684">if len(le.Signature) == 0 &amp;&amp; le.Certificate != nil </span><span class="cov0" title="0">{
                if raw := le.Certificate.Raw; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span> else<span class="cov0" title="0"> if raw := le.Certificate.RawTBSCertificate; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span>
        }
        <span class="cov9" title="684">return le</span>
}

func (ls *LogStream) makeTileLogEntry(logindex int64, entry *sunlight.LogEntry, historical bool) (le *LogEntry) <span class="cov5" title="26">{
        le = &amp;LogEntry{
                LogStream:  ls,
                LogIndex:   logindex,
                Historical: historical,
        }
        if entry != nil </span><span class="cov5" title="26">{
                le.Seen = time.UnixMilli(entry.Timestamp).UTC()
                if entry.IsPrecert </span><span class="cov3" title="11">{
                        le.PreCert = true
                }</span>
                <span class="cov5" title="26">var cert *x509.Certificate
                var certErr error
                if entry.IsPrecert </span><span class="cov3" title="11">{
                        cert, certErr = x509.ParseTBSCertificate(entry.Certificate)
                }</span> else<span class="cov4" title="15"> {
                        cert, certErr = x509.ParseCertificate(entry.Certificate)
                }</span>
                <span class="cov5" title="26">if certErr != nil </span><span class="cov0" title="0">{
                        le.Err = certErr
                }</span>
                <span class="cov5" title="26">le.Certificate = cert
                if entry.IsPrecert &amp;&amp; len(entry.PreCertificate) &gt; 0 </span><span class="cov3" title="11">{
                        shasig := sha256.Sum256(entry.PreCertificate)
                        le.Signature = shasig[:]
                }</span> else<span class="cov4" title="15"> if len(entry.Certificate) &gt; 0 </span><span class="cov4" title="15">{
                        shasig := sha256.Sum256(entry.Certificate)
                        le.Signature = shasig[:]
                }</span>
        }
        <span class="cov5" title="26">if len(le.Signature) == 0 &amp;&amp; le.Certificate != nil </span><span class="cov0" title="0">{
                if raw := le.Certificate.Raw; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span> else<span class="cov0" title="0"> if raw := le.Certificate.RawTBSCertificate; len(raw) &gt; 0 </span><span class="cov0" title="0">{
                        shasig := sha256.Sum256(raw)
                        le.Signature = shasig[:]
                }</span>
        }
        <span class="cov5" title="26">return</span>
}

func (ls *LogStream) sendEntry(ctx context.Context, now time.Time, le *LogEntry) (wanted bool) <span class="cov9" title="646">{
        if le != nil </span><span class="cov9" title="646">{
                if cert := le.Cert(); cert != nil </span><span class="cov9" title="646">{
                        ls.seeIndex(le.LogIndex)
                        wanted = now.Before(cert.NotAfter) || now.Sub(cert.Seen) &lt; time.Hour*24*time.Duration(ls.PgMaxAge)
                        if ctx.Err() == nil </span><span class="cov9" title="646">{
                                ls.Count.Add(1)
                                ls.LogOperator.Count.Add(1)
                                if db := ls.DB(); db != nil </span><span class="cov9" title="646">{
                                        db.sendToBatcher(ctx, le)
                                }</span> else<span class="cov0" title="0"> {
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                        case ls.getSendEntryCh() &lt;- le:<span class="cov0" title="0"></span>
                                        }
                                }
                        }
                }
        }
        <span class="cov9" title="646">return</span>
}

func (ls *LogStream) handleStreamError(err error, from string) (fatal bool) <span class="cov7" title="156">{
        errTxt := err.Error()
        if errors.Is(err, context.Canceled) || strings.Contains(errTxt, "context canceled") </span><span class="cov5" title="55">{
                fatal = true
        }</span> else<span class="cov6" title="101"> if errors.Is(err, context.DeadlineExceeded) || strings.Contains(errTxt, "deadline exceeded") </span><span class="cov0" title="0">{
                fatal = false
        }</span> else<span class="cov6" title="101"> {
                statusCode := statusCodeFromError(err)
                switch statusCode </span>{
                case http.StatusTooManyRequests, http.StatusGatewayTimeout, http.StatusNotFound:<span class="cov1" title="1"></span>
                        // expected, just retry, no need to log it
                case http.StatusInternalServerError, http.StatusBadGateway:<span class="cov0" title="0">
                        fallthrough</span>
                default:<span class="cov6" title="100">
                        if ls.addError(ls, wrapErr(err, from)) &gt;= MaxErrors </span><span class="cov1" title="1">{
                                fatal = true
                        }</span>
                }
        }
        <span class="cov7" title="156">return</span>
}

func statusCodeFromError(err error) (code int) <span class="cov6" title="104">{
        if err != nil </span><span class="cov6" title="104">{
                if rspErr, isRspErr := err.(jsonclient.RspError); isRspErr </span><span class="cov1" title="1">{
                        code = rspErr.StatusCode
                }</span> else<span class="cov6" title="103"> {
                        msg := err.Error()
                        idx := strings.LastIndex(msg, "status code ")
                        if idx &gt;= 0 </span><span class="cov1" title="2">{
                                start := idx + len("status code ")
                                end := start
                                for end &lt; len(msg) </span><span class="cov3" title="6">{
                                        if msg[end] &lt; '0' || msg[end] &gt; '9' </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                        <span class="cov3" title="6">end++</span>
                                }
                                <span class="cov1" title="2">if end &gt; start </span><span class="cov1" title="2">{
                                        code, _ = strconv.Atoi(msg[start:end])
                                }</span>
                        }
                }
        }
        <span class="cov6" title="104">return</span>
}

func (ls *LogStream) getRawEntries(ctx context.Context, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool) <span class="cov6" title="115">{
        next = start
        if start &lt;= end </span><span class="cov6" title="115">{
                if ls.isTiled() </span><span class="cov5" title="47">{
                        next, wanted = ls.getTileEntries(ctx, start, end, historical, handleFn, gapcounter)
                }</span> else<span class="cov6" title="68"> {
                        client := ls.headClient
                        if historical &amp;&amp; ls.tailClient != nil </span><span class="cov5" title="32">{
                                client = ls.tailClient
                        }</span>
                        <span class="cov6" title="68">next, wanted = ls.getRawEntriesRange(ctx, client, start, end, historical, handleFn, gapcounter)</span>
                }
        }
        <span class="cov6" title="115">return</span>
}

func (ls *LogStream) getRawEntriesRange(ctx context.Context, client rawEntriesClient, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool) <span class="cov6" title="69">{
        next = start
        stop := false
        for start &lt;= end &amp;&amp; !stop </span><span class="cov7" title="186">{
                if ctx.Err() == nil </span><span class="cov7" title="186">{
                        bo := &amp;backoff.Backoff{
                                Min:    1 * time.Second,
                                Max:    30 * time.Second,
                                Factor: 2,
                                Jitter: true,
                        }
                        var resp *ct.GetEntriesResponse
                        stopIndex := start + min(LogBatchSize, end-start)
                        err := bo.Retry(ctx, func() error </span><span class="cov7" title="186">{
                                ls.adjustTailLimiter(historical)
                                var err error
                                resp, err = client.GetRawEntries(ctx, start, stopIndex)
                                return err
                        }</span>)
                        <span class="cov7" title="186">if err == nil </span><span class="cov5" title="54">{
                                now := time.Now()
                                for i := range resp.Entries </span><span class="cov9" title="684">{
                                        le := ls.makeLogEntry(start, resp.Entries[i], historical)
                                        ls.seeIndex(start)
                                        if handleFn(ctx, now, le) </span><span class="cov9" title="648">{
                                                wanted = true
                                        }</span>
                                        <span class="cov9" title="684">next = start
                                        start++
                                        if gapcounter != nil </span><span class="cov9" title="646">{
                                                gapcounter.Add(-1)
                                        }</span>
                                }
                                <span class="cov5" title="54">if historical &amp;&amp; !wanted </span><span class="cov0" title="0">{
                                        stop = true
                                }</span>
                        } else<span class="cov7" title="132"> if ls.handleStreamError(err, "GetRawEntries") </span><span class="cov5" title="33">{
                                if gapcounter != nil &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                                        _ = ls.LogError(err, "gap not fillable", "url", ls.URL(), "start", start, "end", end)
                                        gapcounter.Add(start - (end + 1))
                                }</span>
                                <span class="cov5" title="33">stop = true</span>
                        }
                } else<span class="cov0" title="0"> {
                        stop = true
                }</span>
        }
        <span class="cov6" title="69">return</span>
}

func (ls *LogStream) getTileEntries(ctx context.Context, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool) <span class="cov5" title="47">{
        next = start
        if start &lt;= end </span><span class="cov5" title="47">{
                client := ls.headTile
                if historical &amp;&amp; ls.tailTile != nil </span><span class="cov4" title="22">{
                        client = ls.tailTile
                }</span>
                <span class="cov5" title="47">if client != nil </span><span class="cov5" title="47">{
                        var checkpoint sunlight.Checkpoint
                        bo := &amp;backoff.Backoff{
                                Min:    1 * time.Second,
                                Max:    30 * time.Second,
                                Factor: 2,
                                Jitter: true,
                        }
                        var chkErr error
                        chkErr = bo.Retry(ctx, func() error </span><span class="cov5" title="47">{
                                ls.adjustTailLimiter(historical)
                                var err error
                                checkpoint, _, err = client.Checkpoint(ctx)
                                if err == nil </span><span class="cov5" title="47">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">if ls.handleStreamError(err, "Checkpoint") </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return backoff.RetriableError(err.Error())</span>
                        })
                        <span class="cov5" title="47">if chkErr == nil </span><span class="cov5" title="47">{
                                if checkpoint.N &gt; 0 </span><span class="cov5" title="47">{
                                        maxIndex := checkpoint.N - 1
                                        if end &gt; maxIndex </span><span class="cov0" title="0">{
                                                end = maxIndex
                                        }</span>
                                        <span class="cov5" title="47">if start &lt;= end </span><span class="cov5" title="47">{
                                                for start &lt;= end </span><span class="cov5" title="47">{
                                                        if ctx.Err() == nil </span><span class="cov5" title="47">{
                                                                lastIndex := int64(-1)
                                                                entryBo := &amp;backoff.Backoff{
                                                                        Min:    1 * time.Second,
                                                                        Max:    30 * time.Second,
                                                                        Factor: 2,
                                                                        Jitter: true,
                                                                }
                                                                entryErr := entryBo.Retry(ctx, func() error </span><span class="cov5" title="47">{
                                                                        lastIndex = -1
                                                                        ls.adjustTailLimiter(historical)
                                                                        now := time.Now()
                                                                        for i, entry := range client.Entries(ctx, checkpoint.Tree, start) </span><span class="cov5" title="26">{
                                                                                if i &gt; end </span><span class="cov1" title="1">{
                                                                                        break</span>
                                                                                }
                                                                                <span class="cov4" title="25">le := ls.makeTileLogEntry(i, entry, historical)
                                                                                ls.seeIndex(i)
                                                                                if handleFn(ctx, now, le) </span><span class="cov0" title="0">{
                                                                                        wanted = true
                                                                                }</span>
                                                                                <span class="cov4" title="25">lastIndex = i
                                                                                next = i
                                                                                if gapcounter != nil </span><span class="cov0" title="0">{
                                                                                        gapcounter.Add(-1)
                                                                                }</span>
                                                                        }
                                                                        <span class="cov5" title="47">err := client.Err()
                                                                        if err == nil </span><span class="cov4" title="25">{
                                                                                return nil
                                                                        }</span>
                                                                        <span class="cov4" title="22">if ls.handleStreamError(err, "Entries") </span><span class="cov4" title="22">{
                                                                                return err
                                                                        }</span>
                                                                        <span class="cov0" title="0">return backoff.RetriableError(err.Error())</span>
                                                                })
                                                                <span class="cov5" title="47">if entryErr == nil </span><span class="cov4" title="25">{
                                                                        if lastIndex &gt;= start </span><span class="cov4" title="25">{
                                                                                start = lastIndex + 1
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                start = end + 1
                                                                        }</span>
                                                                } else<span class="cov4" title="22"> if gapcounter != nil &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                                                                        if lastIndex &gt;= start </span><span class="cov0" title="0">{
                                                                                start = lastIndex + 1
                                                                        }</span>
                                                                        <span class="cov0" title="0">_ = ls.LogError(entryErr, "gap not fillable", "url", ls.URL(), "start", start, "end", end)
                                                                        gapcounter.Add(start - (end + 1))
                                                                        start = end + 1</span>
                                                                } else<span class="cov4" title="22"> {
                                                                        start = end + 1
                                                                }</span>
                                                        } else<span class="cov0" title="0"> {
                                                                start = end + 1
                                                        }</span>
                                                }
                                        }
                                }
                        } else<span class="cov0" title="0"> if gapcounter != nil &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                                _ = ls.LogError(chkErr, "gap not fillable", "url", ls.URL(), "start", start, "end", end)
                                gapcounter.Add(start - (end + 1))
                        }</span>
                }
        }
        <span class="cov5" title="47">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package certstream

import (
        "net/url"
        "strings"
)

// OperatorDomain returns the TLD+1 given an URL.
func OperatorDomain(urlString string) string <span class="cov10" title="66">{
        opDom := urlString
        if u, err := url.Parse(urlString); err == nil </span><span class="cov10" title="66">{
                opDom = u.Hostname()
                if idx := strings.LastIndexByte(opDom, '.'); idx &gt; 0 </span><span class="cov9" title="65">{
                        if idx := strings.LastIndexByte(opDom[:idx], '.'); idx &gt; 0 </span><span class="cov9" title="63">{
                                opDom = opDom[idx+1:]
                        }</span>
                }
        }
        <span class="cov10" title="66">return opDom</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package certstream

import (
        "context"
        "database/sql"
        "errors"
        "strconv"
        "sync"
        "sync/atomic"
)

var BulkRange = int64(4096)
var ErrLogEntriesTooOld = errors.New("log entries are older than max age")

type errLogEntriesTooOld struct {
        MaxAge int
}

type rawEntriesFetcher func(ctx context.Context, start, end int64, historical bool, handleFn handleLogEntryFn, gapcounter *atomic.Int64) (next int64, wanted bool)

func (e errLogEntriesTooOld) Error() string <span class="cov0" title="0">{
        return "log entries are older than " + strconv.Itoa(e.MaxAge) + " days"
}</span>

func (e errLogEntriesTooOld) Unwrap() error <span class="cov0" title="0">{
        return ErrLogEntriesTooOld
}</span>

func (cdb *PgDB) backfillGapsWithFetcher(ctx context.Context, ls *LogStream, fetchFn rawEntriesFetcher) <span class="cov9" title="55">{
        var lastgap gap
        if cdb != nil &amp;&amp; ls != nil </span><span class="cov9" title="55">{
                if lastindex := ls.LastIndex.Load(); lastindex != -1 </span><span class="cov9" title="54">{
                        row := cdb.QueryRow(ctx, cdb.stmtSelectMaxIdx, ls.Id)
                        var nullableMaxIndex sql.NullInt64
                        if err := row.Scan(&amp;nullableMaxIndex); cdb.LogError(err, "backfillGaps/MaxIndex", "url", ls.URL()) == nil </span><span class="cov9" title="54">{
                                if nullableMaxIndex.Valid </span><span class="cov0" title="0">{
                                        ls.seeIndex(nullableMaxIndex.Int64)
                                        if nullableMaxIndex.Int64 &lt; lastindex </span><span class="cov0" title="0">{
                                                lastgap = gap{start: nullableMaxIndex.Int64 + 1, end: lastindex}
                                        }</span>
                                }
                        }
                }
                <span class="cov9" title="55">if gapCh := ls.getGapCh(); gapCh != nil </span><span class="cov7" title="22">{
                        fillGap := func(label string, g gap) </span><span class="cov1" title="1">{
                                if ctx.Err() == nil </span><span class="cov1" title="1">{
                                        ls.Backfill.Add((g.end - g.start) + 1)
                                        cdb.LogInfo(label, "url", ls.URL(), "stream", ls.Id, "logindex", g.start, "length", (g.end-g.start)+1)
                                        fetchFn(ctx, g.start, g.end, true, ls.sendEntry, &amp;ls.Backfill)
                                        if ctx.Err() == nil </span><span class="cov1" title="1">{
                                                _ = cdb.updateBackfillIndex(ctx, ls, g.start)
                                        }</span>
                                }
                        }
                        <span class="cov7" title="22">for gap := range gapCh </span><span class="cov1" title="1">{
                                fillGap("gap", gap)
                        }</span>
                        <span class="cov7" title="22">if lastgap.end != 0 &amp;&amp; ctx.Err() == nil </span><span class="cov0" title="0">{
                                fillGap("last gap", lastgap)
                        }</span>
                }
        }
}

func (cdb *PgDB) backfillStartIndex(ctx context.Context, ls *LogStream) (minIndex int64, stored bool, err error) <span class="cov9" title="56">{
        minIndex = -1
        if cdb != nil &amp;&amp; ls != nil </span><span class="cov9" title="56">{
                var storedIndex int64
                row := cdb.QueryRow(ctx, cdb.stmtSelectBackfillIdx, ls.Id)
                if err = cdb.LogError(row.Scan(&amp;storedIndex), "Backfill/StoredIndex", "url", ls.URL()); err == nil </span><span class="cov9" title="56">{
                        if storedIndex &gt; 0 </span><span class="cov1" title="1">{
                                minIndex = storedIndex
                                stored = true
                        }</span> else<span class="cov9" title="55"> {
                                var minIndexRow sql.NullInt64
                                row = cdb.QueryRow(ctx, cdb.stmtSelectMinIdx, ls.Id)
                                if err = cdb.LogError(row.Scan(&amp;minIndexRow), "Backfill/MinIndex", "url", ls.URL()); err == nil </span><span class="cov9" title="55">{
                                        if minIndexRow.Valid </span><span class="cov1" title="1">{
                                                minIndex = minIndexRow.Int64
                                        }</span> else<span class="cov9" title="54"> {
                                                minIndex = ls.LastIndex.Load()
                                        }</span>
                                }
                        }
                        <span class="cov9" title="56">if err == nil </span><span class="cov9" title="56">{
                                if lastIndex := ls.LastIndex.Load(); lastIndex &gt;= 0 &amp;&amp; minIndex &gt; lastIndex </span><span class="cov0" title="0">{
                                        minIndex = lastIndex
                                }</span>
                        }
                }
        }
        <span class="cov9" title="56">return</span>
}

func (cdb *PgDB) updateBackfillIndex(ctx context.Context, ls *LogStream, logindex int64) (err error) <span class="cov10" title="66">{
        if cdb != nil &amp;&amp; ls != nil </span><span class="cov10" title="66">{
                if ctx.Err() == nil </span><span class="cov10" title="66">{
                        if logindex &gt;= 0 </span><span class="cov10" title="66">{
                                _, err = cdb.Exec(ctx, cdb.stmtUpdateBackfillIdx, logindex, ls.Id)
                                err = cdb.LogError(err, "Backfill/UpdateIndex", "url", ls.URL(), "stream", ls.Id, "logindex", logindex)
                        }</span>
                }
        }
        <span class="cov10" title="66">return</span>
}

func (cdb *PgDB) backfillStream(ctx context.Context, ls *LogStream, wg *sync.WaitGroup) <span class="cov9" title="54">{
        defer wg.Done()
        var minIndex int64
        var stored bool
        var err error
        if minIndex, stored, err = cdb.backfillStartIndex(ctx, ls); err == nil </span><span class="cov9" title="54">{
                if !stored </span><span class="cov9" title="54">{
                        _ = cdb.updateBackfillIndex(ctx, ls, minIndex)
                }</span>
                <span class="cov9" title="54">ls.seeIndex(minIndex)
                cdb.backfillGapsWithFetcher(ctx, ls, ls.getRawEntries)
                if minIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov9" title="54">{
                        cdb.LogInfo("backlog start", "url", ls.URL(), "stream", ls.Id, "logindex", minIndex)
                        ls.Backfill.Add(minIndex - 1)
                        for minIndex &gt; 0 &amp;&amp; ctx.Err() == nil </span><span class="cov9" title="54">{
                                start := max(0, minIndex-BulkRange)
                                stop := minIndex - 1
                                minIndex = start
                                var wanted bool
                                if _, wanted = ls.getRawEntries(ctx, start, stop, true, ls.sendEntry, &amp;ls.Backfill); !wanted </span><span class="cov9" title="42">{
                                        cdb.LogInfo("backlog stops", "url", ls.URL(), "stream", ls.Id, "logindex", minIndex)
                                        ls.addError(ls, errLogEntriesTooOld{MaxAge: cdb.PgMaxAge})
                                        ls.Backfill.Store(0)
                                        break</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package certstream

import (
        "context"
        "sync"
        "time"

        "github.com/jackc/pgx/v5/pgconn"
)

func (cdb *PgDB) runBatch(ctx context.Context, queued []*LogEntry) (err error) <span class="cov4" title="47">{
        var b []byte
        b = append(b, `[`...)
        for i, le := range queued </span><span class="cov6" title="646">{
                if i &gt; 0 </span><span class="cov6" title="599">{
                        b = append(b, `,`...)
                }</span>
                <span class="cov6" title="646">b = le.appendJSON(b)</span>
        }
        <span class="cov4" title="47">b = append(b, `]`...)
        now := time.Now()
        _, err = cdb.Exec(ctx, cdb.funcIngestBatch, string(b))
        elapsed := time.Since(now)
        if err != nil </span><span class="cov3" title="31">{
                if pe, ok := err.(*pgconn.PgError); ok </span><span class="cov0" title="0">{
                        if pe.SQLState() == "22P02" </span><span class="cov0" title="0">{
                                cdb.LogInfo("generated invalid JSON data", "json", string(b))
                        }</span>
                }
        }
        <span class="cov4" title="47">cdb.mu.Lock()
        cdb.newentrycount += int64(len(queued))
        cdb.newentrytime += elapsed
        cdb.mu.Unlock()
        return</span>
}

func (cdb *PgDB) worker(ctx context.Context, wg *sync.WaitGroup, workerID int) <span class="cov3" title="32">{
        defer wg.Done()
        if batchCh := cdb.getBatchCh(workerID); batchCh != nil </span><span class="cov3" title="32">{
                cdb.Workers.Add(1)
                defer cdb.Workers.Add(-1)
                const tickerInterval = time.Second * 10
                staggerInterval := tickerInterval / time.Duration(cdb.workerCount)
                tckr := time.NewTicker(1 + (staggerInterval * time.Duration(workerID)))
                stop := false
                var queued []*LogEntry
                for !stop </span><span class="cov6" title="700">{
                        ticked := false
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov3" title="32">
                                stop = true</span>
                        case &lt;-tckr.C:<span class="cov3" title="22">
                                ticked = true
                                if staggerInterval != 0 </span><span class="cov3" title="22">{
                                        staggerInterval = 0
                                        tckr.Stop()
                                        tckr = time.NewTicker(tickerInterval)
                                        defer tckr.Stop()
                                }</span>
                        case le := &lt;-batchCh:<span class="cov6" title="646">
                                queued = append(queued, le)</span>
                        }
                        <span class="cov6" title="700">if l := len(queued); l &gt; 0 &amp;&amp; (l &gt;= DbIngestBatchSize || ticked || stop) </span><span class="cov4" title="47">{
                                _ = cdb.LogError(cdb.runBatch(ctx, queued), "runBatch")
                                for _, le := range queued </span><span class="cov6" title="646">{
                                        if !stop </span><span class="cov4" title="104">{
                                                select </span>{
                                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                                        stop = true</span>
                                                case cdb.getSendEntryCh() &lt;- le:<span class="cov4" title="104"></span>
                                                }
                                        }
                                }
                                <span class="cov4" title="47">clear(queued)
                                queued = queued[:0]</span>
                        }
                }
        }
}

func (cdb *PgDB) AverageNewEntryTime() (d time.Duration) <span class="cov0" title="0">{
        cdb.mu.Lock()
        d = cdb.avgentrytime
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) runWorkers(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        const interval = time.Millisecond * 100
        defer func() </span><span class="cov1" title="1">{
                wg.Done()
        }</span>()

        <span class="cov1" title="1">wg.Add(cdb.workerCount)
        for i := 0; i &lt; cdb.workerCount; i++ </span><span class="cov3" title="32">{
                go cdb.worker(ctx, wg, i)
        }</span>

        <span class="cov1" title="1">ticks := 0
        ticker := time.NewTicker(interval)
        avgentrytimes := make([]time.Duration, time.Minute/interval)
        defer ticker.Stop()
        for </span><span class="cov4" title="66">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov4" title="65">
                        cdb.mu.Lock()
                        avgentrytime := cdb.newentrytime
                        if d := time.Duration(cdb.newentrycount); d &gt; 0 </span><span class="cov3" title="15">{
                                avgentrytime /= d
                        }</span>
                        <span class="cov4" title="65">cdb.newentrytime = 0
                        cdb.newentrycount = 0
                        avgentrytimes[ticks] = avgentrytime
                        ticks++
                        if ticks &gt;= cap(avgentrytimes) </span><span class="cov0" title="0">{
                                ticks = 0
                        }</span>
                        <span class="cov4" title="65">avgentrytime = 0
                        for _, d := range avgentrytimes </span><span class="cov10" title="39000">{
                                avgentrytime += d
                        }</span>
                        <span class="cov4" title="65">cdb.avgentrytime = avgentrytime / time.Duration(cap(avgentrytimes))
                        cdb.mu.Unlock()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package certstream

import (
        "time"
)

type PgCertificate struct {
        Id         int64
        NotBefore  time.Time
        NotAfter   time.Time
        CommonName string
        SubjectID  int
        IssuerID   int
        Sha256     []byte
        PreCert    bool
        Since      time.Time
}

func ScanCertificate(row Scanner, cert *PgCertificate) (err error) <span class="cov10" title="2">{
        var p_since *time.Time
        if err = row.Scan(
                &amp;cert.Id,
                &amp;cert.NotBefore,
                &amp;cert.NotAfter,
                &amp;cert.CommonName,
                &amp;cert.SubjectID,
                &amp;cert.IssuerID,
                &amp;cert.Sha256,
                &amp;cert.PreCert,
                &amp;p_since,
        ); err == nil </span><span class="cov10" title="2">{
                if p_since != nil </span><span class="cov10" title="2">{
                        cert.Since = *p_since
                }</span>
        }
        <span class="cov10" title="2">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package certstream

import (
        "context"
        "database/sql"
        _ "embed"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Scanner interface {
        Scan(dest ...any) error
}

type gap struct {
        start int64
        end   int64
}

// PgDB integrates with sql.DB to manage certificate stream data for a PostgreSQL database
type PgDB struct {
        *CertStream
        *pgxpool.Pool
        Pfx                   func(string) string // prefix replacer
        Workers               atomic.Int32
        funcOperatorID        string
        funcStreamID          string
        funcIngestBatch       string
        stmtSelectAllGaps     string
        stmtSelectMinIdx      string
        stmtSelectMaxIdx      string
        stmtSelectBackfillIdx string
        stmtUpdateBackfillIdx string
        mu                    sync.Mutex // protects following
        batchCh               []chan *LogEntry
        workerBits            int
        workerCount           int
        estimates             map[string]float64 // row count estimates
        newentrytime          time.Duration
        newentrycount         int64
        avgentrytime          time.Duration
}

func ensureSchema(ctx context.Context, db *pgxpool.Pool, pfx func(string) string) (err error) <span class="cov3" title="12">{
        if _, err = db.Exec(ctx, pfx(CreateSchema)); err == nil </span><span class="cov3" title="12">{
                if _, err = db.Exec(ctx, pfx(FunctionOperatorID)); err == nil </span><span class="cov3" title="12">{
                        if _, err = db.Exec(ctx, pfx(FunctionStreamID)); err == nil </span><span class="cov3" title="12">{
                                _, err = db.Exec(ctx, pfx(FuncIngestBatch))
                        }</span>
                }
        }
        <span class="cov3" title="12">return</span>
}

// NewPgDB creates a PgDB and creates the needed tables and indices if they don't exist.
func NewPgDB(ctx context.Context, cs *CertStream) (cdb *PgDB, err error) <span class="cov3" title="12">{
        const callOperatorID = `SELECT CERTDB_operator_id($1,$2);`
        const callStreamID = `SELECT CERTDB_stream_id($1,$2,$3);`

        if cs.Config.PgAddr != "" </span><span class="cov3" title="12">{
                dsn := fmt.Sprintf("postgres://%s:%s@%s/%s?pool_max_conns=%d&amp;pool_max_conn_idle_time=1m",
                        cs.Config.PgUser, cs.Config.PgPass, cs.Config.PgAddr, cs.Config.PgName, cs.Config.PgConns)
                if cs.Config.PgNoSSL </span><span class="cov3" title="12">{
                        dsn += "&amp;sslmode=disable"
                }</span>
                <span class="cov3" title="12">var poolcfg *pgxpool.Config
                if poolcfg, err = pgxpool.ParseConfig(dsn); err == nil </span><span class="cov3" title="12">{
                        poolcfg.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeSimpleProtocol
                        var pool *pgxpool.Pool
                        if pool, err = pgxpool.NewWithConfig(ctx, poolcfg); err == nil </span><span class="cov3" title="12">{
                                if err = pool.Ping(ctx); err == nil </span><span class="cov3" title="12">{
                                        cs.LogInfo("database", "addr", cs.Config.PgAddr, "name", cs.Config.PgName, "prefix", cs.Config.PgPrefix)
                                        pfx := func(s string) string </span><span class="cov7" title="302">{ return strings.ReplaceAll(s, "CERTDB_", cs.Config.PgPrefix) }</span>
                                        <span class="cov3" title="12">if err = ensureSchema(ctx, pool, pfx); err == nil </span><span class="cov3" title="12">{
                                                var pgversion string
                                                if cs.LogError(pool.QueryRow(ctx, `SELECT version();`).Scan(&amp;pgversion), "postgres version") == nil </span><span class="cov3" title="12">{
                                                        cs.LogInfo("postgres", "version", pgversion)
                                                }</span>
                                                <span class="cov3" title="12">workerBits := min(8, max(1, cs.Config.PgWorkerBits))
                                                workerCount := 1 &lt;&lt; workerBits
                                                batchChans := make([]chan *LogEntry, workerCount)
                                                for i := range batchChans </span><span class="cov7" title="384">{
                                                        batchChans[i] = make(chan *LogEntry, (DbIngestBatchSize*12)/10)
                                                }</span>
                                                <span class="cov3" title="12">cdb = &amp;PgDB{
                                                        CertStream:            cs,
                                                        Pool:                  pool,
                                                        Pfx:                   pfx,
                                                        funcOperatorID:        pfx(callOperatorID),
                                                        funcStreamID:          pfx(callStreamID),
                                                        funcIngestBatch:       pfx(`SELECT CERTDB_ingest_batch($1::jsonb);`),
                                                        stmtSelectAllGaps:     pfx(SelectAllGaps),
                                                        stmtSelectMinIdx:      pfx(SelectMinIndex),
                                                        stmtSelectMaxIdx:      pfx(SelectMaxIndex),
                                                        stmtSelectBackfillIdx: pfx(SelectBackfillIndex),
                                                        stmtUpdateBackfillIdx: pfx(UpdateBackfillIndex),
                                                        batchCh:               batchChans,
                                                        workerBits:            workerBits,
                                                        workerCount:           workerCount,
                                                        estimates: map[string]float64{
                                                                "cert":   0,
                                                                "domain": 0,
                                                                "entry":  0,
                                                        },
                                                }
                                                cdb.refreshEstimates(ctx)</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov3" title="12">if cdb != nil </span><span class="cov3" title="12">{
                cs.LogInfo("database workers", "count", cdb.workerCount, "bits", cdb.workerBits)
        }</span>
        <span class="cov3" title="12">return</span>
}

func (cdb *PgDB) Close() <span class="cov3" title="12">{
        cdb.mu.Lock()
        chans := cdb.batchCh
        cdb.batchCh = nil
        cdb.mu.Unlock()
        for _, ch := range chans </span><span class="cov7" title="384">{
                if ch != nil </span><span class="cov7" title="384">{
                        close(ch)
                }</span>
        }
        <span class="cov3" title="12">cdb.Pool.Close()</span>
}

func (cdb *PgDB) QueueUsage() (pct int) <span class="cov6" title="93">{
        cdb.mu.Lock()
        chans := cdb.batchCh
        cdb.mu.Unlock()
        totalLen := 0
        totalCap := 0
        for _, ch := range chans </span><span class="cov10" title="2976">{
                if ch != nil </span><span class="cov10" title="2976">{
                        totalLen += len(ch)
                        totalCap += cap(ch)
                }</span>
        }
        <span class="cov6" title="93">if totalCap &gt; 0 </span><span class="cov6" title="93">{
                pct = totalLen * 100 / totalCap
        }</span>
        <span class="cov6" title="93">return</span>
}

func (cdb *PgDB) getBatchCh(idx int) (ch chan *LogEntry) <span class="cov8" title="678">{
        cdb.mu.Lock()
        ch = cdb.batchCh[idx]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) workerIndexFor(le *LogEntry) (idx int) <span class="cov8" title="646">{
        if cdb != nil &amp;&amp; le != nil </span><span class="cov8" title="646">{
                if cert := le.Cert(); cert != nil &amp;&amp; len(cert.Signature) &gt; 0 </span><span class="cov8" title="646">{
                        idx = int(cert.Signature[0] &gt;&gt; (8 - cdb.workerBits))
                }</span>
        }
        <span class="cov8" title="646">return</span>
}

func (cdb *PgDB) sendToBatcher(ctx context.Context, le *LogEntry) <span class="cov8" title="646">{
        if le != nil &amp;&amp; ctx.Err() == nil </span><span class="cov8" title="646">{
                if ch := cdb.getBatchCh(cdb.workerIndexFor(le)); ch != nil </span><span class="cov8" title="646">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        case ch &lt;- le:<span class="cov8" title="646"></span>
                        }
                }
        }
}

func (cdb *PgDB) ensureOperator(ctx context.Context, lo *LogOperator) (err error) <span class="cov3" title="8">{
        if cdb != nil </span><span class="cov3" title="8">{
                row := cdb.QueryRow(ctx, cdb.funcOperatorID, lo.operator.Name, strings.Join(lo.operator.Email, ","))
                err = wrapErr(row.Scan(&amp;lo.Id), cdb.funcOperatorID)
        }</span>
        <span class="cov3" title="8">return</span>
}

func (cdb *PgDB) ensureStream(ctx context.Context, ls *LogStream) (err error) <span class="cov5" title="61">{
        if cdb != nil </span><span class="cov5" title="61">{
                var b []byte
                if b, err = json.Marshal(ls.logInfo()); err == nil </span><span class="cov5" title="61">{
                        row := cdb.QueryRow(ctx, cdb.funcStreamID, ls.URL(), ls.LogOperator.Id, string(b))
                        err = wrapErr(row.Scan(&amp;ls.Id), cdb.funcStreamID)
                }</span>
        }
        <span class="cov5" title="61">return</span>
}

func (cdb *PgDB) fillIdentity(ctx context.Context, id int, ident *JsonIdentity) <span class="cov2" title="4">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT id, organization, province, country FROM CERTDB_ident WHERE id=$1;`), id)
        var dbident PgIdent
        if err := cdb.LogError(ScanIdent(row, &amp;dbident), "fillIdentity", "id", id); err == nil </span><span class="cov2" title="4">{
                ident.ID = id
                ident.Country = dbident.Country
                ident.Organization = dbident.Organization
                ident.Province = dbident.Province
        }</span>
}

func (cdb *PgDB) getCertStrings(ctx context.Context, id int64, tablename, colname string) (sl []string) <span class="cov3" title="8">{
        rows, err := cdb.Query(ctx, cdb.Pfx(fmt.Sprintf("SELECT %s::text FROM CERTDB_%s WHERE cert=$1;", colname, tablename)), id)
        if cdb.LogError(err, "getCertStrings/"+tablename, "id", id) == nil </span><span class="cov3" title="8">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var s string
                        if err := cdb.LogError(rows.Scan(&amp;s), "getCertStrings/scan/"+tablename); err == nil </span><span class="cov0" title="0">{
                                sl = append(sl, s)
                        }</span>
                }
        }
        <span class="cov3" title="8">return</span>
}

func (cdb *PgDB) getCertificate(ctx context.Context, dbcert *PgCertificate) (cert *JsonCertificate, err error) <span class="cov1" title="2">{
        cert = &amp;JsonCertificate{
                PreCert:        dbcert.PreCert,
                Signature:      dbcert.Sha256,
                CommonName:     dbcert.CommonName,
                DNSNames:       []string{},
                EmailAddresses: []string{},
                IPAddresses:    []string{},
                URIs:           []string{},
                NotBefore:      dbcert.NotBefore,
                NotAfter:       dbcert.NotAfter,
                Since:          dbcert.Since,
        }
        cdb.fillIdentity(ctx, dbcert.IssuerID, &amp;cert.Issuer)
        cdb.fillIdentity(ctx, dbcert.SubjectID, &amp;cert.Subject)
        cert.Subject.CommonName = dbcert.CommonName
        cert.DNSNames = cdb.getCertStrings(ctx, dbcert.Id, "dnsnames", "fqdn")
        cert.EmailAddresses = cdb.getCertStrings(ctx, dbcert.Id, "email", "email")
        cert.IPAddresses = cdb.getCertStrings(ctx, dbcert.Id, "ipaddress", "addr")
        for i := range cert.IPAddresses </span><span class="cov0" title="0">{
                cert.IPAddresses[i] = strings.TrimSuffix(cert.IPAddresses[i], "/32")
        }</span>
        <span class="cov1" title="2">cert.URIs = cdb.getCertStrings(ctx, dbcert.Id, "uri", "uri")
        cert.SetCommonName()
        return</span>
}

func (cdb *PgDB) GetCertificateByLogEntry(ctx context.Context, entry *PgLogEntry) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        return cdb.GetCertificateByID(ctx, entry.CertID)
}</span>

func RenderSQL(query string, args ...any) string <span class="cov0" title="0">{
        for i, arg := range args </span><span class="cov0" title="0">{
                var s string
                switch v := arg.(type) </span>{
                case string:<span class="cov0" title="0">
                        s = fmt.Sprintf("'%s'", strings.ReplaceAll(v, "'", "''"))</span>
                case time.Time:<span class="cov0" title="0">
                        s = fmt.Sprintf("'%s'", v.Format(time.RFC3339))</span>
                default:<span class="cov0" title="0">
                        s = fmt.Sprint(v)</span>
                }
                <span class="cov0" title="0">query = strings.ReplaceAll(query, fmt.Sprintf("$%d", i+1), s)</span>
        }
        <span class="cov0" title="0">return query</span>
}

func (cdb *PgDB) GetCertificatesByCommonName(ctx context.Context, commonname string) (certs []*JsonCertificate, err error) <span class="cov0" title="0">{
        var rows pgx.Rows
        if rows, err = cdb.Query(ctx, cdb.Pfx(`SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since FROM CERTDB_cert WHERE commonname=$1 ORDER BY notbefore DESC;`), commonname); err == nil </span><span class="cov0" title="0">{
                defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        var dbcert PgCertificate
                        e := ScanCertificate(rows, &amp;dbcert)
                        if e == nil </span><span class="cov0" title="0">{
                                var cert *JsonCertificate
                                if cert, e = cdb.getCertificate(ctx, &amp;dbcert); e == nil </span><span class="cov0" title="0">{
                                        certs = append(certs, cert)
                                }</span>
                        }
                        <span class="cov0" title="0">err = errors.Join(err, e)</span>
                }
                <span class="cov0" title="0">err = errors.Join(err, rows.Err())</span>
        }
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByHash(ctx context.Context, hash []byte) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since FROM CERTDB_cert WHERE sha256=$1;`), hash)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetCertificateByID(ctx context.Context, id int64) (cert *JsonCertificate, err error) <span class="cov0" title="0">{
        row := cdb.QueryRow(ctx, cdb.Pfx(`SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since FROM CERTDB_cert WHERE id=$1;`), id)
        var dbcert PgCertificate
        if err = ScanCertificate(row, &amp;dbcert); err == nil </span><span class="cov0" title="0">{
                cert, err = cdb.getCertificate(ctx, &amp;dbcert)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (cdb *PgDB) GetHistoricalCertificates(ctx context.Context, expiresAfter time.Time, callback func(ctx context.Context, cert *JsonCertificate) (err error)) (err error) <span class="cov1" title="1">{
        if cdb != nil </span><span class="cov1" title="1">{
                expiresAfter = expiresAfter.UTC()
                var maxNotAfter *time.Time
                if err = cdb.QueryRow(ctx, cdb.Pfx(`SELECT MAX(notafter) FROM CERTDB_cert;`)).Scan(&amp;maxNotAfter); err == nil </span><span class="cov1" title="1">{
                        if maxNotAfter != nil </span><span class="cov1" title="1">{
                                maxAtStart := maxNotAfter.UTC()
                                lastNotAfter := expiresAfter
                                lastID := int64(0)
                                query := cdb.Pfx(`
SELECT id, notbefore, notafter, commonname, subject, issuer, sha256, precert, since
FROM CERTDB_cert
WHERE notafter &gt; $1
  AND notafter &lt;= $2
  AND (notafter &gt; $3 OR (notafter = $3 AND id &gt; $4))
ORDER BY notafter ASC, id ASC
LIMIT $5;
`)
                                for err == nil </span><span class="cov1" title="2">{
                                        var rows pgx.Rows
                                        if rows, err = cdb.Query(ctx, query, expiresAfter, maxAtStart, lastNotAfter, lastID, max(100, HistoricalBatchSize)); err == nil </span><span class="cov1" title="2">{
                                                var dbcerts []PgCertificate
                                                for rows.Next() &amp;&amp; err == nil </span><span class="cov1" title="2">{
                                                        var dbcert PgCertificate
                                                        if err = ScanCertificate(rows, &amp;dbcert); err == nil </span><span class="cov1" title="2">{
                                                                dbcerts = append(dbcerts, dbcert)
                                                        }</span>
                                                }
                                                <span class="cov1" title="2">if err == nil </span><span class="cov1" title="2">{
                                                        err = rows.Err()
                                                }</span>
                                                <span class="cov1" title="2">rows.Close()
                                                if err == nil </span><span class="cov1" title="2">{
                                                        if len(dbcerts) == 0 </span><span class="cov1" title="1">{
                                                                break</span>
                                                        }
                                                        <span class="cov1" title="1">for i := range dbcerts </span><span class="cov1" title="2">{
                                                                if err == nil </span><span class="cov1" title="2">{
                                                                        dbcert := dbcerts[i]
                                                                        var cert *JsonCertificate
                                                                        if cert, err = cdb.getCertificate(ctx, &amp;dbcert); err == nil </span><span class="cov1" title="2">{
                                                                                if err = callback(ctx, cert); err == nil </span><span class="cov1" title="2">{
                                                                                        lastNotAfter = dbcert.NotAfter
                                                                                        lastID = dbcert.Id
                                                                                }</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

func (cdb *PgDB) DeleteCertificates(ctx context.Context, cutoff time.Time, batchSize int) (rowsDeleted int64, err error) <span class="cov2" title="3">{
        if cdb != nil </span><span class="cov2" title="3">{
                if batchSize &gt; 0 </span><span class="cov2" title="3">{
                        cutoff = cutoff.UTC()
                        query := cdb.Pfx(`WITH todelete AS (
  SELECT ctid
  FROM CERTDB_cert
  WHERE notafter &lt;= $1
  ORDER BY notafter DESC
  LIMIT $2
)
DELETE FROM CERTDB_cert
USING todelete
WHERE CERTDB_cert.ctid = todelete.ctid;`)
                        var tag pgconn.CommandTag
                        if tag, err = cdb.Exec(ctx, query, cutoff, batchSize); err == nil </span><span class="cov2" title="3">{
                                rowsDeleted = tag.RowsAffected()
                        }</span>
                }
        }
        <span class="cov2" title="3">return</span>
}

func (cdb *PgDB) DeleteStream(ctx context.Context, streamId int32, batchSize int) (rowsDeleted int64, err error) <span class="cov2" title="4">{
        if cdb != nil </span><span class="cov2" title="4">{
                if batchSize &gt; 0 </span><span class="cov2" title="4">{
                        query := cdb.Pfx(`WITH todelete AS (
  SELECT logindex
  FROM CERTDB_entry
  WHERE stream = $1
  ORDER BY logindex ASC
  LIMIT $2
)
DELETE FROM CERTDB_entry
USING todelete
WHERE CERTDB_entry.stream = $1
  AND CERTDB_entry.logindex = todelete.logindex;`)
                        var tag pgconn.CommandTag
                        if tag, err = cdb.Exec(ctx, query, streamId, batchSize); err == nil </span><span class="cov2" title="4">{
                                rowsDeleted = tag.RowsAffected()
                                if rowsDeleted == 0 </span><span class="cov1" title="2">{
                                        if tag, err = cdb.Exec(ctx, cdb.Pfx(`DELETE FROM CERTDB_stream WHERE id = $1;`), streamId); err == nil </span><span class="cov1" title="2">{
                                                rowsDeleted = tag.RowsAffected()
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov2" title="4">return</span>
}

func (cdb *PgDB) Estimate(table string) (f float64) <span class="cov0" title="0">{
        table = strings.TrimPrefix(table, "CERTDB_")
        table = strings.TrimPrefix(table, cdb.CertStream.Config.PgPrefix)
        cdb.mu.Lock()
        f = cdb.estimates[table]
        cdb.mu.Unlock()
        return
}</span>

func (cdb *PgDB) refreshEstimatesBatch() (batch *pgx.Batch) <span class="cov3" title="12">{
        batch = &amp;pgx.Batch{}
        cdb.mu.Lock()
        defer cdb.mu.Unlock()
        for k := range cdb.estimates </span><span class="cov5" title="36">{
                table := cdb.Pfx("CERTDB_" + k)
                batch.Queue(SelectEstimate, table).QueryRow(func(row pgx.Row) error </span><span class="cov5" title="36">{
                        var estimate float64
                        if cdb.LogError(row.Scan(&amp;estimate), "refreshEstimates", "table", table) == nil </span><span class="cov5" title="36">{
                                cdb.mu.Lock()
                                cdb.estimates[k] = estimate
                                cdb.mu.Unlock()
                        }</span>
                        <span class="cov5" title="36">return nil</span>
                })
        }
        <span class="cov3" title="12">return</span>
}

func (cdb *PgDB) refreshEstimates(ctx context.Context) <span class="cov3" title="12">{
        if batch := cdb.refreshEstimatesBatch(); batch != nil </span><span class="cov3" title="12">{
                ctx, cancel := context.WithTimeout(ctx, time.Minute)
                defer cancel()
                _ = cdb.LogError(cdb.SendBatch(ctx, batch).Close(), "refreshEstimates")
        }</span>
}

func (cdb *PgDB) estimator(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="1">{
        defer wg.Done()
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()
        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cdb.refreshEstimates(ctx)</span>
                }
        }
}

type gapTotals struct {
        count atomic.Int64
        size  atomic.Int64
}

func (gt *gapTotals) add(g gap) <span class="cov1" title="2">{
        if gt != nil </span><span class="cov1" title="2">{
                gt.count.Add(1)
                gt.size.Add((g.end - g.start) + 1)
        }</span>
}

func (gt *gapTotals) values() (count int64, size int64) <span class="cov1" title="2">{
        if gt != nil </span><span class="cov1" title="2">{
                count = gt.count.Load()
                size = gt.size.Load()
        }</span>
        <span class="cov1" title="2">return</span>
}

func (cdb *PgDB) selectAllGapsStmt(streamID int32) (stmt string) <span class="cov4" title="19">{
        stmt = strings.ReplaceAll(cdb.stmtSelectAllGaps, "STREAMID", fmt.Sprintf("%03d", streamID))
        return
}</span>

func (cdb *PgDB) selectStreamGaps(ctx context.Context, wg *sync.WaitGroup, ls *LogStream, pageSize int, totals *gapTotals) <span class="cov5" title="67">{
        defer wg.Done()

        if ls != nil </span><span class="cov5" title="67">{
                gapCh := ls.getGapCh()
                if gapCh != nil </span><span class="cov5" title="67">{
                        if pageSize &gt; 0 </span><span class="cov5" title="67">{
                                var err error
                                var maxIndex sql.NullInt64
                                if err = cdb.QueryRow(ctx, cdb.stmtSelectMaxIdx, ls.Id).Scan(&amp;maxIndex); err == nil </span><span class="cov5" title="67">{
                                        endIndex := int64(-1)
                                        if maxIndex.Valid </span><span class="cov3" title="6">{
                                                endIndex = maxIndex.Int64
                                        }</span>
                                        <span class="cov5" title="67">if endIndex &gt;= 0 </span><span class="cov3" title="6">{
                                                var lastIndex int64
                                                if err = cdb.QueryRow(ctx, cdb.stmtSelectBackfillIdx, ls.Id).Scan(&amp;lastIndex); err == nil </span><span class="cov3" title="6">{
                                                        for err == nil &amp;&amp; ctx.Err() == nil &amp;&amp; lastIndex &lt; endIndex </span><span class="cov4" title="17">{
                                                                stmt := cdb.selectAllGapsStmt(ls.Id)
                                                                row := cdb.QueryRow(ctx, stmt, ls.Id, lastIndex, endIndex, pageSize)
                                                                var gapStart sql.NullInt64
                                                                var gapEnd sql.NullInt64
                                                                var lastLogIndex sql.NullInt64
                                                                if err = row.Scan(&amp;gapStart, &amp;gapEnd, &amp;lastLogIndex); err == nil </span><span class="cov4" title="17">{
                                                                        advanced := false
                                                                        if gapStart.Valid &amp;&amp; gapEnd.Valid </span><span class="cov3" title="9">{
                                                                                g := gap{start: gapStart.Int64, end: gapEnd.Int64}
                                                                                select </span>{
                                                                                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                                                                case gapCh &lt;- g:<span class="cov3" title="9">
                                                                                        lastIndex = gapEnd.Int64
                                                                                        if totals != nil </span><span class="cov1" title="2">{
                                                                                                totals.add(g)
                                                                                        }</span>
                                                                                        <span class="cov3" title="9">advanced = true</span>
                                                                                }
                                                                        } else<span class="cov3" title="8"> if lastLogIndex.Valid </span><span class="cov3" title="8">{
                                                                                _ = cdb.updateBackfillIndex(ctx, ls, lastLogIndex.Int64)
                                                                        }</span>
                                                                        <span class="cov4" title="17">if !advanced &amp;&amp; ctx.Err() == nil &amp;&amp; lastLogIndex.Valid </span><span class="cov3" title="8">{
                                                                                if lastLogIndex.Int64 &gt; lastIndex </span><span class="cov3" title="8">{
                                                                                        lastIndex = lastLogIndex.Int64
                                                                                        advanced = true
                                                                                }</span>
                                                                        }
                                                                        <span class="cov4" title="17">if !advanced </span><span class="cov0" title="0">{
                                                                                break</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                                <span class="cov5" title="67">_ = cdb.LogError(err, "selectAllGaps.stream", "stream", ls.Id, "url", ls.URL())</span>
                        }
                }
        }
}

func (cdb *PgDB) selectAllGaps(ctx context.Context, wg *sync.WaitGroup) <span class="cov1" title="2">{
        defer wg.Done()

        streams := make(map[int32]*LogStream)

        cdb.mu.Lock()
        for _, logop := range cdb.operators </span><span class="cov3" title="9">{
                logop.mu.Lock()
                for _, ls := range logop.streams </span><span class="cov5" title="63">{
                        if ls.gapCh == nil </span><span class="cov5" title="61">{
                                ls.gapCh = make(chan gap, 1)
                        }</span>
                        <span class="cov5" title="63">streams[ls.Id] = ls</span>
                }
                <span class="cov3" title="9">logop.mu.Unlock()</span>
        }
        <span class="cov1" title="2">cdb.mu.Unlock()

        defer func() </span><span class="cov1" title="2">{
                for _, ls := range streams </span><span class="cov5" title="63">{
                        ls.mu.Lock()
                        if ls.gapCh != nil </span><span class="cov5" title="63">{
                                close(ls.gapCh)
                                ls.gapCh = nil
                        }</span>
                        <span class="cov5" title="63">ls.mu.Unlock()</span>
                }
        }()

        <span class="cov1" title="2">start := time.Now()
        cdb.LogInfo("selectAllGaps starts", "streams", len(streams))

        var totals gapTotals
        if ctx.Err() == nil </span><span class="cov1" title="2">{
                var streamWG sync.WaitGroup
                for _, ls := range streams </span><span class="cov5" title="63">{
                        streamWG.Add(1)
                        go cdb.selectStreamGaps(ctx, &amp;streamWG, ls, max(100, FindGapsBatchSize), &amp;totals)
                }</span>
                <span class="cov1" title="2">streamWG.Wait()</span>
        }

        <span class="cov1" title="2">if ctx.Err() == nil </span><span class="cov1" title="2">{
                totalgaps, totalgapsize := totals.values()
                cdb.LogInfo("selectAllGaps completed", "totalgapsize", totalgapsize, "totalgaps", totalgaps, "elapsed", time.Since(start).Round(time.Second))
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package certstream

type PgDnsname struct {
        Dnsname string
        CertID  int64
}

func ScanDnsname(row Scanner, p *PgDnsname) error <span class="cov0" title="0">{
        return row.Scan(
                &amp;p.Dnsname,
                &amp;p.CertID,
        )
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package certstream

import (
        "time"
)

type PgDnsnamesView struct {
        CertID    int64
        FQDN      string
        NotBefore time.Time
        Idna      bool
        Valid     bool
        PreCert   bool
        Issuer    string
        Subject   string
        Crtsh     string
        Domain    string
        Tld       string
}

func ScanDnsnamesView(row Scanner, dnsname *PgDnsnamesView) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;dnsname.CertID,
                &amp;dnsname.FQDN,
                &amp;dnsname.NotBefore,
                &amp;dnsname.Idna,
                &amp;dnsname.Valid,
                &amp;dnsname.PreCert,
                &amp;dnsname.Issuer,
                &amp;dnsname.Subject,
                &amp;dnsname.Crtsh,
                &amp;dnsname.Domain,
                &amp;dnsname.Tld,
        )
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package certstream

type PgIdent struct {
        Id           int
        Organization string
        Province     string
        Country      string
}

func ScanIdent(row Scanner, ident *PgIdent) error <span class="cov10" title="4">{
        return row.Scan(
                &amp;ident.Id,
                &amp;ident.Organization,
                &amp;ident.Province,
                &amp;ident.Country,
        )
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package certstream

import (
        "time"
)

type PgLogEntry struct {
        Seen     time.Time // CT log entry timestamp
        LogIndex int64     // CT log index for the stream
        CertID   int64     // database ID of cert
        StreamID int32     // database ID of stream
}

func ScanLogEntry(row Scanner, entry *PgLogEntry) (err error) <span class="cov0" title="0">{
        return row.Scan(
                &amp;entry.Seen,
                &amp;entry.LogIndex,
                &amp;entry.CertID,
                &amp;entry.StreamID,
        )
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package certstream

import (
        "fmt"
        "time"
)

type StreamError struct {
        *LogStream
        When time.Time
        Err  error
}

func (ewt StreamError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("%v %s", ewt.When.Format(time.DateTime), ewt.Err.Error())
}</span>

func (ewt StreamError) Unwrap() error <span class="cov10" title="2">{
        return ewt.Err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package certstream

import (
        "crypto/x509"
        "errors"
        "net/http"

        "filippo.io/sunlight"
        "github.com/google/certificate-transparency-go/loglist3"
)

const sunlightUserAgent = "certstream (+https://github.com/linkdata/certstream)"

var ErrSunlightClientMissing = errors.New("sunlight client missing")

func newSunlightClient(log *loglist3.TiledLog, httpClient *http.Client, concurrency int) (client *sunlight.Client, err error) <span class="cov10" title="52">{
        var pub any
        if log != nil </span><span class="cov10" title="52">{
                if pub, err = x509.ParsePKIXPublicKey(log.Key); err == nil </span><span class="cov10" title="52">{
                        cfg := &amp;sunlight.ClientConfig{
                                MonitoringPrefix: log.MonitoringURL,
                                PublicKey:        pub,
                                HTTPClient:       httpClient,
                                UserAgent:        sunlightUserAgent,
                                ConcurrencyLimit: max(concurrency, 1),
                        }
                        client, err = sunlight.NewClient(cfg)
                }</span>
        }
        <span class="cov10" title="52">return</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package certstream

import (
        "context"
        "errors"
        "fmt"
        "slices"
        "sort"
        "sync"

        "github.com/google/certificate-transparency-go/loglist3"
)

func (cs *CertStream) ensureOperator(ctx context.Context, op *loglist3.Operator, opDom string) (logop *LogOperator, err error) <span class="cov8" title="61">{
        cs.mu.Lock()
        logop = cs.operators[opDom]
        cs.mu.Unlock()

        if logop == nil </span><span class="cov4" title="8">{
                logop = &amp;LogOperator{
                        CertStream: cs,
                        operator:   op,
                        Domain:     opDom,
                        streams:    make(map[string]*LogStream),
                }
                sort.Strings(op.Email)
                if db := cs.DB(); db != nil </span><span class="cov4" title="8">{
                        if err = db.ensureOperator(ctx, logop); err == nil </span><span class="cov4" title="8">{
                                cs.mu.Lock()
                                cs.operators[opDom] = logop
                                cs.mu.Unlock()
                        }</span>
                }
        }
        <span class="cov8" title="61">return</span>
}

func (cs *CertStream) ensureOperatorAndLog(ctx context.Context, op *loglist3.Operator, log *loglist3.Log, wg *sync.WaitGroup) (err error) <span class="cov7" title="36">{
        opDom := OperatorDomain(log.URL)

        var logop *LogOperator
        if logop, err = cs.ensureOperator(ctx, op, opDom); err == nil </span><span class="cov7" title="36">{
                err = logop.ensureStream(ctx, log, wg)
        }</span>

        <span class="cov7" title="36">return</span>
}

func (cs *CertStream) ensureOperatorAndTiledLog(ctx context.Context, op *loglist3.Operator, log *loglist3.TiledLog, wg *sync.WaitGroup) (err error) <span class="cov6" title="25">{
        opDom := OperatorDomain(log.MonitoringURL)

        var logop *LogOperator
        if logop, err = cs.ensureOperator(ctx, op, opDom); err == nil </span><span class="cov6" title="25">{
                err = logop.ensureTiledStream(ctx, log, wg)
        }</span>

        <span class="cov6" title="25">return</span>
}

func (cs *CertStream) updateStreams(ctx context.Context, wg *sync.WaitGroup) (err error) <span class="cov1" title="1">{
        defer wg.Done()
        var logList *loglist3.LogList
        if logList, err = getLogList(ctx, cs.HeadClient, loglist3.AllLogListURL); err == nil </span><span class="cov1" title="1">{
                for _, op := range logList.Operators </span><span class="cov6" title="24">{
                        for _, log := range op.Logs </span><span class="cov10" title="187">{
                                if log.State.LogStatus() == loglist3.UsableLogStatus </span><span class="cov7" title="36">{
                                        if e := cs.ensureOperatorAndLog(ctx, op, log, wg); e != nil </span><span class="cov0" title="0">{
                                                err = errors.Join(err, e)
                                        }</span>
                                }
                        }
                        <span class="cov6" title="24">for _, log := range op.TiledLogs </span><span class="cov8" title="60">{
                                if log.State.LogStatus() == loglist3.UsableLogStatus </span><span class="cov6" title="25">{
                                        if e := cs.ensureOperatorAndTiledLog(ctx, op, log, wg); e != nil </span><span class="cov0" title="0">{
                                                err = errors.Join(err, e)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov1" title="1">var operators []string
        for _, lo := range cs.Operators() </span><span class="cov4" title="8">{
                operators = append(operators, fmt.Sprintf("%s*%d", lo.Domain, len(lo.Streams())))
        }</span>
        <span class="cov1" title="1">slices.Sort(operators)
        cs.LogInfo("active", "streams", operators)
        return</span>
}

func (cs *CertStream) removeStream(ls *LogStream) <span class="cov8" title="61">{
        lo := ls.LogOperator
        lo.mu.Lock()
        delete(lo.streams, ls.URL())
        empty := len(lo.streams) == 0
        lo.mu.Unlock()
        if empty </span><span class="cov4" title="8">{
                cs.mu.Lock()
                delete(cs.operators, lo.Domain)
                cs.mu.Unlock()
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package certstream

type wrappedErr struct {
        err error
        msg string
}

func (we wrappedErr) Error() string <span class="cov0" title="0">{
        return we.msg + ": " + we.err.Error()
}</span>

func (we wrappedErr) Unwrap() error <span class="cov0" title="0">{
        return we.err
}</span>

func wrapErr(err error, msg string) error <span class="cov10" title="169">{
        if err == nil </span><span class="cov8" title="69">{
                return nil
        }</span>
        <span class="cov9" title="100">return wrappedErr{err: err, msg: msg}</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
